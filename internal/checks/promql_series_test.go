package checks_test

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/prometheus/common/model"

	"github.com/cloudflare/pint/internal/checks"
	"github.com/cloudflare/pint/internal/promapi"
)

func newSeriesCheck(prom *promapi.FailoverGroup) checks.RuleChecker {
	return checks.NewSeriesCheck(prom)
}

func noMetricText(name, uri, metric, since string) string {
	return fmt.Sprintf(`prometheus %q at %s didn't have any series for %q metric in the last %s`, name, uri, metric, since)
}

func noMetricRRText(name, uri, metric, since string) string {
	return fmt.Sprintf(`prometheus %q at %s didn't have any series for %q metric in the last %s but found recording rule that generates it, skipping further checks`, name, uri, metric, since)
}

func noFilterMatchText(name, uri, metric, label, filter, since string) string {
	return fmt.Sprintf(`prometheus %q at %s has %q metric with %q label but there are no series matching %s in the last %s`, name, uri, metric, label, filter, since)
}

func noLabelKeyText(name, uri, metric, label, since string) string {
	return fmt.Sprintf(`prometheus %q at %s has %q metric but there are no series with %q label in the last %s`, name, uri, metric, label, since)
}

func noSeriesText(name, uri, metric, since string) string {
	return fmt.Sprintf(`prometheus %q at %s didn't have any series for %q metric in the last %s`, name, uri, metric, since)
}

func seriesDisappearedText(name, uri, metric, since string) string {
	return fmt.Sprintf(`prometheus %q at %s doesn't currently have %q, it was last present %s ago`, name, uri, metric, since)
}

func filterDisappeardText(name, uri, metric, filter, since string) string {
	return fmt.Sprintf(`prometheus %q at %s has %q metric but doesn't currently have series matching %s, such series was last present %s ago`, name, uri, metric, filter, since)
}

func filterSometimesText(name, uri, metric, filter, since string) string {
	return fmt.Sprintf(`metric %q with label %s is only sometimes present on prometheus %q at %s with average life span of %s`, metric, filter, name, uri, since)
}

func seriesSometimesText(name, uri, metric, since, avg string) string {
	return fmt.Sprintf(`metric %q is only sometimes present on prometheus %q at %s with average life span of %s in the last %s`, metric, name, uri, avg, since)
}

func alertMissing(metric, alertname string) string {
	return fmt.Sprintf("%s metric is generated by alerts but didn't found any rule named %q", metric, alertname)
}

func metricIgnored(metric, check, re string) string {
	return fmt.Sprintf("Metric name %q matches %q check ignore regexp %q", metric, check, re)
}

func TestSeriesCheck(t *testing.T) {
	testCases := []checkTest{
		{
			description: "ignores rules with syntax errors",
			content:     "- record: foo\n  expr: sum(foo) without(\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems:    noProblems,
		},
		{
			description: "bad response",
			content:     "- record: foo\n  expr: sum(foo)\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: "foo",
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     checkErrorBadData("prom", uri, "bad_data: bad input data"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{requireQueryPath},
					resp:  respondWithBadData(),
				},
			},
		},
		{
			description: "bad uri",
			content:     "- record: foo\n  expr: sum(foo)\n",
			checker:     newSeriesCheck,
			prometheus: func(s string) *promapi.FailoverGroup {
				return simpleProm("prom", "http://", time.Second*5, false)
			},
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: "foo",
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     checkErrorUnableToRun(checks.SeriesCheckName, "prom", "http://", `Post "http:///api/v1/query": http: no Host in request URL`),
						Severity: checks.Warning,
					},
				}
			},
		},
		{
			description: "simple query",
			content:     "- record: foo\n  expr: sum(notfound)\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: "notfound",
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noMetricText("prom", uri, "notfound", "1w"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{requireQueryPath},
					resp:  respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{requireRangeQueryPath},
					resp:  respondWithEmptyMatrix(),
				},
			},
		},
		{
			description: "simple query / duplicated metric",
			content:     "- record: foo\n  expr: count(notfound) / sum(notfound)\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: "notfound",
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noMetricText("prom", uri, "notfound", "1w"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{requireQueryPath},
					resp:  respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{requireRangeQueryPath},
					resp:  respondWithEmptyMatrix(),
				},
			},
		},
		{
			description: "complex query",
			content:     "- record: foo\n  expr: sum(found_7 * on (job) sum(sum(notfound))) / found_7\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: "notfound",
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noMetricText("prom", uri, "notfound", "1w"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: "count(notfound)"},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(notfound)"},
					},
					resp: respondWithEmptyMatrix(),
				},
				{
					conds: []requestCondition{requireQueryPath, formCond{key: "query", value: "count(found_7)"}},
					resp:  respondWithSingleInstantVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "label_replace()",
			content: `
- alert: foo
  expr: |
    count(
      label_replace(
        node_filesystem_readonly{mountpoint!=""},
        "device",
        "$2",
        "device",
        "/dev/(mapper/luks-)?(sd[a-z])[0-9]"
      )
    ) by (device,instance) > 0
    and on (device, instance)
    label_replace(
      disk_info{type="sat",interface_speed!="6.0 Gb/s"},
      "device",
      "$1",
      "disk",
      "/dev/(sd[a-z])"
    )
  for: 5m
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(disk_info{interface_speed!="6.0 Gb/s",type="sat"})`},
					},
					resp: respondWithSingleInstantVector(),
				},
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(node_filesystem_readonly{mountpoint!=""})`},
					},
					resp: respondWithSingleInstantVector(),
				},
			},
		},
		{
			description: "offset",
			content:     "- record: foo\n  expr: node_filesystem_readonly{mountpoint!=\"\"} offset 5m\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems:    noProblems,
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(node_filesystem_readonly{mountpoint!=""})`},
					},
					resp: respondWithSingleInstantVector(),
				},
			},
		},
		{
			description: "negative offset",
			content:     "- record: foo\n  expr: node_filesystem_readonly{mountpoint!=\"\"} offset -15m\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems:    noProblems,
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(node_filesystem_readonly{mountpoint!=""})`},
					},
					resp: respondWithSingleInstantVector(),
				},
			},
		},
		{
			description: "#1 series present",
			content:     "- record: foo\n  expr: found > 0\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems:    noProblems,
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{requireQueryPath},
					resp:  respondWithSingleInstantVector(),
				},
			},
		},
		{
			description: "#1 query error",
			content:     "- record: foo\n  expr: found > 0\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `found`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     checkErrorUnableToRun(checks.SeriesCheckName, "prom", uri, "server_error: server error: 500"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{requireQueryPath},
					resp:  respondWithInternalError(),
				},
			},
		},
		{
			description: "#2 series never present",
			content:     "- record: foo\n  expr: sum(notfound)\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: "notfound",
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noMetricText("prom", uri, "notfound", "1w"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{requireQueryPath},
					resp:  respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{requireRangeQueryPath},
					resp:  respondWithEmptyMatrix(),
				},
			},
		},
		{
			description: "#2 series never present but recording rule provides it correctly",
			content:     "- record: foo\n  expr: sum(foo:bar{job=\"xxx\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			entries:     mustParseContent("- record: foo:bar\n  expr: sum(foo:bar)\n"),
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: "foo:bar",
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noMetricRRText("prom", uri, "foo:bar", "1w"),
						Severity: checks.Information,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(foo:bar{job="xxx"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(foo:bar)`},
					},
					resp: respondWithEmptyMatrix(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#2 series never present but recording rule provides it without results",
			content:     "- record: foo\n  expr: sum(foo:bar{job=\"xxx\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			entries:     mustParseContent("- record: foo:bar\n  expr: sum(foo)\n"),
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: "foo:bar",
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noMetricRRText("prom", uri, "foo:bar", "1w"),
						Severity: checks.Information,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(foo:bar{job="xxx"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(foo:bar)`},
					},
					resp: respondWithEmptyMatrix(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#2 {ALERTS=...} present",
			content:     "- record: foo\n  expr: count(ALERTS{alertname=\"myalert\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			entries:     mustParseContent("- alert: myalert\n  expr: sum(foo) == 0\n"),
			problems:    noProblems,
		},
		{
			description: "#2 {ALERTS=...} missing",
			content:     "- record: foo\n  expr: count(ALERTS{alertname=\"myalert\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			entries:     mustParseContent("- alert: notmyalert\n  expr: sum(foo) == 0\n"),
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `ALERTS{alertname="myalert"}`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     alertMissing(`ALERTS{alertname="myalert"}`, "myalert"),
						Severity: checks.Bug,
					},
				}
			},
		},
		{
			description: "#2 series never present but recording rule provides it, query error",
			content:     "- record: foo\n  expr: sum(foo:bar{job=\"xxx\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			entries:     mustParseContent("- record: foo:bar\n  expr: sum(foo:bar)\n"),
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: "foo:bar",
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noMetricRRText("prom", uri, "foo:bar", "1w"),
						Severity: checks.Information,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(foo:bar{job="xxx"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(foo:bar)`},
					},
					resp: respondWithEmptyMatrix(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#2 query error",
			content:     "- record: foo\n  expr: found > 0\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `found`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     checkErrorUnableToRun(checks.SeriesCheckName, "prom", uri, "server_error: server error: 500"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{requireQueryPath},
					resp:  respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{requireRangeQueryPath},
					resp:  respondWithInternalError(),
				},
			},
		},
		{
			description: "#2 series never present but metric ignored",
			content:     "- record: foo\n  expr: sum(notfound)\n",
			checker:     newSeriesCheck,
			ctx: func() context.Context {
				s := checks.PromqlSeriesSettings{
					IgnoreMetrics: []string{"foo", "bar", "not.+"},
				}
				if err := s.Validate(); err != nil {
					t.Error(err)
					t.FailNow()
				}
				return context.WithValue(context.Background(), checks.SettingsKey(checks.SeriesCheckName), &s)
			},
			prometheus: newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: "notfound",
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noMetricText("prom", uri, "notfound", "1w") + ". " + metricIgnored("notfound", checks.SeriesCheckName, "^not.+$"),
						Severity: checks.Warning,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{requireQueryPath},
					resp:  respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{requireRangeQueryPath},
					resp:  respondWithEmptyMatrix(),
				},
			},
		},
		{
			description: "#3 metric present, label missing",
			content:     "- record: foo\n  expr: sum(found{job=\"foo\", notfound=\"xxx\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `found{job="foo",notfound="xxx"}`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noLabelKeyText("prom", uri, "found", "notfound", "1w"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{job="foo",notfound="xxx"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: respondWithSingleRangeVector1W(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{job=~".+"}) by (job)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"job": "xxx"},
								time.Now().Add(time.Hour*24*-7),
								time.Now(),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{notfound=~".+"}) by (notfound)`},
					},
					resp: respondWithSingleRangeVector1W(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#3 metric present, label query error",
			content:     "- record: foo\n  expr: sum(found{notfound=\"xxx\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `found{notfound="xxx"}`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     checkErrorUnableToRun(checks.SeriesCheckName, "prom", uri, "server_error: server error: 500"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{notfound="xxx"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: respondWithSingleRangeVector1W(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{notfound=~".+"}) by (notfound)`},
					},
					resp: respondWithInternalError(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#4 metric was present but disappeared 50m ago",
			content:     "- record: foo\n  expr: sum(found{job=\"foo\", instance=\"bar\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems:    noProblems,
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{instance="bar",job="foo"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Minute*-50),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{job=~".+"}) by (job)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"job": "foo"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Minute*-50),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{instance=~".+"}) by (instance)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"instance": "bar"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Minute*-50),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#4 metric was present but disappeared over 1h ago",
			content:     "- record: foo\n  expr: sum(found{job=\"foo\", instance=\"bar\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `found`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     seriesDisappearedText("prom", uri, "found", "4d"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{instance="bar",job="foo"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{job=~".+"}) by (job)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"job": "foo"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{instance=~".+"}) by (instance)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"instance": "bar"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#4 metric was present but disappeared over 1h ago / ignored",
			content:     "- record: foo\n  expr: sum(found{job=\"foo\", instance=\"bar\"})\n",
			checker:     newSeriesCheck,
			ctx: func() context.Context {
				s := checks.PromqlSeriesSettings{
					IgnoreMetrics: []string{"foo", "found", "not.+"},
				}
				if err := s.Validate(); err != nil {
					t.Error(err)
					t.FailNow()
				}
				return context.WithValue(context.Background(), checks.SettingsKey(checks.SeriesCheckName), &s)
			},
			prometheus: newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `found`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     seriesDisappearedText("prom", uri, "found", "4d") + ". " + metricIgnored("found", checks.SeriesCheckName, "^found$"),
						Severity: checks.Warning,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{instance="bar",job="foo"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{job=~".+"}) by (job)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"job": "foo"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{instance=~".+"}) by (instance)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"instance": "bar"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#4 metric was present but disappeared / min-age / ok",
			content: `
- record: foo
  # pint rule/set promql/series min-age 5d
  expr: sum(found{job="foo", instance="bar"})
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{instance="bar",job="foo"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{job=~".+"}) by (job)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"job": "foo"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{instance=~".+"}) by (instance)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"instance": "bar"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#4 metric was present but disappeared / min-age / match",
			content: `
- record: foo
  # pint rule/set promql/series(found) min-age 5d
  expr: sum(found{job="foo", instance="bar"})
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{instance="bar",job="foo"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{job=~".+"}) by (job)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"job": "foo"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{instance=~".+"}) by (instance)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"instance": "bar"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#4 metric was present but disappeared / min-age / fail",
			content: `
- record: foo
  # pint rule/set promql/series min-age 3d
  expr: sum(found{job="foo", instance="bar"})
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `found`,
						Lines:    []int{4},
						Reporter: checks.SeriesCheckName,
						Text:     seriesDisappearedText("prom", uri, "found", "4d"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{instance="bar",job="foo"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{job=~".+"}) by (job)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"job": "foo"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{instance=~".+"}) by (instance)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"instance": "bar"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#4 metric was present but disappeared / min-age / mismatch",
			content: `
- record: foo
  # pint rule/set promql/series(bar) min-age 5d
  expr: sum(found{job="foo", instance="bar"})
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `found`,
						Lines:    []int{4},
						Reporter: checks.SeriesCheckName,
						Text:     seriesDisappearedText("prom", uri, "found", "4d"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{instance="bar",job="foo"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{job=~".+"}) by (job)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"job": "foo"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{instance=~".+"}) by (instance)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"instance": "bar"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#4 metric was present but disappeared / min-age / invalid value",
			content: `
- record: foo
  # pint rule/set promql/series(found) min-age foo
  expr: sum(found{job="foo", instance="bar"})
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `rule/set promql/series(found) min-age foo`,
						Lines:    []int{2, 3, 4},
						Reporter: checks.SeriesCheckName,
						Text:     `failed to parse pint comment as duration: not a valid duration string: "foo"`,
						Severity: checks.Warning,
					},
					{
						Fragment: `found`,
						Lines:    []int{4},
						Reporter: checks.SeriesCheckName,
						Text:     seriesDisappearedText("prom", uri, "found", "4d"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{instance="bar",job="foo"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{job=~".+"}) by (job)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"job": "foo"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{instance=~".+"}) by (instance)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"instance": "bar"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4).Add(time.Minute*-5),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#5 metric was present but not with label value",
			content:     "- record: foo\n  expr: sum(found{notfound=\"notfound\", instance=~\".+\", not!=\"negative\", instance!~\"bad\"})\n",
			checker:     newSeriesCheck,
			ctx: func() context.Context {
				s := checks.PromqlSeriesSettings{
					IgnoreMetrics: []string{"foo", "bar", "found"},
				}
				if err := s.Validate(); err != nil {
					t.Error(err)
					t.FailNow()
				}
				return context.WithValue(context.Background(), checks.SettingsKey(checks.SeriesCheckName), &s)
			},
			prometheus: newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `found{instance!~"bad",instance=~".+",not!="negative",notfound="notfound"}`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noFilterMatchText("prom", uri, "found", "notfound", `{notfound="notfound"}`, "1w") + ". " + metricIgnored("found", checks.SeriesCheckName, "^found$"),
						Severity: checks.Warning,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{instance!~"bad",instance=~".+",not!="negative",notfound="notfound"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: respondWithSingleRangeVector1W(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{instance=~".+"}) by (instance)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"instance": "bar"},
								time.Now().Add(time.Hour*24*-7),
								time.Now(),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{not=~".+"}) by (not)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"not": "yyy"},
								time.Now().Add(time.Hour*24*-7),
								time.Now(),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{notfound=~".+"}) by (notfound)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"notfound": "found"},
								time.Now().Add(time.Hour*24*-7),
								time.Now(),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{instance=~".+"})`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"instance": "bar"},
								time.Now().Add(time.Hour*24*-7),
								time.Now(),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{notfound="notfound"})`},
					},
					resp: respondWithEmptyMatrix(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#5 metric was present but not with label value / ignored metric",
			content:     "- record: foo\n  expr: sum(found{notfound=\"notfound\", instance=~\".+\", not!=\"negative\", instance!~\"bad\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `found{instance!~"bad",instance=~".+",not!="negative",notfound="notfound"}`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noFilterMatchText("prom", uri, "found", "notfound", `{notfound="notfound"}`, "1w"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{instance!~"bad",instance=~".+",not!="negative",notfound="notfound"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: respondWithSingleRangeVector1W(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{instance=~".+"}) by (instance)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"instance": "bar"},
								time.Now().Add(time.Hour*24*-7),
								time.Now(),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{not=~".+"}) by (not)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"not": "yyy"},
								time.Now().Add(time.Hour*24*-7),
								time.Now(),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{notfound=~".+"}) by (notfound)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"notfound": "found"},
								time.Now().Add(time.Hour*24*-7),
								time.Now(),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{instance=~".+"})`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"instance": "bar"},
								time.Now().Add(time.Hour*24*-7),
								time.Now(),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{notfound="notfound"})`},
					},
					resp: respondWithEmptyMatrix(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#5 label query error",
			content:     "- record: foo\n  expr: sum(found{error=\"xxx\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `found{error="xxx"}`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     checkErrorUnableToRun(checks.SeriesCheckName, "prom", uri, "server_error: server error: 500"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{error="xxx"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: respondWithSingleRangeVector1W(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{error=~".+"}) by (error)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"error": "bar"},
								time.Now().Add(time.Hour*24*-7),
								time.Now(),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{error="xxx"})`},
					},
					resp: respondWithInternalError(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#5 high churn labels",
			content:     "- record: foo\n  expr: sum(sometimes{churn=\"notfound\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `sometimes{churn="notfound"}`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noFilterMatchText("prom", uri, "sometimes", "churn", `{churn="notfound"}`, "1w") + `, "churn" looks like a high churn label`,
						Severity: checks.Warning,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(sometimes{churn="notfound"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(sometimes)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-7).Add(time.Hour),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-5),
								time.Now().Add(time.Hour*24*-5).Add(time.Minute*10),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-2),
								time.Now().Add(time.Hour*24*-2).Add(time.Minute*20),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(sometimes{churn=~".+"}) by (churn)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"churn": "aaa"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-7).Add(time.Hour),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{"churn": "bbb"},
								time.Now().Add(time.Hour*24*-5),
								time.Now().Add(time.Hour*24*-5).Add(time.Minute*10),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{"churn": "ccc"},
								time.Now().Add(time.Hour*24*-2),
								time.Now().Add(time.Hour*24*-2).Add(time.Minute*20),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(sometimes{churn="notfound"})`},
					},
					resp: respondWithEmptyMatrix(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#5 ignored label value",
			content: `
- record: foo
  # pint rule/set promql/series ignore/label-value error
  expr: sum(foo{error="notfound"})
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(foo{error="notfound"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(foo)`},
					},
					resp: respondWithSingleRangeVector1W(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(foo{error=~".+"}) by (error)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"error": "yyy"},
								time.Now().Add(time.Hour*24*-7),
								time.Now(),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#6 metric was always present but label disappeared",
			content:     "- record: foo\n  expr: sum({__name__=\"found\", removed=\"xxx\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `found{removed="xxx"}`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     filterDisappeardText("prom", uri, "found", `{removed="xxx"}`, "5d16h"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count({__name__="found",removed="xxx"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: respondWithSingleRangeVector1W(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{removed=~".+"}) by (removed)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"removed": "xxx"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-6).Add(time.Hour*8),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{removed="xxx"})`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-6).Add(time.Hour*8),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#6 metric was always present but label disappeared / invalid min-age",
			content: `
# pint rule/set promql/series(found) min-age 1e
- record: foo
  expr: sum({__name__="found", removed="xxx"})
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `rule/set promql/series(found) min-age 1e`,
						Lines:    []int{3, 4},
						Reporter: checks.SeriesCheckName,
						Text:     `failed to parse pint comment as duration: not a valid duration string: "1e"`,
						Severity: checks.Warning,
					},
					{
						Fragment: `found{removed="xxx"}`,
						Lines:    []int{4},
						Reporter: checks.SeriesCheckName,
						Text:     filterDisappeardText("prom", uri, "found", `{removed="xxx"}`, "5d16h"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count({__name__="found",removed="xxx"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: respondWithSingleRangeVector1W(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{removed=~".+"}) by (removed)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"removed": "xxx"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-6).Add(time.Hour*8),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{removed="xxx"})`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-6).Add(time.Hour*8),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#6 metric was always present but label disappeared / less than min-age",
			content: `
# pint rule/set promql/series(found) min-age 3h
- record: foo
  expr: sum({__name__="found", removed="xxx"})
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count({__name__="found",removed="xxx"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: respondWithSingleRangeVector1W(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{removed=~".+"}) by (removed)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"removed": "xxx"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Minute*-150),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{removed="xxx"})`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Minute*-150),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#7 metric was always present but label only sometimes",
			content:     "- record: foo\n  expr: sum(found{sometimes=\"xxx\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `found{sometimes="xxx"}`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     filterSometimesText("prom", uri, `found`, `{sometimes="xxx"}`, "18h43m20s"),
						Severity: checks.Warning,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{sometimes="xxx"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found)`},
					},
					resp: respondWithSingleRangeVector1W(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{sometimes=~".+"}) by (sometimes)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"sometimes": "aaa"},
								time.Now().Add(time.Hour*24*-7),
								time.Now(),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{"sometimes": "bbb"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-4),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{"sometimes": "xxx"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-6).Add(time.Hour*8),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{"sometimes": "xxx"},
								time.Now().Add(time.Hour*24*-5),
								time.Now().Add(time.Hour*24*-4),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{"sometimes": "xxx"},
								time.Now().Add(time.Hour*24*-2),
								time.Now().Add(time.Hour*24*-2),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{sometimes="xxx"})`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-6).Add(time.Hour*8),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-4),
								time.Now().Add(time.Hour*24*-3),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-1),
								time.Now().Add(time.Hour*24*-1),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#8 metric is sometimes present",
			content:     "- record: foo\n  expr: sum(sometimes{foo!=\"bar\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `sometimes`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     seriesSometimesText("prom", uri, "sometimes", "1w", "33m20s"),
						Severity: checks.Warning,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(sometimes{foo!="bar"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(sometimes)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-7).Add(time.Hour),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-5),
								time.Now().Add(time.Hour*24*-5).Add(time.Minute*10),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-2),
								time.Now().Add(time.Hour*24*-2).Add(time.Minute*20),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(sometimes{foo=~".+"}) by (foo)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"foo": "aaa"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-7).Add(time.Hour),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{"foo": "bbb"},
								time.Now().Add(time.Hour*24*-5),
								time.Now().Add(time.Hour*24*-5).Add(time.Minute*10),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{"foo": "ccc"},
								time.Now().Add(time.Hour*24*-2),
								time.Now().Add(time.Hour*24*-2).Add(time.Minute*20),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "#8 metric is sometimes present due to prometheus downtime",
			content:     "- record: foo\n  expr: sum(sometimes{foo!=\"bar\"})\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems:    noProblems,
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(sometimes{foo!="bar"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(sometimes)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-3).Add(time.Minute*-5),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-3).Add(time.Hour),
								time.Now(),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(sometimes{foo=~".+"}) by (foo)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"foo": "aaa"},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-7).Add(time.Hour),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{"foo": "bbb"},
								time.Now().Add(time.Hour*24*-5),
								time.Now().Add(time.Hour*24*-5).Add(time.Minute*10),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{"foo": "ccc"},
								time.Now().Add(time.Hour*24*-2),
								time.Now().Add(time.Hour*24*-2).Add(time.Minute*20),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-7),
								time.Now().Add(time.Hour*24*-3).Add(time.Minute*-5),
								time.Minute*5,
							),
							generateSampleStream(
								map[string]string{},
								time.Now().Add(time.Hour*24*-3).Add(time.Hour),
								time.Now(),
								time.Minute*5,
							),
						},
					},
				},
			},
		},
		{
			description: "series found, label missing",
			content:     "- record: foo\n  expr: found{job=\"notfound\"}\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `found{job="notfound"}`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noFilterMatchText("prom", uri, "found", "job", `{job="notfound"}`, "1w"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(found{job="notfound"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(found)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{job=~".+"}) by (job)`},
					},
					resp: matrixResponse{
						samples: []*model.SampleStream{
							generateSampleStream(
								map[string]string{"job": "found"},
								time.Now().Add(time.Hour*24*-7),
								time.Now(),
								time.Minute*5,
							),
						},
					},
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(found{job="notfound"})`},
					},
					resp: respondWithEmptyMatrix(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "series missing, label missing",
			content:     "- record: foo\n  expr: notfound{job=\"notfound\"}\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: "notfound",
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noSeriesText("prom", uri, "notfound", "1w"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(notfound{job="notfound"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(notfound)"},
					},
					resp: respondWithEmptyMatrix(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "series missing, {__name__=}",
			content: `
- record: foo
  expr: '{__name__="notfound", job="bar"}'
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `notfound`,
						Lines:    []int{3},
						Reporter: checks.SeriesCheckName,
						Text:     noSeriesText("prom", uri, "notfound", "1w"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count({__name__="notfound",job="bar"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(notfound)`},
					},
					resp: respondWithEmptyMatrix(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "series missing but check disabled",
			content: `
# pint disable promql/series(notfound)
- record: foo
  expr: count(notfound) == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
		},
		{
			description: "series missing, selector disabled",
			content: `
# pint disable promql/series(notfound{job="foo"})
- record: foo
  expr: count(notfound{job="foo"}) == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
		},
		{
			description: "series missing, multi-label selector disabled",
			content: `
# pint disable promql/series(notfound{job="foo", instance="xxx"})
- record: foo
  expr: count(notfound{job="foo", instance="xxx"}) == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
		},
		{
			description: "series missing, multi-label selector disabled with different order",
			content: `
- record: foo
  # pint disable promql/series(notfound{job="foo", instance="xxx"})
  expr: count(notfound{instance="xxx",job="foo"}) == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
		},
		{
			description: "series missing, multi-label selector disabled with subset of labels",
			content: `
# pint disable promql/series(notfound{job="foo"})    
- record: foo
  expr: count(notfound{instance="xxx",job="foo"}) == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
		},
		{
			description: "series missing, series disabled",
			content: `
# pint disable promql/series(notfound)
- record: foo
  expr: count(notfound{job="foo"}) == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
		},
		{
			description: "series missing, series disabled",
			content: `
# pint disable promql/series(notfound)
- record: foo
  expr: notfound == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
		},
		{
			description: "series missing, labels disabled",
			content: `
# pint disable promql/series({job="foo"})
- record: foo
  expr: count(notfound{job="foo"}) == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
		},
		{
			description: "series missing, multi-label selector disabled with __name__",
			content: `
# pint disable promql/series({job="foo", __name__="notfound", instance="xxx"})    
- record: foo
  expr: count(notfound{instance="xxx",cluster="dev", job="foo"}) == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
		},
		{
			description: "series missing, labels disabled, regexp",
			content: `
# pint disable promql/series({job=~"foo"})
- record: foo
  expr: count(notfound{job=~"foo", instance!="bob"}) == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
		},
		{
			description: "series missing, disable comment with labels, regexp selector",
			content: `
# pint disable promql/series({job="foo"})
- record: foo
  expr: count(notfound{job=~"foo"}) == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: "notfound",
						Lines:    []int{4},
						Reporter: checks.SeriesCheckName,
						Text:     noMetricText("prom", uri, "notfound", "1w"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{requireQueryPath},
					resp:  respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{requireRangeQueryPath},
					resp:  respondWithEmptyMatrix(),
				},
			},
		},
		{
			description: "series missing, disable comment with labels, invalid selector",
			content: `
# pint disable promql/series(notfound{job=foo})
- record: foo
  expr: count(notfound{job=~"foo"}) == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: "notfound",
						Lines:    []int{4},
						Reporter: checks.SeriesCheckName,
						Text:     noMetricText("prom", uri, "notfound", "1w"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{requireQueryPath},
					resp:  respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{requireRangeQueryPath},
					resp:  respondWithEmptyMatrix(),
				},
			},
		},
		{
			description: "series missing but check disabled, labels",
			content: `
# pint disable promql/series(notfound)
- record: foo
  expr: count(notfound{job="foo"}) == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
		},
		{
			description: "series missing but check disabled, negative labels",
			content: `
# pint disable promql/series(notfound)
- record: foo
  expr: count(notfound{job!="foo"}) == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
		},
		{
			description: "series missing, disabled comment for labels",
			content: `
# pint disable promql/series(notfound{job="foo"})
- record: foo
  expr: count(notfound) == 0
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `notfound`,
						Lines:    []int{4},
						Reporter: checks.SeriesCheckName,
						Text:     noSeriesText("prom", uri, "notfound", "1w"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(notfound)`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(notfound)`},
					},
					resp: respondWithEmptyMatrix(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "alert rule using 2 recording rules",
			content:     "- alert: foo\n  expr: sum(foo:count) / sum(foo:sum) > 120\n",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			entries:     mustParseContent("- record: foo:count\n  expr: count(foo)\n- record: foo:sum\n  expr: sum(foo)\n"),
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: "foo:count",
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noMetricRRText("prom", uri, "foo:count", "1w"),
						Severity: checks.Information,
					},
					{
						Fragment: "foo:sum",
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noMetricRRText("prom", uri, "foo:sum", "1w"),
						Severity: checks.Information,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(foo:count)`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(foo:count)`},
					},
					resp: respondWithEmptyMatrix(),
				},

				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count(foo:sum)`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count(foo:sum)`},
					},
					resp: respondWithEmptyMatrix(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "__name__=~foo|bar",
			content:     "- alert: NameRegex\n  expr: rate({__name__=~\"(foo|bar)_panics_total\", job=\"myjob\"}[2m]) > 0",
			checker:     newSeriesCheck,
			prometheus:  newSimpleProm,
			problems: func(uri string) []checks.Problem {
				return []checks.Problem{
					{
						Fragment: `{__name__=~"(foo|bar)_panics_total"}`,
						Lines:    []int{2},
						Reporter: checks.SeriesCheckName,
						Text:     noSeriesText("prom", uri, `{__name__=~"(foo|bar)_panics_total"}`, "1w"),
						Severity: checks.Bug,
					},
				}
			},
			mocks: []*prometheusMock{
				{
					conds: []requestCondition{
						requireQueryPath,
						formCond{key: "query", value: `count({__name__=~"(foo|bar)_panics_total",job="myjob"})`},
					},
					resp: respondWithEmptyVector(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: `count({__name__=~"(foo|bar)_panics_total"})`},
					},
					resp: respondWithEmptyMatrix(),
				},
				{
					conds: []requestCondition{
						requireRangeQueryPath,
						formCond{key: "query", value: "count(up)"},
					},
					resp: respondWithSingleRangeVector1W(),
				},
			},
		},
		{
			description: "multiple comments",
			content: `
- alert: Purge_Queue_Size
  # coreless_purge_queue_colo_queue_size_min can be ignored
  # pint disable promql/series(coreless_purge_queue_colo_queue_size_min)
  # coreless_purge_queue_colo_queue_size_median can be ignored
  # pint disable promql/series(coreless_purge_queue_colo_queue_size_median)
  expr: coreless_purge_queue_colo_queue_size_min > 50 or coreless_purge_queue_colo_queue_size_median > 100
`,
			checker:    newSeriesCheck,
			prometheus: newSimpleProm,
			problems:   noProblems,
		},
	}
	runTests(t, testCases)
}
