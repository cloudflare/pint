
[TestLabelsSource/1 - 1]
expr: "1"
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo: null
      deadlabels: []
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/2 - 1]
expr: 1 / 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo: null
      deadlabels: []
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 1 / 5
        valueposition:
            start: 0
            end: 1
        returnednumber: 0.2
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/3 - 1]
expr: (2 ^ 5) == bool 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo:
        reason: '`2 ^ 5 == 5` always evaluates to `32 == 5` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      deadlabels: []
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 32
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/4 - 1]
expr: (2 ^ 5 + 11) % 5 <= bool 2
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo:
        reason: '`2 ^ 5 + 11 % 5 <= 2` always evaluates to `3 <= 2` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      deadlabels: []
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/5 - 1]
expr: (2 ^ 5 + 11) % 5 >= bool 20
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo:
        reason: '`2 ^ 5 + 11 % 5 >= 20` always evaluates to `3 >= 20` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      deadlabels: []
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/6 - 1]
expr: (2 ^ 5 + 11) % 5 <= bool 3
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo: null
      deadlabels: []
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/7 - 1]
expr: (2 ^ 5 + 11) % 5 < bool 1
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo:
        reason: '`2 ^ 5 + 11 % 5 < 1` always evaluates to `3 < 1` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      deadlabels: []
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/8 - 1]
expr: 20 - 15 < bool 1
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 2
      deadinfo:
        reason: '`20 - 15 < 1` always evaluates to `5 < 1` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 0
            end: 2
      deadlabels: []
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 20 - 15
        valueposition:
            start: 0
            end: 2
        returnednumber: 5
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/9 - 1]
expr: 2 * 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo: null
      deadlabels: []
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 * 5
        valueposition:
            start: 0
            end: 1
        returnednumber: 10
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/10 - 1]
expr: (foo or bar) * 5
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 11
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/11 - 1]
expr: (foo or vector(2)) * 5
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 8
                end: 14
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "2"
          node: '[*parser.Call] vector(2)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: vector(2) * 5
        valueposition:
            start: 8
            end: 17
        returnednumber: 10
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 8
        end: 17
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/12 - 1]
expr: (foo or vector(5)) * (vector(2) or bar)
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 39
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 22
                        end: 28
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - args:
                    - "2"
                  node: '[*parser.Call] vector(2)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 22
                    end: 31
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 22
                end: 31
            type: function
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo:
                reason: The left hand side always returs something and so the right hand side is never used.
                fragment:
                    start: 35
                    end: 38
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 35
                end: 38
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 8
                end: 14
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 39
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "5"
          node: '[*parser.Call] vector(5)'
          op: vector
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 22
                        end: 28
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - args:
                    - "2"
                  node: '[*parser.Call] vector(2)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 22
                    end: 31
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 22
                end: 31
            type: function
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo:
                reason: The left hand side always returs something and so the right hand side is never used.
                fragment:
                    start: 35
                    end: 38
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 35
                end: 38
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: vector(5) * vector(2)
        valueposition:
            start: 8
            end: 17
        returnednumber: 10
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 8
        end: 17
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/13 - 1]
expr: 1 > bool 0
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo: null
      deadlabels: []
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/14 - 1]
expr: 20 > bool 10
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 2
      deadinfo: null
      deadlabels: []
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 2
        returnednumber: 20
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/15 - 1]
expr: '"test"'
output:
    - labels:
        "":
            reason: This query returns a string value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      deadlabels: []
      returns: string
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 6
      type: string
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/16 - 1]
expr: foo
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/17 - 1]
expr: (foo > 1) > bool 1
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/18 - 1]
expr: foo > bool 5
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/19 - 1]
expr: foo > bool 5 == 1
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/20 - 1]
expr: foo > bool bar
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 14
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 11
                end: 14
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/21 - 1]
expr: (foo > bool bar) == 0
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 15
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 12
                end: 15
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/22 - 1]
expr: foo > bool on(instance) bar
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 11
                end: 23
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 27
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 14
                end: 22
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 24
                end: 27
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/23 - 1]
expr: (foo > bool on(instance) bar) == 1
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 12
                end: 24
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 28
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 15
                end: 23
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 25
                end: 28
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/24 - 1]
expr: foo > bool on(instance) group_left(version) bar
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 47
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 14
                end: 22
        version:
            reason: Query is using `group_left(version)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 35
                end: 42
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - version
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 44
                end: 47
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/25 - 1]
expr: bar > bool on(instance) group_right(version) foo
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 48
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 14
                end: 22
        version:
            reason: Query is using `group_right(version)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 36
                end: 43
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - version
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 3
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 45
        end: 48
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/26 - 1]
expr: foo and bar > bool 0
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: true
            position:
                start: 8
                end: 11
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/27 - 1]
expr: foo offset 5m
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo offset 5m'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 13
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/28 - 1]
expr: foo{job="bar"}
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="bar"}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/29 - 1]
expr: foo{job=""}
output:
    - labels:
        job:
            reason: Query uses `{job=""}` selector which will filter out any time series with the `job` label set.
            kind: excluded
            fragment:
                start: 0
                end: 11
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job=""}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 11
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/30 - 1]
expr: foo{job="bar"} or bar{job="foo"}
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="bar"}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 18
                end: 32
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{job="foo"}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 18
        end: 32
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/31 - 1]
expr: foo{a="bar"} or bar{b="foo"}
output:
    - labels:
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 12
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="bar"}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 12
      type: selector
      fixedlabels: false
      isconditional: false
    - labels:
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 16
                end: 28
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{b="foo"}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 16
        end: 28
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/32 - 1]
expr: foo[5m]
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: matrix
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/33 - 1]
expr: prometheus_build_info[2m:1m]
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_build_info'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 21
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/34 - 1]
expr: deriv(rate(distance_covered_meters_total[1m])[5m:1m])
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] distance_covered_meters_total'
          op: ""
        - node: '[*parser.Call] rate(distance_covered_meters_total[1m])'
          op: rate
        - node: '[*parser.Call] deriv(rate(distance_covered_meters_total[1m])[5m:1m])'
          op: deriv
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 52
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/35 - 1]
expr: foo - 1
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/36 - 1]
expr: foo / 5
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/37 - 1]
expr: -foo
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/38 - 1]
expr: sum(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo{job="myjob"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/39 - 1]
expr: sum(count(foo{job="myjob"}) by(instance))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 41
        instance:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        job:
            reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 28
                end: 40
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] count by (instance) (foo{job="myjob"})'
          op: count
        - node: '[*parser.AggregateExpr] sum(count by (instance) (foo{job="myjob"}))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 10
        end: 26
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/40 - 1]
expr: sum(foo{job="myjob"}) > 20
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo{job="myjob"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/41 - 1]
expr: sum(foo{job="myjob"}) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 30
                end: 33
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (job) (foo{job="myjob"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/42 - 1]
expr: sum(foo) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 9
                end: 11
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 16
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 12
                end: 15
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job) (foo)'
          op: sum
      joins: []
      unless: []
      usedLabels:
        - job
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 7
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/43 - 1]
expr: sum(foo{job="myjob"}) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 22
                end: 24
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 29
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job) (foo{job="myjob"})'
          op: sum
      joins: []
      unless: []
      usedLabels:
        - job
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/44 - 1]
expr: abs(foo{job="myjob"} offset 5m)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 31
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"} offset 5m'
          op: ""
        - node: '[*parser.Call] abs(foo{job="myjob"} offset 5m)'
          op: abs
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 30
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/45 - 1]
expr: abs(foo{job="myjob"} or bar{cluster="dev"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 43
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.Call] abs(foo{job="myjob"} or bar{cluster="dev"})'
          op: abs
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 42
      type: function
      fixedlabels: false
      isconditional: false
    - labels:
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 43
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{cluster="dev"}'
          op: ""
        - node: '[*parser.Call] abs(foo{job="myjob"} or bar{cluster="dev"})'
          op: abs
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 42
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/46 - 1]
expr: sum(foo{job="myjob"} or bar{cluster="dev"}) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 61
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 52
                end: 60
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"} or bar{cluster="dev"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: false
      isconditional: false
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 61
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 24
                end: 42
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 52
                end: 60
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{cluster="dev"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"} or bar{cluster="dev"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 42
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/47 - 1]
expr: sum(foo{job="myjob"}) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 39
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 30
                end: 38
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/48 - 1]
expr: min(foo{job="myjob"}) / max(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 45
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] min(foo{job="myjob"})'
          op: min
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 27
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
                job:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 27
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{job="myjob"}'
                  op: ""
                - node: '[*parser.AggregateExpr] max(foo{job="myjob"})'
                  op: max
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 28
                end: 44
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/49 - 1]
expr: max(foo{job="myjob"}) / min(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 45
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] max(foo{job="myjob"})'
          op: max
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 27
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
                job:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 27
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{job="myjob"}'
                  op: ""
                - node: '[*parser.AggregateExpr] min(foo{job="myjob"})'
                  op: min
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 28
                end: 44
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/50 - 1]
expr: avg(foo{job="myjob"}) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 22
                end: 24
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 29
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] avg by (job) (foo{job="myjob"})'
          op: avg
      joins: []
      unless: []
      usedLabels:
        - job
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/51 - 1]
expr: group(foo) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 11
                end: 13
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 18
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 14
                end: 17
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] group by (job) (foo)'
          op: group
      joins: []
      unless: []
      usedLabels:
        - job
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 9
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/52 - 1]
expr: stddev(rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[5m])'
          op: rate
        - node: '[*parser.AggregateExpr] stddev(rate(foo[5m]))'
          op: stddev
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 12
        end: 19
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/53 - 1]
expr: stdvar(rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[5m])'
          op: rate
        - node: '[*parser.AggregateExpr] stdvar(rate(foo[5m]))'
          op: stdvar
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 12
        end: 19
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/54 - 1]
expr: stddev_over_time(foo[5m])
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] stddev_over_time(foo[5m])'
          op: stddev_over_time
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 17
        end: 24
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/55 - 1]
expr: stdvar_over_time(foo[5m])
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] stdvar_over_time(foo[5m])'
          op: stdvar_over_time
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 17
        end: 24
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/56 - 1]
expr: quantile(0.9, rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 28
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[5m])'
          op: rate
        - args:
            - "0.9"
          node: '[*parser.AggregateExpr] quantile(0.9, rate(foo[5m]))'
          op: quantile
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 19
        end: 26
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/57 - 1]
expr: count_values("version", build_version)
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 12
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 38
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] build_version'
          op: ""
        - args:
            - '"version"'
          node: '[*parser.AggregateExpr] count_values("version", build_version)'
          op: count_values
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 37
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/58 - 1]
expr: count_values("version", build_version) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 51
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 47
                end: 50
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 51
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] build_version'
          op: ""
        - args:
            - '"version"'
          node: '[*parser.AggregateExpr] count_values without (job) ("version", build_version)'
          op: count_values
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 37
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/59 - 1]
expr: count_values("version", build_version{job="foo"}) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 62
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 58
                end: 61
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 62
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] build_version{job="foo"}'
          op: ""
        - args:
            - '"version"'
          node: '[*parser.AggregateExpr] count_values without (job) ("version", build_version{job="foo"})'
          op: count_values
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 48
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/60 - 1]
expr: count_values("version", build_version) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 39
                end: 41
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 46
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 42
                end: 45
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 46
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] build_version'
          op: ""
        - args:
            - '"version"'
          node: '[*parser.AggregateExpr] count_values by (job) ("version", build_version)'
          op: count_values
      joins: []
      unless: []
      usedLabels:
        - job
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 37
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/61 - 1]
expr: topk(10, foo{job="myjob"}) > 10
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 9
                end: 25
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, foo{job="myjob"})'
          op: topk
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 25
      type: aggregation
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/62 - 1]
expr: topk(10, foo or bar)
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, foo or bar)'
          op: topk
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 12
      type: aggregation
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, foo or bar)'
          op: topk
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 16
        end: 19
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/63 - 1]
expr: rate(foo[10m])
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[10m])'
          op: rate
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 13
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/64 - 1]
expr: sum(rate(foo[10m])) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 37
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 28
                end: 36
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[10m])'
          op: rate
        - node: '[*parser.AggregateExpr] sum without (instance) (rate(foo[10m]))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 17
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/65 - 1]
expr: foo{job="foo"} / bar
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 20
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 17
                end: 20
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/66 - 1]
expr: foo{job="foo"} * on(instance) bar
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 17
                end: 29
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 33
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 20
                end: 28
        job:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 17
                end: 29
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 30
                end: 33
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/67 - 1]
expr: foo{job="foo"} * on(instance) group_left(bar) bar
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 49
        bar:
            reason: Query is using `group_left(bar)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 41
                end: 44
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 20
                end: 28
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - bar
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 46
                end: 49
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/68 - 1]
expr: foo{job="foo"} * on(instance) group_left(cluster) bar{cluster="bar", ignored="true"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 84
        cluster:
            reason: Query is using `group_left(cluster)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 41
                end: 48
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 20
                end: 28
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - cluster
          src:
            labels:
                cluster:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 50
                        end: 84
                ignored:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 50
                        end: 84
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{cluster="bar",ignored="true"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 50
                end: 84
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/69 - 1]
expr: foo{job="foo", ignored="true"} * on(instance) group_right(job) bar{cluster="bar"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 81
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 63
                end: 81
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 36
                end: 44
        job:
            reason: Query is using `group_right(job)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 58
                end: 61
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{cluster="bar"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - job
          src:
            labels:
                ignored:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 0
                        end: 30
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 0
                        end: 30
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{ignored="true",job="foo"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 30
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 63
        end: 81
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/70 - 1]
expr: count(foo / bar)
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 5
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 16
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] count(foo / bar)'
          op: count
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 12
                end: 15
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 1
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 9
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/71 - 1]
expr: count(up{job="a"} / on () up{job="b"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 5
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 38
        job:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 20
                end: 25
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="a"}'
          op: ""
        - node: '[*parser.AggregateExpr] count(up{job="a"} / on () up{job="b"})'
          op: count
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 26
                        end: 37
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] up{job="b"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 26
                end: 37
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 1
          ison: true
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 17
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/72 - 1]
expr: count(up{job="a"} / on (env) up{job="b"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 5
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 41
        env:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 5
        job:
            reason: Query is using one-to-one vector matching with `on(env)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 20
                end: 28
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="a"}'
          op: ""
        - node: '[*parser.AggregateExpr] count(up{job="a"} / on (env) up{job="b"})'
          op: count
      joins:
        - matchinglabels:
            - env
          addedlabels: []
          src:
            labels:
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 29
                        end: 40
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] up{job="b"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 29
                end: 40
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 1
          ison: true
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 17
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/73 - 1]
expr: foo{job="foo", instance="1"} and bar
output:
    - labels:
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{instance="1",job="foo"}'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 33
                end: 36
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57389
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 28
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/74 - 1]
expr: foo{job="foo", instance="1"} and on(cluster) bar
output:
    - labels:
        cluster:
            reason: Query is using many-to-many vector matching with `on(cluster)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 36
                end: 43
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{instance="1",job="foo"}'
          op: ""
      joins:
        - matchinglabels:
            - cluster
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 45
                end: 48
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57389
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - cluster
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 28
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/75 - 1]
expr: topk(10, foo)
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, foo)'
          op: topk
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 12
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/76 - 1]
expr: topk(10, foo) without(cluster)
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk without (cluster) (10, foo)'
          op: topk
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 12
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/77 - 1]
expr: topk(10, foo) by(cluster)
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk by (cluster) (10, foo)'
          op: topk
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 12
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/78 - 1]
expr: bottomk(10, sum(rate(foo[5m])) without(job))
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 12
                end: 43
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 39
                end: 42
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[5m])'
          op: rate
        - node: '[*parser.AggregateExpr] sum without (job) (rate(foo[5m]))'
          op: sum
        - args:
            - "10"
          node: '[*parser.AggregateExpr] bottomk(10, sum without (job) (rate(foo[5m])))'
          op: bottomk
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 21
        end: 28
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/79 - 1]
expr: foo or bar
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/80 - 1]
expr: foo or bar or baz
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] baz'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 17
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/81 - 1]
expr: (foo or bar) or baz
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 11
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] baz'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 16
        end: 19
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/82 - 1]
expr: foo unless bar
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless:
        - matchinglabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 11
                end: 14
            type: selector
            fixedlabels: false
            isconditional: false
          ison: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/83 - 1]
expr: foo unless bar > 5
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless:
        - matchinglabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 11
                end: 14
            type: selector
            fixedlabels: false
            isconditional: true
          ison: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/84 - 1]
expr: foo unless bar unless baz
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless:
        - matchinglabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 11
                end: 14
            type: selector
            fixedlabels: false
            isconditional: false
          ison: false
        - matchinglabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] baz'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 22
                end: 25
            type: selector
            fixedlabels: false
            isconditional: false
          ison: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/85 - 1]
expr: count(sum(up{job="foo", cluster="dev"}) by(job, cluster) == 0) without(job, cluster)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 40
                end: 42
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 84
        cluster:
            reason: Query is using aggregation with `without(job, cluster)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 76
                end: 83
        job:
            reason: Query is using aggregation with `without(job, cluster)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 71
                end: 74
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{cluster="dev",job="foo"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job, cluster) (up{cluster="dev",job="foo"})'
          op: sum
        - node: '[*parser.AggregateExpr] count without (job, cluster) (sum by (job, cluster) (up{cluster="dev",job="foo"}) == 0)'
          op: count
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 10
        end: 38
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/86 - 1]
expr: year()
output:
    - labels:
        "":
            reason: Calling `year()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.Call] year()'
          op: year
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 6
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/87 - 1]
expr: year(foo)
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] year(foo)'
          op: year
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/88 - 1]
expr: label_join(up{job="api-server",src1="a",src2="b",src3="c"}, "foo", ",", "src1", "src2", "src3")
output:
    - labels:
        foo:
            reason: This label will be added to the result by label_join() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 95
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src1:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src2:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src3:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="api-server",src1="a",src2="b",src3="c"}'
          op: ""
        - args:
            - '"foo"'
            - '","'
            - '"src1"'
            - '"src2"'
            - '"src3"'
          node: '[*parser.Call] label_join(up{job="api-server",src1="a",src2="b",src3="c"}, "foo", ",", "src1", "src2", "src3")'
          op: label_join
      joins: []
      unless: []
      usedLabels:
        - src1
        - src2
        - src3
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 11
        end: 58
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/89 - 1]
expr: |4-

    (
     sum(foo:sum > 0) without(notify)
     * on(job) group_left(notify)
     job:notify
    )
    and on(job)
    sum(foo:count) by(job) > 20
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 4
                end: 78
        job:
            reason: Query is using many-to-many vector matching with `on(job)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 111
                end: 114
        notify:
            reason: Query is using `group_left(notify)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 59
                end: 65
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo:sum'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (notify) (foo:sum > 0)'
          op: sum
      joins:
        - matchinglabels:
            - job
          addedlabels:
            - notify
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] job:notify'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 68
                end: 78
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
        - matchinglabels:
            - job
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 108
                        end: 110
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 93
                        end: 115
                job:
                    reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 111
                        end: 114
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo:count'
                  op: ""
                - node: '[*parser.AggregateExpr] sum by (job) (foo:count)'
                  op: sum
            joins: []
            unless: []
            usedLabels:
                - job
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 97
                end: 106
            type: aggregation
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - job
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 15
      type: aggregation
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/90 - 1]
expr: container_file_descriptors / on (instance, app_name) container_ulimits_soft{ulimit="max_open_files"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 29
                end: 52
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 100
        app_name:
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 43
                end: 51
        instance:
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 33
                end: 41
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] container_file_descriptors'
          op: ""
      joins:
        - matchinglabels:
            - instance
            - app_name
          addedlabels: []
          src:
            labels:
                ulimit:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 53
                        end: 100
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] container_ulimits_soft{ulimit="max_open_files"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 53
                end: 100
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
        - app_name
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 26
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/91 - 1]
expr: container_file_descriptors / on (instance, app_name) group_left() container_ulimits_soft{ulimit="max_open_files"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 113
        app_name:
            reason: Query is using many-to-one vector matching with `on(instance, app_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 43
                end: 51
        instance:
            reason: Query is using many-to-one vector matching with `on(instance, app_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 33
                end: 41
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] container_file_descriptors'
          op: ""
      joins:
        - matchinglabels:
            - instance
            - app_name
          addedlabels: []
          src:
            labels:
                ulimit:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 66
                        end: 113
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] container_ulimits_soft{ulimit="max_open_files"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 66
                end: 113
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
        - app_name
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 26
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/92 - 1]
expr: absent(foo{job="bar"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 22
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="bar"}'
          op: ""
        - node: '[*parser.Call] absent(foo{job="bar"})'
          op: absent
      joins: []
      unless: []
      usedLabels:
        - job
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 21
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/93 - 1]
expr: absent(foo{job="bar", cluster!="dev", instance=~".+", env="prod"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        env:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 66
        instance:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 66
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{cluster!="dev",env="prod",instance=~".+",job="bar"}'
          op: ""
        - node: '[*parser.Call] absent(foo{cluster!="dev",env="prod",instance=~".+",job="bar"})'
          op: absent
      joins: []
      unless: []
      usedLabels:
        - job
        - env
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 65
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/94 - 1]
expr: absent(sum(foo) by(job, instance))
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 7
                end: 33
        instance:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job, instance) (foo)'
          op: sum
        - node: '[*parser.Call] absent(sum by (job, instance) (foo))'
          op: absent
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 33
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/95 - 1]
expr: absent(foo{job="prometheus", xxx="1"}) AND on(job) prometheus_build_info
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
        xxx:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="prometheus",xxx="1"}'
          op: ""
        - node: '[*parser.Call] absent(foo{job="prometheus",xxx="1"})'
          op: absent
      joins:
        - matchinglabels:
            - job
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] prometheus_build_info'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 51
                end: 72
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57389
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - job
        - xxx
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 37
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/96 - 1]
expr: 1 + sum(foo) by(notjob)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(notjob)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 4
                end: 23
        notjob:
            reason: Query is using aggregation with `by(notjob)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 16
                end: 22
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (notjob) (foo)'
          op: sum
      joins: []
      unless: []
      usedLabels:
        - notjob
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 11
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/97 - 1]
expr: count(node_exporter_build_info) by (instance, version) != ignoring(package,version) group_left(foo) count(deb_package_version) by (instance, version, package)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 32
                end: 35
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 158
        foo:
            reason: Query is using `group_left(foo)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 95
                end: 98
        instance:
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 36
                end: 44
        version:
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 46
                end: 53
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] node_exporter_build_info'
          op: ""
        - node: '[*parser.AggregateExpr] count by (instance, version) (node_exporter_build_info)'
          op: count
      joins:
        - matchinglabels:
            - package
            - version
          addedlabels:
            - foo
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 127
                        end: 130
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 100
                        end: 158
                instance:
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 131
                        end: 139
                package:
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 150
                        end: 157
                version:
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 141
                        end: 148
            deadinfo: null
            deadlabels:
                - name: foo
                  reason: You can't use `foo` because this label is not possible here.
                  labelreason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                  usagefragment:
                    start: 95
                    end: 98
                  labelfragment:
                    start: 127
                    end: 130
                  kind: 0
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] deb_package_version'
                  op: ""
                - node: '[*parser.AggregateExpr] count by (instance, version, package) (deb_package_version)'
                  op: count
            joins: []
            unless: []
            usedLabels:
                - instance
                - version
                - package
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 106
                end: 125
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57396
          depth: 0
          ison: false
      unless: []
      usedLabels:
        - instance
        - version
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 30
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/98 - 1]
expr: absent(foo) or absent(bar)
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] absent(foo)'
          op: absent
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 10
      type: function
      fixedlabels: true
      isconditional: false
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 15
                end: 21
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
        - node: '[*parser.Call] absent(bar)'
          op: absent
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 22
        end: 25
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/99 - 1]
expr: absent_over_time(foo[5m]) or absent(bar)
output:
    - labels:
        "":
            reason: |-
                The [absent_over_time()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent_over_time) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 16
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] absent_over_time(foo[5m])'
          op: absent_over_time
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 17
        end: 24
      type: function
      fixedlabels: true
      isconditional: false
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 29
                end: 35
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
        - node: '[*parser.Call] absent(bar)'
          op: absent
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 36
        end: 39
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/100 - 1]
expr: bar * on() group_right(cluster, env) absent(foo{job="xxx"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 37
                end: 43
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 59
        cluster:
            reason: Query is using `group_right(cluster, env)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 23
                end: 30
        env:
            reason: Query is using `group_right(cluster, env)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 32
                end: 35
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 37
                end: 59
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="xxx"}'
          op: ""
        - node: '[*parser.Call] absent(foo{job="xxx"})'
          op: absent
      joins:
        - matchinglabels: []
          addedlabels:
            - cluster
            - env
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 3
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - job
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 44
        end: 58
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/101 - 1]
expr: bar * on() group_right() absent(foo{job="xxx"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 25
                end: 31
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 47
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 25
                end: 47
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="xxx"}'
          op: ""
        - node: '[*parser.Call] absent(foo{job="xxx"})'
          op: absent
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 3
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - job
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 32
        end: 46
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/102 - 1]
expr: vector(1)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/103 - 1]
expr: vector(scalar(foo))
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - args:
            - scalar(foo)
          node: '[*parser.Call] vector(scalar(foo))'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 19
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 19
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/104 - 1]
expr: vector(0.0  >= bool 0.5) == 1
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo:
        reason: '`vector(0.0  >= bool 0.5) == 1` always evaluates to `0 == 1` which is not possible, so it will never return anything.'
        fragment:
            start: 0
            end: 24
      deadlabels: []
      returns: vector
      operations:
        - args:
            - 0 >= bool 0.5
          node: '[*parser.Call] vector(0 >= bool 0.5)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 24
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 24
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/105 - 1]
expr: sum_over_time(foo{job="myjob"}[5m])
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 35
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.Call] sum_over_time(foo{job="myjob"}[5m])'
          op: sum_over_time
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 34
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/106 - 1]
expr: days_in_month()
output:
    - labels:
        "":
            reason: Calling `days_in_month()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 15
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.Call] days_in_month()'
          op: days_in_month
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 15
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/107 - 1]
expr: days_in_month(foo{job="foo"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 29
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
        - node: '[*parser.Call] days_in_month(foo{job="foo"})'
          op: days_in_month
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 28
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/108 - 1]
expr: label_replace(up{job="api-server",service="a:c"}, "foo", "$1", "service", "(.*):.*")
output:
    - labels:
        foo:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 84
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 14
                end: 48
        service:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 14
                end: 48
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="api-server",service="a:c"}'
          op: ""
        - args:
            - '"foo"'
            - '"$1"'
            - '"service"'
            - '"(.*):.*"'
          node: '[*parser.Call] label_replace(up{job="api-server",service="a:c"}, "foo", "$1", "service", "(.*):.*")'
          op: label_replace
      joins: []
      unless: []
      usedLabels:
        - service
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 48
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/109 - 1]
expr: label_replace(sum by (pod) (pod_status) > 0, "cluster", "$1", "pod", "(.*)")
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 18
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 14
                end: 39
        cluster:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 76
        pod:
            reason: Query is using aggregation with `by(pod)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 22
                end: 25
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] pod_status'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (pod) (pod_status)'
          op: sum
        - args:
            - '"cluster"'
            - '"$1"'
            - '"pod"'
            - '"(.*)"'
          node: '[*parser.Call] label_replace(sum by (pod) (pod_status) > 0, "cluster", "$1", "pod", "(.*)")'
          op: label_replace
      joins: []
      unless: []
      usedLabels:
        - pod
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 43
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/110 - 1]
expr: (time() - my_metric) > 5*3600
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] my_metric'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 10
        end: 19
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/111 - 1]
expr: up{instance="a", job="prometheus"} * ignoring(job) up{instance="a", job="pint"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 79
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using one-to-one vector matching with `ignoring(job)`, all labels included inside `ignoring(...)` will be removed on the results.
            kind: excluded
            fragment:
                start: 46
                end: 49
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{instance="a",job="prometheus"}'
          op: ""
      joins:
        - matchinglabels:
            - job
          addedlabels: []
          src:
            labels:
                instance:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 51
                        end: 79
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 51
                        end: 79
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] up{instance="a",job="pint"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 51
                end: 79
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 34
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/112 - 1]
expr: |4

    avg without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"})
    < 0.5 > 0
    or sum without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"})
    < on() count(colo_router_tier:disabled_pops:max{tier="1",router=~"edge.*"}) * 0.4 > 0
    or avg without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"})
    < 0.1 > 0
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 101
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 21
                end: 28
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 30
                end: 38
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 13
                end: 19
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"}'
          op: ""
        - node: '[*parser.AggregateExpr] avg without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"})'
          op: avg
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 41
        end: 100
      type: aggregation
      fixedlabels: false
      isconditional: true
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 216
                end: 220
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 115
                end: 295
        cidr_use_case:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 216
                end: 220
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 135
                end: 142
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 144
                end: 152
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 127
                end: 133
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"})'
          op: sum
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 226
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 289
                router:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 226
                tier:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 226
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_router_tier:disabled_pops:max{router=~"edge.*",tier="1"}'
                  op: ""
                - node: '[*parser.AggregateExpr] count(colo_router_tier:disabled_pops:max{router=~"edge.*",tier="1"})'
                  op: count
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 227
                end: 288
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57391
          depth: 0
          ison: true
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 155
        end: 212
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 303
                end: 404
        cidr_use_case:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 343
                end: 403
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 323
                end: 330
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 332
                end: 340
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 315
                end: 321
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"}'
          op: ""
        - node: '[*parser.AggregateExpr] avg without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"})'
          op: avg
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 343
        end: 403
      type: aggregation
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/113 - 1]
expr: label_replace(sum(foo) without(instance), "instance", "none", "", "")
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 14
                end: 40
        instance:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 69
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (instance) (foo)'
          op: sum
        - args:
            - '"instance"'
            - '"none"'
            - '""'
            - '""'
          node: '[*parser.Call] label_replace(sum without (instance) (foo), "instance", "none", "", "")'
          op: label_replace
      joins: []
      unless: []
      usedLabels:
        - ""
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 40
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/114 - 1]
expr: |4-

    sum by (region, target, colo_name) (
        sum_over_time(probe_success{job="abc"}[5m])
     or
     vector(1)
    ) == 0
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 102
        colo_name:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 25
                end: 34
        job:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 35
        region:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 9
                end: 15
        target:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 17
                end: 23
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] probe_success{job="abc"}'
          op: ""
        - node: '[*parser.Call] sum_over_time(probe_success{job="abc"}[5m])'
          op: sum_over_time
        - node: '[*parser.AggregateExpr] sum by (region, target, colo_name) (sum_over_time(probe_success{job="abc"}[5m]) or vector(1))'
          op: sum
      joins: []
      unless: []
      usedLabels:
        - region
        - target
        - colo_name
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 56
        end: 84
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 102
        colo_name:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
        region:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
        target:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
      deadinfo:
        reason: '`vector(1) == 0` always evaluates to `1 == 0` which is not possible, so it will never return anything.'
        fragment:
            start: 91
            end: 100
      deadlabels:
        - name: region
          reason: You can't use `region` because this label is not possible here.
          labelreason: Calling `vector()` will return a vector value with no labels.
          usagefragment:
            start: 9
            end: 15
          labelfragment:
            start: 91
            end: 97
          kind: 0
        - name: target
          reason: You can't use `target` because this label is not possible here.
          labelreason: Calling `vector()` will return a vector value with no labels.
          usagefragment:
            start: 17
            end: 23
          labelfragment:
            start: 91
            end: 97
          kind: 0
        - name: colo_name
          reason: You can't use `colo_name` because this label is not possible here.
          labelreason: Calling `vector()` will return a vector value with no labels.
          usagefragment:
            start: 25
            end: 34
          labelfragment:
            start: 91
            end: 97
          kind: 0
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
        - node: '[*parser.AggregateExpr] sum by (region, target, colo_name) (sum_over_time(probe_success{job="abc"}[5m]) or vector(1))'
          op: sum
      joins: []
      unless: []
      usedLabels:
        - region
        - target
        - colo_name
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 91
            end: 100
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 91
        end: 100
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/115 - 1]
expr: vector(1) or foo
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedlabels: true
      isconditional: false
    - labels: {}
      deadinfo:
        reason: The left hand side always returs something and so the right hand side is never used.
        fragment:
            start: 13
            end: 16
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 13
        end: 16
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/116 - 1]
expr: vector(0) > 0
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo:
        reason: '`vector(0) > 0` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 0
            end: 9
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/117 - 1]
expr: vector(0) > vector(1)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo:
        reason: '`vector(0) > vector(1)` always evaluates to `0 > 1` which is not possible, so it will never return anything.'
        fragment:
            start: 0
            end: 9
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 12
                        end: 18
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 12
                    end: 21
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 12
                end: 21
            type: function
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/118 - 1]
expr: sum(foo or vector(0)) > 0
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo or vector(0))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 7
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo:
        reason: '`vector(0) > 0` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 11
            end: 20
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(foo or vector(0))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 11
            end: 20
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 11
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/119 - 1]
expr: (sum(foo or vector(1)) > 0) == 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo or vector(1))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo:
        reason: '`vector(1) == 2` always evaluates to `1 == 2` which is not possible, so it will never return anything.'
        fragment:
            start: 12
            end: 21
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(foo or vector(1))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 12
            end: 21
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/120 - 1]
expr: (sum(foo or vector(1)) > 0) != 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo or vector(1))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(foo or vector(1))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 12
            end: 21
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/121 - 1]
expr: (sum(foo or vector(2)) > 0) != 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo or vector(2))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo:
        reason: '`vector(2) != 2` always evaluates to `2 != 2` which is not possible, so it will never return anything.'
        fragment:
            start: 12
            end: 21
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "2"
          node: '[*parser.Call] vector(2)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(foo or vector(2))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 12
            end: 21
        returnednumber: 2
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/122 - 1]
expr: |-
    (sum(sometimes{foo!="bar"} or vector(0)))
    or
    ((bob > 10) or sum(foo) or vector(1))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 40
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] sometimes{foo!="bar"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(sometimes{foo!="bar"} or vector(0))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 26
      type: aggregation
      fixedlabels: true
      isconditional: false
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 40
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(sometimes{foo!="bar"} or vector(0))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 30
            end: 39
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 30
        end: 39
      type: aggregation
      fixedlabels: true
      isconditional: false
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bob'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 47
        end: 50
      type: selector
      fixedlabels: false
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 60
                end: 63
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 60
                end: 68
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo)'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 64
        end: 67
      type: aggregation
      fixedlabels: true
      isconditional: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 72
                end: 78
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 72
            end: 81
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 72
        end: 81
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/123 - 1]
expr: |4-

    (
     sum(sometimes{foo!="bar"})
     or
     vector(1)
    ) and (
     ((bob > 10) or sum(bar))
     or
     notfound > 0
    )
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 4
                end: 7
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 4
                end: 30
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] sometimes{foo!="bar"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(sometimes{foo!="bar"})'
          op: sum
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bob'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 57
                end: 60
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 73
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 78
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar)'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 74
                end: 77
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57389
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] notfound'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 85
                end: 93
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 29
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 36
                end: 42
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bob'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 57
                end: 60
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 73
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 78
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar)'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 74
                end: 77
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57389
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] notfound'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 85
                end: 93
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 36
            end: 45
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 36
        end: 45
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/124 - 1]
expr: foo offset 5m > 5
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo offset 5m'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 13
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/125 - 1]
expr: |4

    (rate(metric2[5m]) or vector(0)) +
    (rate(metric1[5m]) or vector(1)) +
    (rate(metric3{log_name="samplerd"}[5m]) or vector(2)) > 0
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 124
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] metric2'
          op: ""
        - node: '[*parser.Call] rate(metric2[5m])'
          op: rate
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metric1'
                  op: ""
                - node: '[*parser.Call] rate(metric1[5m])'
                  op: rate
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 42
                end: 53
            type: function
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 58
                        end: 64
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 58
                    end: 67
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 58
                end: 67
            type: function
            fixedlabels: true
            isconditional: false
          op: 57383
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                log_name:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 72
                        end: 110
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metric3{log_name="samplerd"}'
                  op: ""
                - node: '[*parser.Call] rate(metric3{log_name="samplerd"}[5m])'
                  op: rate
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 77
                end: 109
            type: function
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 114
                        end: 120
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - args:
                    - "2"
                  node: '[*parser.Call] vector(2)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 114
                    end: 123
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 114
                end: 123
            type: function
            fixedlabels: true
            isconditional: false
          op: 57383
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 18
      type: function
      fixedlabels: false
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 23
                end: 29
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 124
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metric1'
                  op: ""
                - node: '[*parser.Call] rate(metric1[5m])'
                  op: rate
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 42
                end: 53
            type: function
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 58
                        end: 64
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 58
                    end: 67
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 58
                end: 67
            type: function
            fixedlabels: true
            isconditional: false
          op: 57383
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                log_name:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 72
                        end: 110
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metric3{log_name="samplerd"}'
                  op: ""
                - node: '[*parser.Call] rate(metric3{log_name="samplerd"}[5m])'
                  op: rate
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 77
                end: 109
            type: function
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 114
                        end: 120
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - args:
                    - "2"
                  node: '[*parser.Call] vector(2)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 114
                    end: 123
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 114
                end: 123
            type: function
            fixedlabels: true
            isconditional: false
          op: 57383
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: vector(0) + vector(1) + vector(2)
        valueposition:
            start: 23
            end: 32
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 23
        end: 32
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/126 - 1]
expr: label_replace(vector(1), "nexthop_tag", "$1", "nexthop", "(.+)")
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 14
                end: 20
        nexthop_tag:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 64
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
        - args:
            - '"nexthop_tag"'
            - '"$1"'
            - '"nexthop"'
            - '"(.+)"'
          node: '[*parser.Call] label_replace(vector(1), "nexthop_tag", "$1", "nexthop", "(.+)")'
          op: label_replace
      joins: []
      unless: []
      usedLabels:
        - nexthop
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 14
            end: 23
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 14
        end: 23
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/127 - 1]
expr: (sum(foo{job="myjob"}))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo{job="myjob"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 21
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/128 - 1]
expr: (-foo{job="myjob"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 2
                end: 18
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 2
        end: 18
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/129 - 1]
expr: |4-

    ((( group(vector(0)) ))) > 0
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 5
                end: 10
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 5
                end: 21
      deadinfo:
        reason: '`vector(0) > 0` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 11
            end: 20
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
        - node: '[*parser.AggregateExpr] group(vector(0))'
          op: group
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 11
            end: 20
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 11
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/130 - 1]
expr: 1 > bool 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo:
        reason: '`1 > 5` always evaluates to `1 > 5` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 0
            end: 1
      deadlabels: []
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/131 - 1]
expr: prometheus_ready{job="prometheus"} unless vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
          op: ""
      joins: []
      unless:
        - matchinglabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 48
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `job` label while the left hand side will. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 42
                    end: 48
            deadlabels: []
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 42
                    end: 51
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 42
                end: 51
            type: function
            fixedlabels: true
            isconditional: false
          ison: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 34
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/132 - 1]
expr: prometheus_ready{job="prometheus"} unless on() vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      deadinfo:
        reason: This query will never return anything because the `unless` query always returns something.
        fragment:
            start: 47
            end: 56
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
          op: ""
      joins: []
      unless:
        - matchinglabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 47
                        end: 53
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 47
                    end: 56
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 47
                end: 56
            type: function
            fixedlabels: true
            isconditional: false
          ison: true
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 34
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/133 - 1]
expr: prometheus_ready{job="prometheus"} unless on(job) vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
          op: ""
      joins: []
      unless:
        - matchinglabels:
            - job
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 50
                        end: 56
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `job` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 50
                    end: 56
            deadlabels: []
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 50
                    end: 59
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 50
                end: 59
            type: function
            fixedlabels: true
            isconditional: false
          ison: true
      usedLabels:
        - job
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 34
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/134 - 1]
expr: |4

    max by (instance, cluster) (cf_node_role{kubernetes_role="master",role="kubernetes"})
    unless
       sum by (instance, cluster) (time() - node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"})
       * on (instance) group_left (cluster)
        cf_node_role{kubernetes_role="master",role="kubernetes"}
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 86
        cluster:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 19
                end: 26
        instance:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 9
                end: 17
        kubernetes_role:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 27
        role:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 27
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] cf_node_role{kubernetes_role="master",role="kubernetes"}'
          op: ""
        - node: '[*parser.AggregateExpr] max by (instance, cluster) (cf_node_role{kubernetes_role="master",role="kubernetes"})'
          op: max
      joins: []
      unless:
        - matchinglabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 99
                        end: 102
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 95
                        end: 303
                cluster:
                    reason: Query is using `group_left(cluster)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 234
                        end: 241
                instance:
                    reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 212
                        end: 220
                name:
                    reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 99
                        end: 121
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum by (instance, cluster) (time() - node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"})'
                  op: sum
            joins:
                - matchinglabels:
                    - instance
                  addedlabels:
                    - cluster
                  src:
                    labels:
                        kubernetes_role:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 247
                                end: 303
                        role:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 247
                                end: 303
                    deadinfo: null
                    deadlabels: []
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] cf_node_role{kubernetes_role="master",role="kubernetes"}'
                          op: ""
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 247
                        end: 303
                    type: selector
                    fixedlabels: false
                    isconditional: false
                  op: 57395
                  depth: 0
                  ison: true
            unless: []
            usedLabels:
                - instance
                - cluster
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 132
                end: 201
            type: aggregation
            fixedlabels: true
            isconditional: false
          ison: false
      usedLabels:
        - instance
        - cluster
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 29
        end: 85
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/135 - 1]
expr: foo{a="1"} * on() bar{b="2"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 17
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 28
        a:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 17
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 18
                        end: 28
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 18
                end: 28
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/136 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) bar{b="2"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 52
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using `group_left(c, d)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 37
                end: 38
        d:
            reason: Query is using `group_left(c, d)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 39
                end: 40
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 16
                end: 24
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - c
            - d
          src:
            labels:
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 42
                        end: 52
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 42
                end: 52
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/137 - 1]
expr: foo{a="1"} * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 53
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 43
                end: 53
        c:
            reason: Query is using `group_right(c, d)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 38
                end: 39
        d:
            reason: Query is using `group_right(c, d)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 40
                end: 41
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 16
                end: 24
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{b="2"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - c
            - d
          src:
            labels:
                a:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 0
                        end: 10
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{a="1"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 10
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 43
        end: 53
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/138 - 1]
expr: foo{a="1"} * on(instance) sum(bar{b="2"})
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 25
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 41
        a:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 25
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 16
                end: 24
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 26
                        end: 29
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 26
                        end: 41
                b:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 26
                        end: 29
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 26
                    end: 29
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar{b="2"})'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 30
                end: 40
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/139 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) sum(bar{b="2"})
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 57
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using `group_left(c, d)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 37
                end: 38
        d:
            reason: Query is using `group_left(c, d)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 39
                end: 40
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 16
                end: 24
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - c
            - d
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 45
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 57
                b:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 45
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 42
                    end: 45
            deadlabels:
                - name: c
                  reason: You can't use `c` because this label is not possible here.
                  labelreason: Query is using aggregation that removes all labels.
                  usagefragment:
                    start: 37
                    end: 38
                  labelfragment:
                    start: 42
                    end: 45
                  kind: 0
                - name: d
                  reason: You can't use `d` because this label is not possible here.
                  labelreason: Query is using aggregation that removes all labels.
                  usagefragment:
                    start: 39
                    end: 40
                  labelfragment:
                    start: 42
                    end: 45
                  kind: 0
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar{b="2"})'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 46
                end: 56
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/140 - 1]
expr: sum(foo{a="1"}) * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 58
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 48
                end: 58
        c:
            reason: Query is using `group_right(c, d)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 43
                end: 44
        d:
            reason: Query is using `group_right(c, d)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 45
                end: 46
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 21
                end: 29
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{b="2"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - c
            - d
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 3
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 15
                a:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 3
            deadinfo:
                reason: The left hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 0
                    end: 3
            deadlabels:
                - name: c
                  reason: You can't use `c` because this label is not possible here.
                  labelreason: Query is using aggregation that removes all labels.
                  usagefragment:
                    start: 43
                    end: 44
                  labelfragment:
                    start: 0
                    end: 3
                  kind: 0
                - name: d
                  reason: You can't use `d` because this label is not possible here.
                  labelreason: Query is using aggregation that removes all labels.
                  usagefragment:
                    start: 45
                    end: 46
                  labelfragment:
                    start: 0
                    end: 3
                  kind: 0
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{a="1"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(foo{a="1"})'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 4
                end: 14
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 48
        end: 58
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/141 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) sum(bar{b="2"}) without(instance)
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 75
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using `group_left(c, d)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 37
                end: 38
        d:
            reason: Query is using `group_left(c, d)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 39
                end: 40
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 16
                end: 24
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - c
            - d
          src:
            labels:
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 75
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 46
                        end: 56
                instance:
                    reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                    kind: excluded
                    fragment:
                        start: 66
                        end: 74
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                fragment:
                    start: 66
                    end: 74
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum without (instance) (bar{b="2"})'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 46
                end: 56
            type: aggregation
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/142 - 1]
expr: sum(foo{a="1"}) without(instance) * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 76
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 66
                end: 76
        c:
            reason: Query is using `group_right(c, d)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 61
                end: 62
        d:
            reason: Query is using `group_right(c, d)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 63
                end: 64
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 39
                end: 47
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{b="2"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - c
            - d
          src:
            labels:
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 33
                a:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 4
                        end: 14
                instance:
                    reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 32
            deadinfo:
                reason: The left hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                fragment:
                    start: 24
                    end: 32
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{a="1"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum without (instance) (foo{a="1"})'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 4
                end: 14
            type: aggregation
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 66
        end: 76
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/143 - 1]
expr: |4

     max without (source_instance) (
       increase(kernel_device_io_errors_total{device!~"loop.+"}[120m]) > 3 unless on(instance, device) (
         increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[125m])*2 > increase(kernel_device_io_errors_total[120m])
       )
       and on(device, instance) absent(node_disk_info)
     ) * on(instance) group_left(group) label_replace(salt_highstate_runner_configured_minions, "instance", "$1", "minion", "(.+)")
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 2
                end: 442
        device:
            reason: Query is using many-to-many vector matching with `on(device, instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 274
                end: 280
        group:
            reason: Query is using `group_left(group)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 344
                end: 349
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 323
                end: 331
        source_instance:
            reason: Query is using aggregation with `without(source_instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 15
                end: 30
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] kernel_device_io_errors_total{device!~"loop.+"}'
          op: ""
        - node: '[*parser.Call] increase(kernel_device_io_errors_total{device!~"loop.+"}[2h])'
          op: increase
        - node: '[*parser.AggregateExpr] max without (source_instance) (increase(kernel_device_io_errors_total{device!~"loop.+"}[2h]) > 3 unless on (instance, device) (increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[2h5m]) * 2 > increase(kernel_device_io_errors_total[2h])) and on (device, instance) absent(node_disk_info))'
          op: max
      joins:
        - matchinglabels:
            - device
            - instance
          addedlabels: []
          src:
            labels:
                "":
                    reason: |-
                        The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                        You will only get any results back if the metric selector you pass doesn't match anything.
                        Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                        This means that the only labels you can get back from absent call are the ones you pass to it.
                        If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
                    kind: excluded
                    fragment:
                        start: 292
                        end: 298
            deadinfo:
                reason: |-
                    The right hand side will never be matched because it doesn't have the `device` label from `on(...)`. The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                    You will only get any results back if the metric selector you pass doesn't match anything.
                    Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                    This means that the only labels you can get back from absent call are the ones you pass to it.
                    If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
                fragment:
                    start: 292
                    end: 298
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] node_disk_info'
                  op: ""
                - node: '[*parser.Call] absent(node_disk_info)'
                  op: absent
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 299
                end: 313
            type: function
            fixedlabels: true
            isconditional: false
          op: 57389
          depth: 1
          ison: true
        - matchinglabels:
            - instance
          addedlabels:
            - group
          src:
            labels:
                instance:
                    reason: This label will be added to the result by label_replace() call.
                    kind: guaranteed
                    fragment:
                        start: 351
                        end: 442
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] salt_highstate_runner_configured_minions'
                  op: ""
                - args:
                    - '"instance"'
                    - '"$1"'
                    - '"minion"'
                    - '"(.+)"'
                  node: '[*parser.Call] label_replace(salt_highstate_runner_configured_minions, "instance", "$1", "minion", "(.+)")'
                  op: label_replace
            joins: []
            unless: []
            usedLabels:
                - minion
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 365
                end: 405
            type: function
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless:
        - matchinglabels:
            - instance
            - device
          src:
            labels:
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 140
                        end: 258
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] kernel_device_io_soft_errors_total{device!~"loop.+"}'
                  op: ""
                - node: '[*parser.Call] increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[2h5m])'
                  op: increase
            joins:
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels: {}
                    deadinfo: null
                    deadlabels: []
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] kernel_device_io_errors_total'
                          op: ""
                        - node: '[*parser.Call] increase(kernel_device_io_errors_total[2h])'
                          op: increase
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 222
                        end: 257
                    type: function
                    fixedlabels: false
                    isconditional: false
                  op: 57388
                  depth: 0
                  ison: false
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 149
                end: 207
            type: function
            fixedlabels: false
            isconditional: true
          ison: true
      usedLabels:
        - instance
        - device
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 46
        end: 99
      type: aggregation
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/144 - 1]
expr: sum(foo{a="1"}) by(job) * on() bar{b="2"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 26
                end: 30
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 41
        a:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 16
                end: 23
        job:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 26
                end: 30
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job) (foo{a="1"})'
          op: sum
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 31
                        end: 41
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 31
                end: 41
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 14
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/145 - 1]
expr: sum(sum(foo) without(job)) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 27
                end: 29
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 21
                end: 24
      deadinfo: null
      deadlabels:
        - name: job
          reason: You can't use `job` because this label is not possible here.
          labelreason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
          usagefragment:
            start: 30
            end: 33
          labelfragment:
            start: 21
            end: 24
          kind: 0
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (job) (foo)'
          op: sum
        - node: '[*parser.AggregateExpr] sum by (job) (sum without (job) (foo))'
          op: sum
      joins: []
      unless: []
      usedLabels:
        - job
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 11
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/146 - 1]
expr: |4

    prometheus:scrape_series_added:since_gc:sum
    * on(prometheus) group_left()
    label_replace(
      max(max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])) by(instance)
      /
      max(max_over_time(prometheus_tsdb_head_series[2h])) by(instance),
      "prometheus", "$1",
      "instance", "(.+)"
    )
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 287
        prometheus:
            reason: Query is using many-to-one vector matching with `on(prometheus)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 50
                end: 60
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus:scrape_series_added:since_gc:sum'
          op: ""
      joins:
        - matchinglabels:
            - prometheus
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 158
                        end: 160
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 92
                        end: 241
                instance:
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 161
                        end: 169
                job:
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 158
                        end: 170
                prometheus:
                    reason: This label will be added to the result by label_replace() call.
                    kind: guaranteed
                    fragment:
                        start: 75
                        end: 287
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] go_memstats_alloc_bytes{job="prometheus"}'
                  op: ""
                - node: '[*parser.Call] max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])'
                  op: max_over_time
                - node: '[*parser.AggregateExpr] max by (instance) (max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h]))'
                  op: max
                - args:
                    - '"prometheus"'
                    - '"$1"'
                    - '"instance"'
                    - '"(.+)"'
                  node: '[*parser.Call] label_replace(max by (instance) (max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])) / max by (instance) (max_over_time(prometheus_tsdb_head_series[2h])), "prometheus", "$1", "instance", "(.+)")'
                  op: label_replace
            joins:
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 229
                                end: 231
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 177
                                end: 241
                        instance:
                            reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 232
                                end: 240
                    deadinfo: null
                    deadlabels: []
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] prometheus_tsdb_head_series'
                          op: ""
                        - node: '[*parser.Call] max_over_time(prometheus_tsdb_head_series[2h])'
                          op: max_over_time
                        - node: '[*parser.AggregateExpr] max by (instance) (max_over_time(prometheus_tsdb_head_series[2h]))'
                          op: max
                    joins: []
                    unless: []
                    usedLabels:
                        - instance
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 195
                        end: 226
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                  ison: false
            unless: []
            usedLabels:
                - instance
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 92
                end: 241
            type: function
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - prometheus
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 44
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/147 - 1]
expr: (day_of_week() == 6 and hour() < 1) or vector(1)
output:
    - labels:
        "":
            reason: Calling `day_of_week()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 14
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.Call] day_of_week()'
          op: day_of_week
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `hour()` with no arguments will return an empty time series with no labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 30
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.Call] hour()'
                  op: hour
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: true
                knownreturn: false
                isreturnbool: false
            position:
                start: 24
                end: 30
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 14
      type: function
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 39
                end: 45
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 39
            end: 48
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 39
        end: 48
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/148 - 1]
expr: |4-

    sum by (foo, bar) (
        rate(errors_total[5m])
      * on (instance) group_left (bob, alice)
        server_errors_total
    )
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 115
        alice:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 18
        bar:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 14
                end: 17
        bob:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 18
        foo:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 9
                end: 12
        instance:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 18
      deadinfo: null
      deadlabels:
        - name: bob
          reason: Previously joined label `bob` is being removed from the results.
          labelreason: Query is using `group_left(bob, alice)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 5
            end: 18
          labelfragment:
            start: 78
            end: 81
          kind: 3
        - name: alice
          reason: Previously joined label `alice` is being removed from the results.
          labelreason: Query is using `group_left(bob, alice)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 5
            end: 18
          labelfragment:
            start: 83
            end: 88
          kind: 3
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] errors_total'
          op: ""
        - node: '[*parser.Call] rate(errors_total[5m])'
          op: rate
        - node: '[*parser.AggregateExpr] sum by (foo, bar) (rate(errors_total[5m]) * on (instance) group_left (bob, alice) server_errors_total)'
          op: sum
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - bob
            - alice
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] server_errors_total'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 94
                end: 113
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 1
          ison: true
      unless: []
      usedLabels:
        - foo
        - bar
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 30
        end: 46
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/149 - 1]
expr: 1 - (foo or vector(0)) < 0.999
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: selector
      fixedlabels: false
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 12
                end: 18
      deadinfo:
        reason: '`1 - vector(0) < 0.999` always evaluates to `1 < 0.999` which is not possible, so it will never return anything.'
        fragment:
            start: 12
            end: 21
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: 1 - vector(0)
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/150 - 1]
expr: |4

    (
      vector(1) and month() == 2
    ) or vector(0)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 5
                end: 11
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `month()` with no arguments will return an empty time series with no labels.
                    kind: excluded
                    fragment:
                        start: 19
                        end: 26
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.Call] month()'
                  op: month
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: true
                knownreturn: false
                isreturnbool: false
            position:
                start: 19
                end: 26
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 5
            end: 14
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 5
        end: 14
      type: function
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 37
                end: 43
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 37
            end: 46
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 37
        end: 46
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/151 - 1]
expr: count by (region) (stddev by (colo_name, region) (error_total))
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 9
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 63
        colo_name:
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 17
        region:
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 10
                end: 16
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] error_total'
          op: ""
        - node: '[*parser.AggregateExpr] stddev by (colo_name, region) (error_total)'
          op: stddev
        - node: '[*parser.AggregateExpr] count by (region) (stddev by (colo_name, region) (error_total))'
          op: count
      joins: []
      unless: []
      usedLabels:
        - region
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 50
        end: 61
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/152 - 1]
expr: |4

    (
      avg(
        rate(foo_rejections[6h])
        or
        vector(0)
      ) by (colo_name)
      /
      (
        avg(
          rate(foo_total[6h])
       or
       vector(1)
        ) by (colo_name)
      )
    ) > 5
    *
    (
      avg(
        rate(foo_rejections[6h] offset 1d)
     or
     vector(0)
      ) by (colo_name)
      /
      avg(
        rate(foo_total[6h] offset 1d)
     or
     vector(1)
      ) by (colo_name)
    ) and on (colo_name) (colo_job:foo_total:rate2m or vector(0)) > 80
      and on (colo_name) (colo_job:foo_total:rate2m offset 1d or vector(0)) > 80
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 64
                end: 67
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 336
        colo_name:
            reason: Query is using many-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 412
                end: 421
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo_rejections'
          op: ""
        - node: '[*parser.Call] rate(foo_rejections[6h])'
          op: rate
        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h]) or vector(0))'
          op: avg
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 151
                        end: 160
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo_total'
                  op: ""
                - node: '[*parser.Call] rate(foo_total[6h])'
                  op: rate
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
                  op: avg
            joins: []
            unless: []
            usedLabels:
                - colo_name
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 107
                end: 120
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 131
                        end: 137
            deadinfo: null
            deadlabels:
                - name: colo_name
                  reason: You can't use `colo_name` because this label is not possible here.
                  labelreason: Calling `vector()` will return a vector value with no labels.
                  usagefragment:
                    start: 151
                    end: 160
                  labelfragment:
                    start: 131
                    end: 137
                  kind: 0
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
                  op: avg
            joins: []
            unless: []
            usedLabels:
                - colo_name
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 131
                    end: 140
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 131
                end: 140
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 334
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 245
                        end: 254
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo_rejections offset 1d'
                  op: ""
                - node: '[*parser.Call] rate(foo_rejections[6h] offset 1d)'
                  op: rate
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
                  op: avg
            joins:
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 324
                                end: 333
                    deadinfo: null
                    deadlabels: []
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] foo_total offset 1d'
                          op: ""
                        - node: '[*parser.Call] rate(foo_total[6h] offset 1d)'
                          op: rate
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    usedLabels:
                        - colo_name
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                  ison: false
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadinfo: null
                    deadlabels:
                        - name: colo_name
                          reason: You can't use `colo_name` because this label is not possible here.
                          labelreason: Calling `vector()` will return a vector value with no labels.
                          usagefragment:
                            start: 324
                            end: 333
                          labelfragment:
                            start: 306
                            end: 312
                          kind: 0
                    returns: vector
                    operations:
                        - args:
                            - "1"
                          node: '[*parser.Call] vector(1)'
                          op: vector
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    usedLabels:
                        - colo_name
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                  ison: false
            unless: []
            usedLabels:
                - colo_name
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 192
                end: 220
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 334
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 227
                        end: 233
            deadinfo: null
            deadlabels:
                - name: colo_name
                  reason: You can't use `colo_name` because this label is not possible here.
                  labelreason: Calling `vector()` will return a vector value with no labels.
                  usagefragment:
                    start: 245
                    end: 254
                  labelfragment:
                    start: 227
                    end: 233
                  kind: 0
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
                  op: avg
            joins:
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 324
                                end: 333
                    deadinfo: null
                    deadlabels: []
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] foo_total offset 1d'
                          op: ""
                        - node: '[*parser.Call] rate(foo_total[6h] offset 1d)'
                          op: rate
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    usedLabels:
                        - colo_name
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                  ison: false
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadinfo: null
                    deadlabels:
                        - name: colo_name
                          reason: You can't use `colo_name` because this label is not possible here.
                          labelreason: Calling `vector()` will return a vector value with no labels.
                          usagefragment:
                            start: 324
                            end: 333
                          labelfragment:
                            start: 306
                            end: 312
                          kind: 0
                    returns: vector
                    operations:
                        - args:
                            - "1"
                          node: '[*parser.Call] vector(1)'
                          op: vector
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    usedLabels:
                        - colo_name
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                  ison: false
            unless: []
            usedLabels:
                - colo_name
            returninfo:
                logicalexpr: 5 * vector(0) / vector(1)
                valueposition:
                    start: 170
                    end: 171
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 227
                end: 236
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
          ison: false
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_job:foo_total:rate2m'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 357
                end: 382
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 386
                        end: 392
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 386
                    end: 392
            deadlabels: []
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 386
                    end: 395
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 386
                end: 395
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_job:foo_total:rate2m offset 1d'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 424
                end: 459
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 463
                        end: 469
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 463
                    end: 469
            deadlabels: []
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 463
                    end: 472
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 463
                end: 472
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - colo_name
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 19
        end: 37
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 64
                end: 67
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 336
        colo_name:
            reason: Query is using many-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 412
                end: 421
      deadinfo:
        reason: '`vector(0) / vector(1) > 5 * vector(0) / vector(1)` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 50
            end: 59
      deadlabels:
        - name: colo_name
          reason: You can't use `colo_name` because this label is not possible here.
          labelreason: Calling `vector()` will return a vector value with no labels.
          usagefragment:
            start: 68
            end: 77
          labelfragment:
            start: 50
            end: 56
          kind: 0
        - name: colo_name
          reason: You can't use `colo_name` because this label is not possible here.
          labelreason: Calling `vector()` will return a vector value with no labels.
          usagefragment:
            start: 345
            end: 354
          labelfragment:
            start: 50
            end: 56
          kind: 0
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h]) or vector(0))'
          op: avg
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 151
                        end: 160
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo_total'
                  op: ""
                - node: '[*parser.Call] rate(foo_total[6h])'
                  op: rate
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
                  op: avg
            joins: []
            unless: []
            usedLabels:
                - colo_name
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 107
                end: 120
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 131
                        end: 137
            deadinfo: null
            deadlabels:
                - name: colo_name
                  reason: You can't use `colo_name` because this label is not possible here.
                  labelreason: Calling `vector()` will return a vector value with no labels.
                  usagefragment:
                    start: 151
                    end: 160
                  labelfragment:
                    start: 131
                    end: 137
                  kind: 0
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
                  op: avg
            joins: []
            unless: []
            usedLabels:
                - colo_name
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 131
                    end: 140
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 131
                end: 140
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 334
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 245
                        end: 254
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo_rejections offset 1d'
                  op: ""
                - node: '[*parser.Call] rate(foo_rejections[6h] offset 1d)'
                  op: rate
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
                  op: avg
            joins:
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 324
                                end: 333
                    deadinfo: null
                    deadlabels: []
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] foo_total offset 1d'
                          op: ""
                        - node: '[*parser.Call] rate(foo_total[6h] offset 1d)'
                          op: rate
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    usedLabels:
                        - colo_name
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                  ison: false
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadinfo: null
                    deadlabels:
                        - name: colo_name
                          reason: You can't use `colo_name` because this label is not possible here.
                          labelreason: Calling `vector()` will return a vector value with no labels.
                          usagefragment:
                            start: 324
                            end: 333
                          labelfragment:
                            start: 306
                            end: 312
                          kind: 0
                    returns: vector
                    operations:
                        - args:
                            - "1"
                          node: '[*parser.Call] vector(1)'
                          op: vector
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    usedLabels:
                        - colo_name
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                  ison: false
            unless: []
            usedLabels:
                - colo_name
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 192
                end: 220
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 334
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 227
                        end: 233
            deadinfo: null
            deadlabels:
                - name: colo_name
                  reason: You can't use `colo_name` because this label is not possible here.
                  labelreason: Calling `vector()` will return a vector value with no labels.
                  usagefragment:
                    start: 245
                    end: 254
                  labelfragment:
                    start: 227
                    end: 233
                  kind: 0
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
                  op: avg
            joins:
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 324
                                end: 333
                    deadinfo: null
                    deadlabels: []
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] foo_total offset 1d'
                          op: ""
                        - node: '[*parser.Call] rate(foo_total[6h] offset 1d)'
                          op: rate
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    usedLabels:
                        - colo_name
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                  ison: false
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadinfo: null
                    deadlabels:
                        - name: colo_name
                          reason: You can't use `colo_name` because this label is not possible here.
                          labelreason: Calling `vector()` will return a vector value with no labels.
                          usagefragment:
                            start: 324
                            end: 333
                          labelfragment:
                            start: 306
                            end: 312
                          kind: 0
                    returns: vector
                    operations:
                        - args:
                            - "1"
                          node: '[*parser.Call] vector(1)'
                          op: vector
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    usedLabels:
                        - colo_name
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                  ison: false
            unless: []
            usedLabels:
                - colo_name
            returninfo:
                logicalexpr: 5 * vector(0) / vector(1)
                valueposition:
                    start: 170
                    end: 171
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 227
                end: 236
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
          ison: false
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_job:foo_total:rate2m'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 357
                end: 382
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 386
                        end: 392
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 386
                    end: 392
            deadlabels: []
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 386
                    end: 395
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 386
                end: 395
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_job:foo_total:rate2m offset 1d'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 424
                end: 459
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 463
                        end: 469
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 463
                    end: 469
            deadlabels: []
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 463
                    end: 472
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 463
                end: 472
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - colo_name
      returninfo:
        logicalexpr: vector(0) / vector(1)
        valueposition:
            start: 50
            end: 59
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 50
        end: 59
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/153 - 1]
expr: sum(selector) / sum(selector offset 30m) > 5
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 40
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] selector'
          op: ""
        - node: '[*parser.AggregateExpr] sum(selector)'
          op: sum
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 16
                        end: 19
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 16
                        end: 40
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] selector offset 30m'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(selector offset 30m)'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 20
                end: 39
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 12
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/154 - 1]
expr: |4-

    count by (dc) (
      max(0 < (token_expiration - time()) < (6*60*60)) by (instance)
      * on (instance) group_right label_replace(
        configured_minions, "instance", "$1", "minion", "(.+)")
      ) > 5
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(dc)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 10
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 190
        dc:
            reason: Query is using aggregation with `by(dc)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 13
        instance:
            reason: Query is using aggregation with `by(dc)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 14
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] configured_minions'
          op: ""
        - args:
            - '"instance"'
            - '"$1"'
            - '"minion"'
            - '"(.+)"'
          node: '[*parser.Call] label_replace(configured_minions, "instance", "$1", "minion", "(.+)")'
          op: label_replace
        - node: '[*parser.AggregateExpr] count by (dc) (max by (instance) (0 < (token_expiration - time()) < (6 * 60 * 60)) * on (instance) group_right () label_replace(configured_minions, "instance", "$1", "minion", "(.+)"))'
          op: count
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 68
                        end: 71
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 19
                        end: 81
                instance:
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 72
                        end: 80
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] token_expiration'
                  op: ""
                - node: '[*parser.AggregateExpr] max by (instance) (0 < (token_expiration - time()) < (6 * 60 * 60))'
                  op: max
            joins: []
            unless: []
            usedLabels:
                - instance
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 28
                end: 44
            type: aggregation
            fixedlabels: true
            isconditional: true
          op: 57395
          depth: 1
          ison: true
      unless: []
      usedLabels:
        - dc
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 131
        end: 149
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/155 - 1]
expr: topk(10, prometheus_build_info*prometheus_ready)
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 9
                end: 47
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_build_info'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, prometheus_build_info * prometheus_ready)'
          op: topk
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] prometheus_ready'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 31
                end: 47
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 1
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 30
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/156 - 1]
expr: bottomk(10, prometheus_build_info*prometheus_ready)
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 12
                end: 50
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_build_info'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] bottomk(10, prometheus_build_info * prometheus_ready)'
          op: bottomk
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] prometheus_ready'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 34
                end: 50
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 1
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 12
        end: 33
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/157 - 1]
expr: histogram_fraction(0, 0.1, metric)
output:
    - labels: {}
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] metric'
          op: ""
        - args:
            - "0"
            - "0.1"
          node: '[*parser.Call] histogram_fraction(0, 0.1, metric)'
          op: histogram_fraction
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 27
        end: 33
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/158 - 1]
expr: 'foo * foo '
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 9
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 6
                end: 9
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: false
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/159 - 1]
expr: 'foo + on(__name__, job) foo '
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(__name__, job)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 23
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 27
        job:
            reason: Query is using one-to-one vector matching with `on(__name__, job)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 19
                end: 22
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - __name__
            - job
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 24
                end: 27
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - job
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/160 - 1]
expr: 'foo + on(__name__, job) group_left foo '
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 38
        job:
            reason: Query is using many-to-one vector matching with `on(__name__, job)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 19
                end: 22
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - __name__
            - job
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 35
                end: 38
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - job
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/161 - 1]
expr: 'foo + on(__name__, job) group_right foo '
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 39
        job:
            reason: Query is using one-to-many vector matching with `on(__name__, job)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 19
                end: 22
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - __name__
            - job
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 3
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - job
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 36
        end: 39
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/162 - 1]
expr: |-
    group by (env, cluster) (
          up{env="prod", job="foo"} and on (instance) (services_enabled == 999)
     )
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(env, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 9
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 104
        cluster:
            reason: Query is using aggregation with `by(env, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 15
                end: 22
        env:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 32
                end: 57
        instance:
            reason: Query is using aggregation with `by(env, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 23
        job:
            reason: Query is using aggregation with `by(env, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 23
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{env="prod",job="foo"}'
          op: ""
        - node: '[*parser.AggregateExpr] group by (env, cluster) (up{env="prod",job="foo"} and on (instance) (services_enabled == 999))'
          op: group
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] services_enabled'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 77
                end: 93
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 1
          ison: true
      unless: []
      usedLabels:
        - env
        - cluster
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 32
        end: 57
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/163 - 1]
expr: |-
    group by (env, cluster) (
          up{env="prod", job="foo"} * on (instance) (services_enabled == 999)
     )
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(env, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 9
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 102
        cluster:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 60
                end: 73
        env:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 60
                end: 73
        instance:
            reason: Query is using aggregation with `by(env, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 23
        job:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 60
                end: 73
      deadinfo: null
      deadlabels:
        - name: env
          reason: You can't use `env` because this label is not possible here.
          labelreason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
          usagefragment:
            start: 10
            end: 13
          labelfragment:
            start: 60
            end: 73
          kind: 0
        - name: cluster
          reason: You can't use `cluster` because this label is not possible here.
          labelreason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
          usagefragment:
            start: 15
            end: 22
          labelfragment:
            start: 60
            end: 73
          kind: 0
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{env="prod",job="foo"}'
          op: ""
        - node: '[*parser.AggregateExpr] group by (env, cluster) (up{env="prod",job="foo"} * on (instance) (services_enabled == 999))'
          op: group
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] services_enabled'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 75
                end: 91
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57395
          depth: 1
          ison: true
      unless: []
      usedLabels:
        - env
        - cluster
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 32
        end: 57
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/164 - 1]
expr: foo / on(instance) sum(bar)
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 18
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 27
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 9
                end: 17
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 19
                        end: 22
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 19
                        end: 27
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 19
                    end: 22
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar)'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 23
                end: 26
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/165 - 1]
expr: foo / on(instance) group_left(cluster) sum(bar)
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 47
        cluster:
            reason: Query is using `group_left(cluster)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 30
                end: 37
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 9
                end: 17
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - cluster
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 39
                        end: 42
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 39
                        end: 47
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 39
                    end: 42
            deadlabels:
                - name: cluster
                  reason: You can't use `cluster` because this label is not possible here.
                  labelreason: Query is using aggregation that removes all labels.
                  usagefragment:
                    start: 30
                    end: 37
                  labelfragment:
                    start: 39
                    end: 42
                  kind: 0
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar)'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 43
                end: 46
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/166 - 1]
expr: sum(bar) / on(instance) group_right(cluster) foo
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 48
        cluster:
            reason: Query is using `group_right(cluster)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 36
                end: 43
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 14
                end: 22
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - cluster
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 3
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 8
            deadinfo:
                reason: The left hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 0
                    end: 3
            deadlabels:
                - name: cluster
                  reason: You can't use `cluster` because this label is not possible here.
                  labelreason: Query is using aggregation that removes all labels.
                  usagefragment:
                    start: 36
                    end: 43
                  labelfragment:
                    start: 0
                    end: 3
                  kind: 0
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar)'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 4
                end: 7
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 45
        end: 48
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/167 - 1]
expr: sum(bar) * on(cluster) sum(foo)
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(cluster)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 11
                end: 22
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 31
        cluster:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      deadinfo: null
      deadlabels:
        - name: cluster
          reason: You can't use `cluster` because this label is not possible here.
          labelreason: Query is using aggregation that removes all labels.
          usagefragment:
            start: 14
            end: 21
          labelfragment:
            start: 0
            end: 3
          kind: 0
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
        - node: '[*parser.AggregateExpr] sum(bar)'
          op: sum
      joins:
        - matchinglabels:
            - cluster
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 23
                        end: 26
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 23
                        end: 31
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(foo)'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 27
                end: 30
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - cluster
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 7
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/168 - 1]
expr: |4-

    group by (colo_name, instance, tier, animal, brand, sliver, pop_name) (
      up{node_status="v", job="node_exporter"}
      and on (instance) (metal_services_enabled == 999)
      * on (colo_name) group_left(tier, animal, brand, pop_name) colo_metadata{colo_status="v"}
      * on (instance) group_left (sliver) sliver_metadata{node_status="v"}
    )
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 10
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 332
        animal:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 38
                end: 44
        brand:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 46
                end: 51
        colo_name:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 20
        instance:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 22
                end: 30
        job:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 70
        node_status:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 70
        pop_name:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 61
                end: 69
        sliver:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 53
                end: 59
        tier:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 32
                end: 36
      deadinfo: null
      deadlabels:
        - name: tier
          reason: This binary operation prevents previously joined label `tier` from being added to the results.
          labelreason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 118
            end: 121
          labelfragment:
            start: 198
            end: 202
          kind: 1
        - name: animal
          reason: This binary operation prevents previously joined label `animal` from being added to the results.
          labelreason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 118
            end: 121
          labelfragment:
            start: 204
            end: 210
          kind: 1
        - name: brand
          reason: This binary operation prevents previously joined label `brand` from being added to the results.
          labelreason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 118
            end: 121
          labelfragment:
            start: 212
            end: 217
          kind: 1
        - name: pop_name
          reason: This binary operation prevents previously joined label `pop_name` from being added to the results.
          labelreason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 118
            end: 121
          labelfragment:
            start: 219
            end: 227
          kind: 1
        - name: sliver
          reason: This binary operation prevents previously joined label `sliver` from being added to the results.
          labelreason: Query is using `group_left(sliver)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 118
            end: 121
          labelfragment:
            start: 290
            end: 296
          kind: 1
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="node_exporter",node_status="v"}'
          op: ""
        - node: '[*parser.AggregateExpr] group by (colo_name, instance, tier, animal, brand, sliver, pop_name) (up{job="node_exporter",node_status="v"} and on (instance) (metal_services_enabled == 999) * on (colo_name) group_left (tier, animal, brand, pop_name) colo_metadata{colo_status="v"} * on (instance) group_left (sliver) sliver_metadata{node_status="v"})'
          op: group
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels:
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 136
                        end: 330
                animal:
                    reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 204
                        end: 210
                brand:
                    reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 212
                        end: 217
                colo_name:
                    reason: Query is using many-to-one vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 176
                        end: 185
                instance:
                    reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 268
                        end: 276
                pop_name:
                    reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 219
                        end: 227
                sliver:
                    reason: Query is using `group_left(sliver)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 290
                        end: 296
                tier:
                    reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 198
                        end: 202
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metal_services_enabled'
                  op: ""
            joins:
                - matchinglabels:
                    - colo_name
                  addedlabels:
                    - tier
                    - animal
                    - brand
                    - pop_name
                  src:
                    labels:
                        colo_status:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 229
                                end: 259
                    deadinfo: null
                    deadlabels: []
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] colo_metadata{colo_status="v"}'
                          op: ""
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 229
                        end: 259
                    type: selector
                    fixedlabels: false
                    isconditional: false
                  op: 57395
                  depth: 0
                  ison: true
                - matchinglabels:
                    - instance
                  addedlabels:
                    - sliver
                  src:
                    labels:
                        node_status:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 298
                                end: 330
                    deadinfo: null
                    deadlabels: []
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] sliver_metadata{node_status="v"}'
                          op: ""
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 298
                        end: 330
                    type: selector
                    fixedlabels: false
                    isconditional: false
                  op: 57395
                  depth: 0
                  ison: true
            unless: []
            usedLabels:
                - colo_name
                - instance
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 137
                end: 159
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 1
          ison: true
      unless: []
      usedLabels:
        - instance
        - colo_name
        - tier
        - animal
        - brand
        - sliver
        - pop_name
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 75
        end: 115
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/169 - 1]
expr: |4

    up{node_status="v", job="node_exporter"}
    * on (colo_name) group_left(tier) colo_metadata{colo_status="v"}
    * on (instance) group_left (sliver) sliver_metadata{node_status="v"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 175
        colo_name:
            reason: Query is using many-to-one vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 48
                end: 57
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 113
                end: 121
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 1
                end: 41
        node_status:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 1
                end: 41
        sliver:
            reason: Query is using `group_left(sliver)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 135
                end: 141
        tier:
            reason: Query is using `group_left(tier)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 70
                end: 74
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="node_exporter",node_status="v"}'
          op: ""
      joins:
        - matchinglabels:
            - colo_name
          addedlabels:
            - tier
          src:
            labels:
                colo_status:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 76
                        end: 106
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_metadata{colo_status="v"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 76
                end: 106
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
        - matchinglabels:
            - instance
          addedlabels:
            - sliver
          src:
            labels:
                node_status:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 143
                        end: 175
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] sliver_metadata{node_status="v"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 143
                end: 175
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - colo_name
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 41
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/170 - 1]
expr: |4

    up{node_status="v", job="node_exporter"}
    and on (colo_name) colo_metadata{colo_status="v"}
    * on (instance) group_left (sliver) sliver_metadata{node_status="v"}
output:
    - labels:
        colo_name:
            reason: Query is using many-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 50
                end: 59
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 1
                end: 41
        node_status:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 1
                end: 41
      deadinfo: null
      deadlabels:
        - name: sliver
          reason: This binary operation prevents previously joined label `sliver` from being added to the results.
          labelreason: Query is using `group_left(sliver)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 42
            end: 45
          labelfragment:
            start: 120
            end: 126
          kind: 1
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="node_exporter",node_status="v"}'
          op: ""
      joins:
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            labels:
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 61
                        end: 160
                colo_status:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 61
                        end: 91
                instance:
                    reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 98
                        end: 106
                sliver:
                    reason: Query is using `group_left(sliver)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 120
                        end: 126
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_metadata{colo_status="v"}'
                  op: ""
            joins:
                - matchinglabels:
                    - instance
                  addedlabels:
                    - sliver
                  src:
                    labels:
                        node_status:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 128
                                end: 160
                    deadinfo: null
                    deadlabels: []
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] sliver_metadata{node_status="v"}'
                          op: ""
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 128
                        end: 160
                    type: selector
                    fixedlabels: false
                    isconditional: false
                  op: 57395
                  depth: 0
                  ison: true
            unless: []
            usedLabels:
                - instance
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 61
                end: 91
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57389
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - colo_name
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 41
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/171 - 1]
expr: |4

    colo_metadata{colo_status="v"} * on (colo_name) group_right(tier, animal, brand, pop_name)
    sliver_metadata{node_status="v"} * on (instance) group_right (sliver)
    (metal_services_enabled == 999) * on (instance)
    up{node_status="v", job="node_exporter"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 1
                end: 250
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 250
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 200
                end: 208
        sliver:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 1
                end: 250
      deadinfo: null
      deadlabels:
        - name: tier
          reason: This binary operation prevents previously joined label `tier` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 125
            end: 126
          labelfragment:
            start: 125
            end: 126
          kind: 1
        - name: animal
          reason: This binary operation prevents previously joined label `animal` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 125
            end: 126
          labelfragment:
            start: 125
            end: 126
          kind: 1
        - name: brand
          reason: This binary operation prevents previously joined label `brand` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 125
            end: 126
          labelfragment:
            start: 125
            end: 126
          kind: 1
        - name: pop_name
          reason: This binary operation prevents previously joined label `pop_name` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 125
            end: 126
          labelfragment:
            start: 125
            end: 126
          kind: 1
        - name: sliver
          reason: This binary operation prevents previously joined label `sliver` from being added to the results.
          labelreason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
          usagefragment:
            start: 194
            end: 195
          labelfragment:
            start: 1
            end: 250
          kind: 1
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] metal_services_enabled'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - sliver
          src:
            labels:
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 1
                        end: 124
                animal:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 67
                        end: 73
                brand:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 75
                        end: 80
                colo_name:
                    reason: Query is using one-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 38
                        end: 47
                node_status:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 92
                        end: 124
                pop_name:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 82
                        end: 90
                tier:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 61
                        end: 65
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] sliver_metadata{node_status="v"}'
                  op: ""
            joins:
                - matchinglabels:
                    - colo_name
                  addedlabels:
                    - tier
                    - animal
                    - brand
                    - pop_name
                  src:
                    labels:
                        colo_status:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 1
                                end: 31
                    deadinfo: null
                    deadlabels: []
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] colo_metadata{colo_status="v"}'
                          op: ""
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 1
                        end: 31
                    type: selector
                    fixedlabels: false
                    isconditional: false
                  op: 57395
                  depth: 0
                  ison: true
            unless: []
            usedLabels:
                - colo_name
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 92
                end: 124
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels:
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 210
                        end: 250
                node_status:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 210
                        end: 250
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] up{job="node_exporter",node_status="v"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 210
                end: 250
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 163
        end: 185
      type: selector
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/172 - 1]
expr: |4

    colo_metadata{colo_status="v"} * on (colo_name) group_right(tier, animal, brand, pop_name)
    sliver_metadata{node_status="v"} * on (instance) group_right (sliver)
    (metal_services_enabled == 999) * on (instance) group_right()
    up{node_status="v", job="node_exporter"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 264
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 200
                end: 208
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 224
                end: 264
        node_status:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 224
                end: 264
      deadinfo: null
      deadlabels:
        - name: sliver
          reason: This binary operation prevents previously joined label `sliver` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 194
            end: 195
          labelfragment:
            start: 194
            end: 195
          kind: 1
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="node_exporter",node_status="v"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels:
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 1
                        end: 193
                instance:
                    reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 131
                        end: 139
                sliver:
                    reason: Query is using `group_right(sliver)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 154
                        end: 160
            deadinfo: null
            deadlabels:
                - name: tier
                  reason: This binary operation prevents previously joined label `tier` from being added to the results.
                  labelreason: ""
                  usagefragment:
                    start: 125
                    end: 126
                  labelfragment:
                    start: 125
                    end: 126
                  kind: 1
                - name: animal
                  reason: This binary operation prevents previously joined label `animal` from being added to the results.
                  labelreason: ""
                  usagefragment:
                    start: 125
                    end: 126
                  labelfragment:
                    start: 125
                    end: 126
                  kind: 1
                - name: brand
                  reason: This binary operation prevents previously joined label `brand` from being added to the results.
                  labelreason: ""
                  usagefragment:
                    start: 125
                    end: 126
                  labelfragment:
                    start: 125
                    end: 126
                  kind: 1
                - name: pop_name
                  reason: This binary operation prevents previously joined label `pop_name` from being added to the results.
                  labelreason: ""
                  usagefragment:
                    start: 125
                    end: 126
                  labelfragment:
                    start: 125
                    end: 126
                  kind: 1
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metal_services_enabled'
                  op: ""
            joins:
                - matchinglabels:
                    - instance
                  addedlabels:
                    - sliver
                  src:
                    labels:
                        __name__:
                            reason: Binary operation between two vectors removes metric names.
                            kind: excluded
                            fragment:
                                start: 1
                                end: 124
                        animal:
                            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                            kind: included
                            fragment:
                                start: 67
                                end: 73
                        brand:
                            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                            kind: included
                            fragment:
                                start: 75
                                end: 80
                        colo_name:
                            reason: Query is using one-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 38
                                end: 47
                        node_status:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 92
                                end: 124
                        pop_name:
                            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                            kind: included
                            fragment:
                                start: 82
                                end: 90
                        tier:
                            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                            kind: included
                            fragment:
                                start: 61
                                end: 65
                    deadinfo: null
                    deadlabels: []
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] sliver_metadata{node_status="v"}'
                          op: ""
                    joins:
                        - matchinglabels:
                            - colo_name
                          addedlabels:
                            - tier
                            - animal
                            - brand
                            - pop_name
                          src:
                            labels:
                                colo_status:
                                    reason: Query will only return series where these labels are present.
                                    kind: guaranteed
                                    fragment:
                                        start: 1
                                        end: 31
                            deadinfo: null
                            deadlabels: []
                            returns: vector
                            operations:
                                - node: '[*parser.VectorSelector] colo_metadata{colo_status="v"}'
                                  op: ""
                            joins: []
                            unless: []
                            returninfo:
                                logicalexpr: ""
                                valueposition:
                                    start: 0
                                    end: 0
                                returnednumber: 0
                                alwaysreturns: false
                                knownreturn: false
                                isreturnbool: false
                            position:
                                start: 1
                                end: 31
                            type: selector
                            fixedlabels: false
                            isconditional: false
                          op: 57395
                          depth: 0
                          ison: true
                    unless: []
                    usedLabels:
                        - colo_name
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 92
                        end: 124
                    type: selector
                    fixedlabels: false
                    isconditional: false
                  op: 57395
                  depth: 0
                  ison: true
            unless: []
            usedLabels:
                - instance
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 163
                end: 185
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 224
        end: 264
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/173 - 1]
expr: |4

    sliver_metadata{node_status="v"} * on (instance) group_right (sliver)
    (metal_services_enabled == 999) * on (colo_name) group_left(tier, animal, brand, pop_name)
    colo_metadata{colo_status="v"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 192
        animal:
            reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 137
                end: 143
        brand:
            reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 145
                end: 150
        colo_name:
            reason: Query is using many-to-one vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 109
                end: 118
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 40
                end: 48
        pop_name:
            reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 152
                end: 160
        sliver:
            reason: Query is using `group_right(sliver)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 63
                end: 69
        tier:
            reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 131
                end: 135
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] metal_services_enabled'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - sliver
          src:
            labels:
                node_status:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 1
                        end: 33
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] sliver_metadata{node_status="v"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 1
                end: 33
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels:
            - tier
            - animal
            - brand
            - pop_name
          src:
            labels:
                colo_status:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 162
                        end: 192
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_metadata{colo_status="v"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 162
                end: 192
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
        - colo_name
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 72
        end: 94
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/174 - 1]
expr: |4

    colo_metadata * on (colo_name) group_right(tier, animal, brand, pop_name)
    sliver_metadata * on (instance) group_right (sliver)
    metal_services_enabled
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 150
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 97
                end: 105
        sliver:
            reason: Query is using `group_right(sliver)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 120
                end: 126
      deadinfo: null
      deadlabels:
        - name: tier
          reason: This binary operation prevents previously joined label `tier` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 91
            end: 92
          labelfragment:
            start: 91
            end: 92
          kind: 1
        - name: animal
          reason: This binary operation prevents previously joined label `animal` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 91
            end: 92
          labelfragment:
            start: 91
            end: 92
          kind: 1
        - name: brand
          reason: This binary operation prevents previously joined label `brand` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 91
            end: 92
          labelfragment:
            start: 91
            end: 92
          kind: 1
        - name: pop_name
          reason: This binary operation prevents previously joined label `pop_name` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 91
            end: 92
          labelfragment:
            start: 91
            end: 92
          kind: 1
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] metal_services_enabled'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - sliver
          src:
            labels:
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 1
                        end: 90
                animal:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 50
                        end: 56
                brand:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 58
                        end: 63
                colo_name:
                    reason: Query is using one-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 21
                        end: 30
                pop_name:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 65
                        end: 73
                tier:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 44
                        end: 48
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] sliver_metadata'
                  op: ""
            joins:
                - matchinglabels:
                    - colo_name
                  addedlabels:
                    - tier
                    - animal
                    - brand
                    - pop_name
                  src:
                    labels: {}
                    deadinfo: null
                    deadlabels: []
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] colo_metadata'
                          op: ""
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 1
                        end: 14
                    type: selector
                    fixedlabels: false
                    isconditional: false
                  op: 57395
                  depth: 0
                  ison: true
            unless: []
            usedLabels:
                - colo_name
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 75
                end: 90
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 128
        end: 150
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/175 - 1]
expr: |4

    colo_metadata * on (colo_name) group_right(tier, animal, brand, pop_name)
    (
        sliver_metadata * on (instance) group_right (sliver)
        metal_services_enabled
    )
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 162
        animal:
            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 50
                end: 56
        brand:
            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 58
                end: 63
        colo_name:
            reason: Query is using one-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 21
                end: 30
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 103
                end: 111
        pop_name:
            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 65
                end: 73
        sliver:
            reason: Query is using `group_right(sliver)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 126
                end: 132
        tier:
            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 44
                end: 48
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] metal_services_enabled'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - sliver
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] sliver_metadata'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 81
                end: 96
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels:
            - tier
            - animal
            - brand
            - pop_name
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_metadata'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 1
                end: 14
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
        - colo_name
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 138
        end: 160
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/176 - 1]
expr: |4

    up{node_status="v", job="node_exporter"}
    * on(instance) group_left(node_status) sliver_metadata
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 96
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 47
                end: 55
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 1
                end: 41
        node_status:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 1
                end: 41
      deadinfo: null
      deadlabels:
        - name: node_status
          reason: Query is trying to join the `node_status` label that is already present on the other side of the query.
          labelreason: Query will only return series where these labels are present.
          usagefragment:
            start: 68
            end: 79
          labelfragment:
            start: 1
            end: 41
          kind: 2
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="node_exporter",node_status="v"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - node_status
          src:
            labels: {}
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] sliver_metadata'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 81
                end: 96
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
          ison: true
      unless: []
      usedLabels:
        - instance
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 41
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/177 - 1]
expr: services_enabled{job=""}
output:
    - labels:
        job:
            reason: Query uses `{job=""}` selector which will filter out any time series with the `job` label set.
            kind: excluded
            fragment:
                start: 0
                end: 24
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] services_enabled{job=""}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 24
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/178 - 1]
expr: |4

    group by (cluster, namespace, workload, workload_type, pod) (
      label_join(
        label_join(
          group by (cluster, namespace, job_name, pod) (
            label_join(
              kube_pod_owner{job="kube-state-metrics", owner_kind="Job"}
            , "job_name", "", "owner_name")
          )
          * on (cluster, namespace, job_name) group_left(owner_kind, owner_name)
          group by (cluster, namespace, job_name, owner_kind, owner_name) (
            kube_job_owner{job="kube-state-metrics", owner_kind!="Pod", owner_kind!=""}
          )
        , "workload", "", "owner_name")
      , "workload_type", "", "owner_kind")
    )
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(cluster, namespace, workload, workload_type, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 10
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 600
        cluster:
            reason: Query is using aggregation with `by(cluster, namespace, workload, workload_type, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 18
        job:
            reason: Query is using aggregation with `by(cluster, namespace, job_name, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 105
                end: 143
        job_name:
            reason: Query is using aggregation with `by(cluster, namespace, workload, workload_type, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 60
        namespace:
            reason: Query is using aggregation with `by(cluster, namespace, workload, workload_type, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 20
                end: 29
        owner_kind:
            reason: Query is using aggregation with `by(cluster, namespace, workload, workload_type, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 60
        owner_name:
            reason: Query is using aggregation with `by(cluster, namespace, workload, workload_type, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 60
        pod:
            reason: Query is using aggregation with `by(cluster, namespace, workload, workload_type, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 56
                end: 59
        workload:
            reason: This label will be added to the result by label_join() call.
            kind: guaranteed
            fragment:
                start: 81
                end: 559
        workload_type:
            reason: This label will be added to the result by label_join() call.
            kind: guaranteed
            fragment:
                start: 65
                end: 598
      deadinfo: null
      deadlabels: []
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] kube_pod_owner{job="kube-state-metrics",owner_kind="Job"}'
          op: ""
        - args:
            - '"job_name"'
            - '""'
            - '"owner_name"'
          node: '[*parser.Call] label_join(kube_pod_owner{job="kube-state-metrics",owner_kind="Job"}, "job_name", "", "owner_name")'
          op: label_join
        - node: '[*parser.AggregateExpr] group by (cluster, namespace, job_name, pod) (label_join(kube_pod_owner{job="kube-state-metrics",owner_kind="Job"}, "job_name", "", "owner_name"))'
          op: group
        - args:
            - '"workload"'
            - '""'
            - '"owner_name"'
          node: '[*parser.Call] label_join(group by (cluster, namespace, job_name, pod) (label_join(kube_pod_owner{job="kube-state-metrics",owner_kind="Job"}, "job_name", "", "owner_name")) * on (cluster, namespace, job_name) group_left (owner_kind, owner_name) group by (cluster, namespace, job_name, owner_kind, owner_name) (kube_job_owner{job="kube-state-metrics",owner_kind!="",owner_kind!="Pod"}), "workload", "", "owner_name")'
          op: label_join
        - args:
            - '"workload_type"'
            - '""'
            - '"owner_kind"'
          node: '[*parser.Call] label_join(label_join(group by (cluster, namespace, job_name, pod) (label_join(kube_pod_owner{job="kube-state-metrics",owner_kind="Job"}, "job_name", "", "owner_name")) * on (cluster, namespace, job_name) group_left (owner_kind, owner_name) group by (cluster, namespace, job_name, owner_kind, owner_name) (kube_job_owner{job="kube-state-metrics",owner_kind!="",owner_kind!="Pod"}), "workload", "", "owner_name"), "workload_type", "", "owner_kind")'
          op: label_join
        - node: '[*parser.AggregateExpr] group by (cluster, namespace, workload, workload_type, pod) (label_join(label_join(group by (cluster, namespace, job_name, pod) (label_join(kube_pod_owner{job="kube-state-metrics",owner_kind="Job"}, "job_name", "", "owner_name")) * on (cluster, namespace, job_name) group_left (owner_kind, owner_name) group by (cluster, namespace, job_name, owner_kind, owner_name) (kube_job_owner{job="kube-state-metrics",owner_kind!="",owner_kind!="Pod"}), "workload", "", "owner_name"), "workload_type", "", "owner_kind"))'
          op: group
      joins:
        - matchinglabels:
            - cluster
            - namespace
            - job_name
          addedlabels:
            - owner_kind
            - owner_name
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(cluster, namespace, job_name, owner_kind, owner_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 372
                        end: 375
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 366
                        end: 523
                cluster:
                    reason: Query is using aggregation with `by(cluster, namespace, job_name, owner_kind, owner_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 376
                        end: 383
                job:
                    reason: Query is using aggregation with `by(cluster, namespace, job_name, owner_kind, owner_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 372
                        end: 429
                job_name:
                    reason: Query is using aggregation with `by(cluster, namespace, job_name, owner_kind, owner_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 396
                        end: 404
                namespace:
                    reason: Query is using aggregation with `by(cluster, namespace, job_name, owner_kind, owner_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 385
                        end: 394
                owner_kind:
                    reason: Query is using aggregation with `by(cluster, namespace, job_name, owner_kind, owner_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 406
                        end: 416
                owner_name:
                    reason: Query is using aggregation with `by(cluster, namespace, job_name, owner_kind, owner_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 418
                        end: 428
            deadinfo: null
            deadlabels: []
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] kube_job_owner{job="kube-state-metrics",owner_kind!="",owner_kind!="Pod"}'
                  op: ""
                - node: '[*parser.AggregateExpr] group by (cluster, namespace, job_name, owner_kind, owner_name) (kube_job_owner{job="kube-state-metrics",owner_kind!="",owner_kind!="Pod"})'
                  op: group
            joins: []
            unless: []
            usedLabels:
                - cluster
                - namespace
                - job_name
                - owner_kind
                - owner_name
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 440
                end: 515
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 1
          ison: true
      unless: []
      usedLabels:
        - cluster
        - namespace
        - pod
        - workload
        - workload_type
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 81
        end: 559
      type: aggregation
      fixedlabels: true
      isconditional: false

---
