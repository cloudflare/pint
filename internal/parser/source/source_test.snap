
[TestLabelsSource/1 - 1]
expr: "1"
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      returns: scalar
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 1
      type: number
      fixedLabels: true

---

[TestLabelsSource/2 - 1]
expr: 1 / 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      returns: scalar
      returnInfo:
        logicalexpr: 1 / 5
        valueposition:
            start: 0
            end: 1
        returnednumber: 0.2
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 1
      type: number
      fixedLabels: true

---

[TestLabelsSource/3 - 1]
expr: (2 ^ 5) == bool 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadInfo:
        reason: '`2 ^ 5 == 5` always evaluates to `32 == 5` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      returns: scalar
      returnInfo:
        logicalexpr: 2 ^ 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 32
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/4 - 1]
expr: (2 ^ 5 + 11) % 5 <= bool 2
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadInfo:
        reason: '`2 ^ 5 + 11 % 5 <= 2` always evaluates to `3 <= 2` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      returns: scalar
      returnInfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/5 - 1]
expr: (2 ^ 5 + 11) % 5 >= bool 20
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadInfo:
        reason: '`2 ^ 5 + 11 % 5 >= 20` always evaluates to `3 >= 20` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      returns: scalar
      returnInfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/6 - 1]
expr: (2 ^ 5 + 11) % 5 <= bool 3
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      returns: scalar
      returnInfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/7 - 1]
expr: (2 ^ 5 + 11) % 5 < bool 1
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadInfo:
        reason: '`2 ^ 5 + 11 % 5 < 1` always evaluates to `3 < 1` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      returns: scalar
      returnInfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/8 - 1]
expr: 20 - 15 < bool 1
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 2
      deadInfo:
        reason: '`20 - 15 < 1` always evaluates to `5 < 1` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 0
            end: 2
      returns: scalar
      returnInfo:
        logicalexpr: 20 - 15
        valueposition:
            start: 0
            end: 2
        returnednumber: 5
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 2
      type: number
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/9 - 1]
expr: 2 * 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      returns: scalar
      returnInfo:
        logicalexpr: 2 * 5
        valueposition:
            start: 0
            end: 1
        returnednumber: 10
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 1
      type: number
      fixedLabels: true

---

[TestLabelsSource/10 - 1]
expr: (foo or bar) * 5
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 1
        end: 4
      type: selector
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      position:
        start: 8
        end: 11
      type: selector

---

[TestLabelsSource/11 - 1]
expr: (foo or vector(2)) * 5
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 1
        end: 4
      type: selector
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 8
                end: 14
      returns: vector
      operations:
        - args:
            - "2"
          node: '[*parser.Call] vector(2)'
          op: vector
      returnInfo:
        logicalexpr: vector(2) * 5
        valueposition:
            start: 8
            end: 17
        returnednumber: 10
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 8
        end: 17
      type: function
      fixedLabels: true

---

[TestLabelsSource/12 - 1]
expr: (foo or vector(5)) * (vector(2) or bar)
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 39
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 22
                        end: 28
            returns: vector
            operations:
                - args:
                    - "2"
                  node: '[*parser.Call] vector(2)'
                  op: vector
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 22
                    end: 31
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 22
                end: 31
            type: function
            fixedLabels: true
          op: 57395
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            deadInfo:
                reason: The left hand side always returs something and so the right hand side is never used.
                fragment:
                    start: 35
                    end: 38
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 35
                end: 38
            type: selector
          op: 57395
          depth: 0
          ison: false
      position:
        start: 1
        end: 4
      type: selector
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 8
                end: 14
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 39
      returns: vector
      operations:
        - args:
            - "5"
          node: '[*parser.Call] vector(5)'
          op: vector
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 22
                        end: 28
            returns: vector
            operations:
                - args:
                    - "2"
                  node: '[*parser.Call] vector(2)'
                  op: vector
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 22
                    end: 31
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 22
                end: 31
            type: function
            fixedLabels: true
          op: 57395
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            deadInfo:
                reason: The left hand side always returs something and so the right hand side is never used.
                fragment:
                    start: 35
                    end: 38
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 35
                end: 38
            type: selector
          op: 57395
          depth: 0
          ison: false
      returnInfo:
        logicalexpr: vector(5) * vector(2)
        valueposition:
            start: 8
            end: 17
        returnednumber: 10
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 8
        end: 17
      type: function
      fixedLabels: true

---

[TestLabelsSource/13 - 1]
expr: 1 > bool 0
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      returns: scalar
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 1
      type: number
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/14 - 1]
expr: 20 > bool 10
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 2
      returns: scalar
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 2
        returnednumber: 20
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 2
      type: number
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/15 - 1]
expr: '"test"'
output:
    - labels:
        "":
            reason: This query returns a string value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      returns: string
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 6
      type: string
      fixedLabels: true

---

[TestLabelsSource/16 - 1]
expr: foo
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 0
        end: 3
      type: selector

---

[TestLabelsSource/17 - 1]
expr: (foo > 1) > bool 1
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 1
        end: 4
      type: selector
      isConditional: true

---

[TestLabelsSource/18 - 1]
expr: foo > bool 5
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      isConditional: true

---

[TestLabelsSource/19 - 1]
expr: foo > bool 5 == 1
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 0
        end: 3
      type: selector
      isConditional: true

---

[TestLabelsSource/20 - 1]
expr: foo > bool bar
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 14
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 11
                end: 14
            type: selector
          op: 57388
          depth: 0
          ison: false
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      isConditional: true

---

[TestLabelsSource/21 - 1]
expr: (foo > bool bar) == 0
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 15
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 12
                end: 15
            type: selector
          op: 57388
          depth: 0
          ison: false
      position:
        start: 1
        end: 4
      type: selector
      isConditional: true

---

[TestLabelsSource/22 - 1]
expr: foo > bool on(instance) bar
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 11
                end: 23
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 27
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 14
                end: 22
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 24
                end: 27
            type: selector
          op: 57388
          depth: 0
          ison: true
      usedLabels:
        - instance
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/23 - 1]
expr: (foo > bool on(instance) bar) == 1
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 12
                end: 24
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 28
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 15
                end: 23
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 25
                end: 28
            type: selector
          op: 57388
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 1
        end: 4
      type: selector
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/24 - 1]
expr: foo > bool on(instance) group_left(version) bar
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 47
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 14
                end: 22
        version:
            reason: Query is using `group_left(version)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 35
                end: 42
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - version
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 44
                end: 47
            type: selector
          op: 57388
          depth: 0
          ison: true
      usedLabels:
        - instance
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      isConditional: true

---

[TestLabelsSource/25 - 1]
expr: bar > bool on(instance) group_right(version) foo
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 48
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 14
                end: 22
        version:
            reason: Query is using `group_right(version)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 36
                end: 43
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - version
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 0
                end: 3
            type: selector
          op: 57388
          depth: 0
          ison: true
      usedLabels:
        - instance
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 45
        end: 48
      type: selector
      isConditional: true

---

[TestLabelsSource/26 - 1]
expr: foo and bar > bool 0
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: true
            position:
                start: 8
                end: 11
            type: selector
            isConditional: true
          op: 57389
          depth: 0
          ison: false
      position:
        start: 0
        end: 3
      type: selector
      isConditional: true

---

[TestLabelsSource/27 - 1]
expr: foo offset 5m
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo offset 5m'
          op: ""
      position:
        start: 0
        end: 13
      type: selector

---

[TestLabelsSource/28 - 1]
expr: foo{job="bar"}
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="bar"}'
          op: ""
      position:
        start: 0
        end: 14
      type: selector

---

[TestLabelsSource/29 - 1]
expr: foo{job=""}
output:
    - labels:
        job:
            reason: Query uses `{job=""}` selector which will filter out any time series with the `job` label set.
            kind: excluded
            fragment:
                start: 0
                end: 11
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job=""}'
          op: ""
      position:
        start: 0
        end: 11
      type: selector

---

[TestLabelsSource/30 - 1]
expr: foo{job="bar"} or bar{job="foo"}
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="bar"}'
          op: ""
      usedLabels:
        - job
      position:
        start: 0
        end: 14
      type: selector
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 18
                end: 32
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{job="foo"}'
          op: ""
      position:
        start: 18
        end: 32
      type: selector

---

[TestLabelsSource/31 - 1]
expr: foo{a="bar"} or bar{b="foo"}
output:
    - labels:
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 12
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="bar"}'
          op: ""
      usedLabels:
        - a
      position:
        start: 0
        end: 12
      type: selector
    - labels:
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 16
                end: 28
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{b="foo"}'
          op: ""
      position:
        start: 16
        end: 28
      type: selector

---

[TestLabelsSource/32 - 1]
expr: foo[5m]
output:
    - returns: matrix
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 0
        end: 3
      type: selector

---

[TestLabelsSource/33 - 1]
expr: prometheus_build_info[2m:1m]
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_build_info'
          op: ""
      position:
        start: 0
        end: 21
      type: selector

---

[TestLabelsSource/34 - 1]
expr: deriv(rate(distance_covered_meters_total[1m])[5m:1m])
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] distance_covered_meters_total'
          op: ""
        - node: '[*parser.Call] rate(distance_covered_meters_total[1m])'
          op: rate
        - node: '[*parser.Call] deriv(rate(distance_covered_meters_total[1m])[5m:1m])'
          op: deriv
      position:
        start: 6
        end: 52
      type: function

---

[TestLabelsSource/35 - 1]
expr: foo - 1
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 0
        end: 3
      type: selector

---

[TestLabelsSource/36 - 1]
expr: foo / 5
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 0
        end: 3
      type: selector

---

[TestLabelsSource/37 - 1]
expr: -foo
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 1
        end: 4
      type: selector

---

[TestLabelsSource/38 - 1]
expr: sum(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo{job="myjob"})'
          op: sum
      position:
        start: 4
        end: 20
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/39 - 1]
expr: sum(count(foo{job="myjob"}) by(instance))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 41
        instance:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        job:
            reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 28
                end: 40
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] count by (instance) (foo{job="myjob"})'
          op: count
        - node: '[*parser.AggregateExpr] sum(count by (instance) (foo{job="myjob"}))'
          op: sum
      position:
        start: 10
        end: 26
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/40 - 1]
expr: sum(foo{job="myjob"}) > 20
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo{job="myjob"})'
          op: sum
      position:
        start: 4
        end: 20
      type: aggregation
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/41 - 1]
expr: sum(foo{job="myjob"}) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 30
                end: 33
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (job) (foo{job="myjob"})'
          op: sum
      position:
        start: 4
        end: 20
      type: aggregation

---

[TestLabelsSource/42 - 1]
expr: sum(foo) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 9
                end: 11
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 16
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 12
                end: 15
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job) (foo)'
          op: sum
      usedLabels:
        - job
      position:
        start: 4
        end: 7
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/43 - 1]
expr: sum(foo{job="myjob"}) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 22
                end: 24
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 29
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job) (foo{job="myjob"})'
          op: sum
      usedLabels:
        - job
      position:
        start: 4
        end: 20
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/44 - 1]
expr: abs(foo{job="myjob"} offset 5m)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 31
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"} offset 5m'
          op: ""
        - node: '[*parser.Call] abs(foo{job="myjob"} offset 5m)'
          op: abs
      position:
        start: 4
        end: 30
      type: function

---

[TestLabelsSource/45 - 1]
expr: abs(foo{job="myjob"} or bar{cluster="dev"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 43
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.Call] abs(foo{job="myjob"} or bar{cluster="dev"})'
          op: abs
      usedLabels:
        - job
      position:
        start: 4
        end: 42
      type: function
    - labels:
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 43
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{cluster="dev"}'
          op: ""
        - node: '[*parser.Call] abs(foo{job="myjob"} or bar{cluster="dev"})'
          op: abs
      position:
        start: 4
        end: 42
      type: function

---

[TestLabelsSource/46 - 1]
expr: sum(foo{job="myjob"} or bar{cluster="dev"}) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 61
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 52
                end: 60
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"} or bar{cluster="dev"})'
          op: sum
      usedLabels:
        - job
      position:
        start: 4
        end: 20
      type: aggregation
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 61
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 24
                end: 42
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 52
                end: 60
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{cluster="dev"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"} or bar{cluster="dev"})'
          op: sum
      position:
        start: 24
        end: 42
      type: aggregation

---

[TestLabelsSource/47 - 1]
expr: sum(foo{job="myjob"}) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 39
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 30
                end: 38
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"})'
          op: sum
      position:
        start: 4
        end: 20
      type: aggregation

---

[TestLabelsSource/48 - 1]
expr: min(foo{job="myjob"}) / max(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 45
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] min(foo{job="myjob"})'
          op: min
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 27
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
                job:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 27
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{job="myjob"}'
                  op: ""
                - node: '[*parser.AggregateExpr] max(foo{job="myjob"})'
                  op: max
            position:
                start: 28
                end: 44
            type: aggregation
            fixedLabels: true
          op: 57384
          depth: 0
          ison: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/49 - 1]
expr: max(foo{job="myjob"}) / min(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 45
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] max(foo{job="myjob"})'
          op: max
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 27
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
                job:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 27
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{job="myjob"}'
                  op: ""
                - node: '[*parser.AggregateExpr] min(foo{job="myjob"})'
                  op: min
            position:
                start: 28
                end: 44
            type: aggregation
            fixedLabels: true
          op: 57384
          depth: 0
          ison: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/50 - 1]
expr: avg(foo{job="myjob"}) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 22
                end: 24
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 29
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] avg by (job) (foo{job="myjob"})'
          op: avg
      usedLabels:
        - job
      position:
        start: 4
        end: 20
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/51 - 1]
expr: group(foo) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 11
                end: 13
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 18
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 14
                end: 17
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] group by (job) (foo)'
          op: group
      usedLabels:
        - job
      position:
        start: 6
        end: 9
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/52 - 1]
expr: stddev(rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[5m])'
          op: rate
        - node: '[*parser.AggregateExpr] stddev(rate(foo[5m]))'
          op: stddev
      position:
        start: 12
        end: 19
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/53 - 1]
expr: stdvar(rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[5m])'
          op: rate
        - node: '[*parser.AggregateExpr] stdvar(rate(foo[5m]))'
          op: stdvar
      position:
        start: 12
        end: 19
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/54 - 1]
expr: stddev_over_time(foo[5m])
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] stddev_over_time(foo[5m])'
          op: stddev_over_time
      position:
        start: 17
        end: 24
      type: function

---

[TestLabelsSource/55 - 1]
expr: stdvar_over_time(foo[5m])
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] stdvar_over_time(foo[5m])'
          op: stdvar_over_time
      position:
        start: 17
        end: 24
      type: function

---

[TestLabelsSource/56 - 1]
expr: quantile(0.9, rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 28
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[5m])'
          op: rate
        - args:
            - "0.9"
          node: '[*parser.AggregateExpr] quantile(0.9, rate(foo[5m]))'
          op: quantile
      position:
        start: 19
        end: 26
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/57 - 1]
expr: count_values("version", build_version)
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 12
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 38
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] build_version'
          op: ""
        - args:
            - '"version"'
          node: '[*parser.AggregateExpr] count_values("version", build_version)'
          op: count_values
      position:
        start: 24
        end: 37
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/58 - 1]
expr: count_values("version", build_version) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 51
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 47
                end: 50
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 51
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] build_version'
          op: ""
        - args:
            - '"version"'
          node: '[*parser.AggregateExpr] count_values without (job) ("version", build_version)'
          op: count_values
      position:
        start: 24
        end: 37
      type: aggregation

---

[TestLabelsSource/59 - 1]
expr: count_values("version", build_version{job="foo"}) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 62
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 58
                end: 61
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 62
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] build_version{job="foo"}'
          op: ""
        - args:
            - '"version"'
          node: '[*parser.AggregateExpr] count_values without (job) ("version", build_version{job="foo"})'
          op: count_values
      position:
        start: 24
        end: 48
      type: aggregation

---

[TestLabelsSource/60 - 1]
expr: count_values("version", build_version) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 39
                end: 41
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 46
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 42
                end: 45
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 46
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] build_version'
          op: ""
        - args:
            - '"version"'
          node: '[*parser.AggregateExpr] count_values by (job) ("version", build_version)'
          op: count_values
      usedLabels:
        - job
      position:
        start: 24
        end: 37
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/61 - 1]
expr: topk(10, foo{job="myjob"}) > 10
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 9
                end: 25
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, foo{job="myjob"})'
          op: topk
      position:
        start: 9
        end: 25
      type: aggregation
      isConditional: true

---

[TestLabelsSource/62 - 1]
expr: topk(10, foo or bar)
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, foo or bar)'
          op: topk
      position:
        start: 9
        end: 12
      type: aggregation
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, foo or bar)'
          op: topk
      position:
        start: 16
        end: 19
      type: aggregation

---

[TestLabelsSource/63 - 1]
expr: rate(foo[10m])
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[10m])'
          op: rate
      position:
        start: 5
        end: 13
      type: function

---

[TestLabelsSource/64 - 1]
expr: sum(rate(foo[10m])) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 37
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 28
                end: 36
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[10m])'
          op: rate
        - node: '[*parser.AggregateExpr] sum without (instance) (rate(foo[10m]))'
          op: sum
      position:
        start: 9
        end: 17
      type: aggregation

---

[TestLabelsSource/65 - 1]
expr: foo{job="foo"} / bar
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 20
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 17
                end: 20
            type: selector
          op: 57384
          depth: 0
          ison: false
      usedLabels:
        - job
      position:
        start: 0
        end: 14
      type: selector

---

[TestLabelsSource/66 - 1]
expr: foo{job="foo"} * on(instance) bar
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 17
                end: 29
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 33
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 20
                end: 28
        job:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 17
                end: 29
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 30
                end: 33
            type: selector
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 0
        end: 14
      type: selector
      fixedLabels: true

---

[TestLabelsSource/67 - 1]
expr: foo{job="foo"} * on(instance) group_left(bar) bar
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 49
        bar:
            reason: Query is using `group_left(bar)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 41
                end: 44
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 20
                end: 28
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - bar
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 46
                end: 49
            type: selector
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 0
        end: 14
      type: selector

---

[TestLabelsSource/68 - 1]
expr: foo{job="foo"} * on(instance) group_left(cluster) bar{cluster="bar", ignored="true"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 84
        cluster:
            reason: Query is using `group_left(cluster)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 41
                end: 48
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 20
                end: 28
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - cluster
          src:
            labels:
                cluster:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 50
                        end: 84
                ignored:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 50
                        end: 84
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{cluster="bar",ignored="true"}'
                  op: ""
            position:
                start: 50
                end: 84
            type: selector
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 0
        end: 14
      type: selector

---

[TestLabelsSource/69 - 1]
expr: foo{job="foo", ignored="true"} * on(instance) group_right(job) bar{cluster="bar"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 81
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 63
                end: 81
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 36
                end: 44
        job:
            reason: Query is using `group_right(job)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 58
                end: 61
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{cluster="bar"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - job
          src:
            labels:
                ignored:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 0
                        end: 30
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 0
                        end: 30
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{ignored="true",job="foo"}'
                  op: ""
            position:
                start: 0
                end: 30
            type: selector
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 63
        end: 81
      type: selector

---

[TestLabelsSource/70 - 1]
expr: count(foo / bar)
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 5
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 16
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] count(foo / bar)'
          op: count
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 12
                end: 15
            type: selector
          op: 57384
          depth: 1
          ison: false
      position:
        start: 6
        end: 9
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/71 - 1]
expr: count(up{job="a"} / on () up{job="b"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 5
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 38
        job:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 20
                end: 25
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="a"}'
          op: ""
        - node: '[*parser.AggregateExpr] count(up{job="a"} / on () up{job="b"})'
          op: count
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 26
                        end: 37
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] up{job="b"}'
                  op: ""
            position:
                start: 26
                end: 37
            type: selector
          op: 57384
          depth: 1
          ison: true
      position:
        start: 6
        end: 17
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/72 - 1]
expr: count(up{job="a"} / on (env) up{job="b"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 5
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 41
        env:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 5
        job:
            reason: Query is using one-to-one vector matching with `on(env)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 20
                end: 28
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="a"}'
          op: ""
        - node: '[*parser.AggregateExpr] count(up{job="a"} / on (env) up{job="b"})'
          op: count
      joins:
        - matchinglabels:
            - env
          addedlabels: []
          src:
            labels:
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 29
                        end: 40
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] up{job="b"}'
                  op: ""
            position:
                start: 29
                end: 40
            type: selector
          op: 57384
          depth: 1
          ison: true
      position:
        start: 6
        end: 17
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/73 - 1]
expr: foo{job="foo", instance="1"} and bar
output:
    - labels:
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{instance="1",job="foo"}'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 33
                end: 36
            type: selector
          op: 57389
          depth: 0
          ison: false
      usedLabels:
        - instance
        - job
      position:
        start: 0
        end: 28
      type: selector

---

[TestLabelsSource/74 - 1]
expr: foo{job="foo", instance="1"} and on(cluster) bar
output:
    - labels:
        cluster:
            reason: Query is using many-to-many vector matching with `on(cluster)`, labels included inside `on(...)` will be present on the results if matched time series have them.
            kind: included
            fragment:
                start: 36
                end: 43
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{instance="1",job="foo"}'
          op: ""
      joins:
        - matchinglabels:
            - cluster
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 45
                end: 48
            type: selector
          op: 57389
          depth: 0
          ison: true
      usedLabels:
        - cluster
      position:
        start: 0
        end: 28
      type: selector

---

[TestLabelsSource/75 - 1]
expr: topk(10, foo)
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, foo)'
          op: topk
      position:
        start: 9
        end: 12
      type: aggregation

---

[TestLabelsSource/76 - 1]
expr: topk(10, foo) without(cluster)
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk without (cluster) (10, foo)'
          op: topk
      position:
        start: 9
        end: 12
      type: aggregation

---

[TestLabelsSource/77 - 1]
expr: topk(10, foo) by(cluster)
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk by (cluster) (10, foo)'
          op: topk
      position:
        start: 9
        end: 12
      type: aggregation

---

[TestLabelsSource/78 - 1]
expr: bottomk(10, sum(rate(foo[5m])) without(job))
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 12
                end: 43
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 39
                end: 42
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[5m])'
          op: rate
        - node: '[*parser.AggregateExpr] sum without (job) (rate(foo[5m]))'
          op: sum
        - args:
            - "10"
          node: '[*parser.AggregateExpr] bottomk(10, sum without (job) (rate(foo[5m])))'
          op: bottomk
      position:
        start: 21
        end: 28
      type: aggregation

---

[TestLabelsSource/79 - 1]
expr: foo or bar
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 0
        end: 3
      type: selector
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      position:
        start: 7
        end: 10
      type: selector

---

[TestLabelsSource/80 - 1]
expr: foo or bar or baz
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 0
        end: 3
      type: selector
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      position:
        start: 7
        end: 10
      type: selector
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] baz'
          op: ""
      position:
        start: 14
        end: 17
      type: selector

---

[TestLabelsSource/81 - 1]
expr: (foo or bar) or baz
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 1
        end: 4
      type: selector
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      position:
        start: 8
        end: 11
      type: selector
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] baz'
          op: ""
      position:
        start: 16
        end: 19
      type: selector

---

[TestLabelsSource/82 - 1]
expr: foo unless bar
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      unless:
        - matchinglabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 11
                end: 14
            type: selector
          ison: false
      position:
        start: 0
        end: 3
      type: selector

---

[TestLabelsSource/83 - 1]
expr: foo unless bar > 5
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      unless:
        - matchinglabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 11
                end: 14
            type: selector
            isConditional: true
          ison: false
      position:
        start: 0
        end: 3
      type: selector

---

[TestLabelsSource/84 - 1]
expr: foo unless bar unless baz
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      unless:
        - matchinglabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 11
                end: 14
            type: selector
          ison: false
        - matchinglabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] baz'
                  op: ""
            position:
                start: 22
                end: 25
            type: selector
          ison: false
      position:
        start: 0
        end: 3
      type: selector

---

[TestLabelsSource/85 - 1]
expr: count(sum(up{job="foo", cluster="dev"}) by(job, cluster) == 0) without(job, cluster)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 40
                end: 42
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 84
        cluster:
            reason: Query is using aggregation with `without(job, cluster)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 76
                end: 83
        job:
            reason: Query is using aggregation with `without(job, cluster)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 71
                end: 74
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{cluster="dev",job="foo"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job, cluster) (up{cluster="dev",job="foo"})'
          op: sum
        - node: '[*parser.AggregateExpr] count without (job, cluster) (sum by (job, cluster) (up{cluster="dev",job="foo"}) == 0)'
          op: count
      position:
        start: 10
        end: 38
      type: aggregation
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/86 - 1]
expr: year()
output:
    - labels:
        "":
            reason: Calling `year()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      returns: vector
      operations:
        - node: '[*parser.Call] year()'
          op: year
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 6
      type: function
      fixedLabels: true

---

[TestLabelsSource/87 - 1]
expr: year(foo)
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] year(foo)'
          op: year
      position:
        start: 5
        end: 8
      type: function

---

[TestLabelsSource/88 - 1]
expr: label_join(up{job="api-server",src1="a",src2="b",src3="c"}, "foo", ",", "src1", "src2", "src3")
output:
    - labels:
        foo:
            reason: This label will be added to the result by label_join() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 95
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src1:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src2:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src3:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="api-server",src1="a",src2="b",src3="c"}'
          op: ""
        - args:
            - '"foo"'
            - '","'
            - '"src1"'
            - '"src2"'
            - '"src3"'
          node: '[*parser.Call] label_join(up{job="api-server",src1="a",src2="b",src3="c"}, "foo", ",", "src1", "src2", "src3")'
          op: label_join
      usedLabels:
        - src1
        - src2
        - src3
      position:
        start: 11
        end: 58
      type: function

---

[TestLabelsSource/89 - 1]
expr: |4-

    (
     sum(foo:sum > 0) without(notify)
     * on(job) group_left(notify)
     job:notify
    )
    and on(job)
    sum(foo:count) by(job) > 20
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 4
                end: 78
        job:
            reason: Query is using many-to-many vector matching with `on(job)`, labels included inside `on(...)` will be present on the results if matched time series have them.
            kind: included
            fragment:
                start: 111
                end: 114
        notify:
            reason: Query is using `group_left(notify)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 59
                end: 65
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo:sum'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (notify) (foo:sum > 0)'
          op: sum
      joins:
        - matchinglabels:
            - job
          addedlabels:
            - notify
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] job:notify'
                  op: ""
            position:
                start: 68
                end: 78
            type: selector
          op: 57395
          depth: 0
          ison: true
        - matchinglabels:
            - job
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 108
                        end: 110
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 93
                        end: 115
                job:
                    reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 111
                        end: 114
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo:count'
                  op: ""
                - node: '[*parser.AggregateExpr] sum by (job) (foo:count)'
                  op: sum
            usedLabels:
                - job
            position:
                start: 97
                end: 106
            type: aggregation
            fixedLabels: true
            isConditional: true
          op: 57389
          depth: 0
          ison: true
      usedLabels:
        - job
      position:
        start: 8
        end: 15
      type: aggregation
      isConditional: true

---

[TestLabelsSource/90 - 1]
expr: container_file_descriptors / on (instance, app_name) container_ulimits_soft{ulimit="max_open_files"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 29
                end: 52
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 100
        app_name:
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 43
                end: 51
        instance:
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 33
                end: 41
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] container_file_descriptors'
          op: ""
      joins:
        - matchinglabels:
            - instance
            - app_name
          addedlabels: []
          src:
            labels:
                ulimit:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 53
                        end: 100
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] container_ulimits_soft{ulimit="max_open_files"}'
                  op: ""
            position:
                start: 53
                end: 100
            type: selector
          op: 57384
          depth: 0
          ison: true
      usedLabels:
        - instance
        - app_name
      position:
        start: 0
        end: 26
      type: selector
      fixedLabels: true

---

[TestLabelsSource/91 - 1]
expr: container_file_descriptors / on (instance, app_name) group_left() container_ulimits_soft{ulimit="max_open_files"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 113
        app_name:
            reason: Query is using many-to-one vector matching with `on(instance, app_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 43
                end: 51
        instance:
            reason: Query is using many-to-one vector matching with `on(instance, app_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 33
                end: 41
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] container_file_descriptors'
          op: ""
      joins:
        - matchinglabels:
            - instance
            - app_name
          addedlabels: []
          src:
            labels:
                ulimit:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 66
                        end: 113
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] container_ulimits_soft{ulimit="max_open_files"}'
                  op: ""
            position:
                start: 66
                end: 113
            type: selector
          op: 57384
          depth: 0
          ison: true
      usedLabels:
        - instance
        - app_name
      position:
        start: 0
        end: 26
      type: selector

---

[TestLabelsSource/92 - 1]
expr: absent(foo{job="bar"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 22
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="bar"}'
          op: ""
        - node: '[*parser.Call] absent(foo{job="bar"})'
          op: absent
      usedLabels:
        - job
      position:
        start: 7
        end: 21
      type: function
      fixedLabels: true

---

[TestLabelsSource/93 - 1]
expr: absent(foo{job="bar", cluster!="dev", instance=~".+", env="prod"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        env:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 66
        instance:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 66
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{cluster!="dev",env="prod",instance=~".+",job="bar"}'
          op: ""
        - node: '[*parser.Call] absent(foo{cluster!="dev",env="prod",instance=~".+",job="bar"})'
          op: absent
      usedLabels:
        - job
        - env
      position:
        start: 7
        end: 65
      type: function
      fixedLabels: true

---

[TestLabelsSource/94 - 1]
expr: absent(sum(foo) by(job, instance))
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 7
                end: 33
        instance:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job, instance) (foo)'
          op: sum
        - node: '[*parser.Call] absent(sum by (job, instance) (foo))'
          op: absent
      position:
        start: 7
        end: 33
      type: function
      fixedLabels: true

---

[TestLabelsSource/95 - 1]
expr: absent(foo{job="prometheus", xxx="1"}) AND on(job) prometheus_build_info
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
        xxx:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="prometheus",xxx="1"}'
          op: ""
        - node: '[*parser.Call] absent(foo{job="prometheus",xxx="1"})'
          op: absent
      joins:
        - matchinglabels:
            - job
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] prometheus_build_info'
                  op: ""
            position:
                start: 51
                end: 72
            type: selector
          op: 57389
          depth: 0
          ison: true
      usedLabels:
        - job
        - xxx
      position:
        start: 7
        end: 37
      type: function
      fixedLabels: true

---

[TestLabelsSource/96 - 1]
expr: 1 + sum(foo) by(notjob)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(notjob)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 4
                end: 23
        notjob:
            reason: Query is using aggregation with `by(notjob)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 16
                end: 22
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (notjob) (foo)'
          op: sum
      usedLabels:
        - notjob
      position:
        start: 8
        end: 11
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/97 - 1]
expr: count(node_exporter_build_info) by (instance, version) != ignoring(package,version) group_left(foo) count(deb_package_version) by (instance, version, package)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 32
                end: 35
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 158
        foo:
            reason: Query is using `group_left(foo)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 95
                end: 98
        instance:
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 36
                end: 44
        version:
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 46
                end: 53
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] node_exporter_build_info'
          op: ""
        - node: '[*parser.AggregateExpr] count by (instance, version) (node_exporter_build_info)'
          op: count
      joins:
        - matchinglabels:
            - package
            - version
          addedlabels:
            - foo
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 127
                        end: 130
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 100
                        end: 158
                instance:
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 131
                        end: 139
                package:
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 150
                        end: 157
                version:
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 141
                        end: 148
            deadLabels:
                - name: foo
                  reason: You can't use `foo` because this label is not possible here.
                  labelreason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                  usagefragment:
                    start: 95
                    end: 98
                  labelfragment:
                    start: 127
                    end: 130
                  kind: 0
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] deb_package_version'
                  op: ""
                - node: '[*parser.AggregateExpr] count by (instance, version, package) (deb_package_version)'
                  op: count
            usedLabels:
                - instance
                - version
                - package
            position:
                start: 106
                end: 125
            type: aggregation
            fixedLabels: true
          op: 57396
          depth: 0
          ison: false
      usedLabels:
        - instance
        - version
        - foo
      position:
        start: 6
        end: 30
      type: aggregation
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/98 - 1]
expr: absent(foo) or absent(bar)
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] absent(foo)'
          op: absent
      position:
        start: 7
        end: 10
      type: function
      fixedLabels: true
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 15
                end: 21
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
        - node: '[*parser.Call] absent(bar)'
          op: absent
      position:
        start: 22
        end: 25
      type: function
      fixedLabels: true

---

[TestLabelsSource/99 - 1]
expr: absent_over_time(foo[5m]) or absent(bar)
output:
    - labels:
        "":
            reason: |-
                The [absent_over_time()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent_over_time) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 16
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] absent_over_time(foo[5m])'
          op: absent_over_time
      position:
        start: 17
        end: 24
      type: function
      fixedLabels: true
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 29
                end: 35
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
        - node: '[*parser.Call] absent(bar)'
          op: absent
      position:
        start: 36
        end: 39
      type: function
      fixedLabels: true

---

[TestLabelsSource/100 - 1]
expr: bar * on() group_right(cluster, env) absent(foo{job="xxx"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 37
                end: 43
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 59
        cluster:
            reason: Query is using `group_right(cluster, env)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 23
                end: 30
        env:
            reason: Query is using `group_right(cluster, env)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 32
                end: 35
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 37
                end: 59
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="xxx"}'
          op: ""
        - node: '[*parser.Call] absent(foo{job="xxx"})'
          op: absent
      joins:
        - matchinglabels: []
          addedlabels:
            - cluster
            - env
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 0
                end: 3
            type: selector
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - job
      position:
        start: 44
        end: 58
      type: function
      fixedLabels: true

---

[TestLabelsSource/101 - 1]
expr: bar * on() group_right() absent(foo{job="xxx"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 25
                end: 31
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 47
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 25
                end: 47
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="xxx"}'
          op: ""
        - node: '[*parser.Call] absent(foo{job="xxx"})'
          op: absent
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            position:
                start: 0
                end: 3
            type: selector
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - job
      position:
        start: 32
        end: 46
      type: function
      fixedLabels: true

---

[TestLabelsSource/102 - 1]
expr: vector(1)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedLabels: true

---

[TestLabelsSource/103 - 1]
expr: vector(scalar(foo))
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      returns: vector
      operations:
        - args:
            - scalar(foo)
          node: '[*parser.Call] vector(scalar(foo))'
          op: vector
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 19
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 19
      type: function
      fixedLabels: true

---

[TestLabelsSource/104 - 1]
expr: vector(0.0  >= bool 0.5) == 1
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadInfo:
        reason: '`vector(0.0  >= bool 0.5) == 1` always evaluates to `0 == 1` which is not possible, so it will never return anything.'
        fragment:
            start: 0
            end: 24
      returns: vector
      operations:
        - args:
            - 0 >= bool 0.5
          node: '[*parser.Call] vector(0 >= bool 0.5)'
          op: vector
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 24
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 24
      type: function
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/105 - 1]
expr: sum_over_time(foo{job="myjob"}[5m])
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 35
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.Call] sum_over_time(foo{job="myjob"}[5m])'
          op: sum_over_time
      position:
        start: 14
        end: 34
      type: function

---

[TestLabelsSource/106 - 1]
expr: days_in_month()
output:
    - labels:
        "":
            reason: Calling `days_in_month()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 15
      returns: vector
      operations:
        - node: '[*parser.Call] days_in_month()'
          op: days_in_month
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 15
      type: function
      fixedLabels: true

---

[TestLabelsSource/107 - 1]
expr: days_in_month(foo{job="foo"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 29
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
        - node: '[*parser.Call] days_in_month(foo{job="foo"})'
          op: days_in_month
      position:
        start: 14
        end: 28
      type: function

---

[TestLabelsSource/108 - 1]
expr: label_replace(up{job="api-server",service="a:c"}, "foo", "$1", "service", "(.*):.*")
output:
    - labels:
        foo:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 84
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 14
                end: 48
        service:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 14
                end: 48
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="api-server",service="a:c"}'
          op: ""
        - args:
            - '"foo"'
            - '"$1"'
            - '"service"'
            - '"(.*):.*"'
          node: '[*parser.Call] label_replace(up{job="api-server",service="a:c"}, "foo", "$1", "service", "(.*):.*")'
          op: label_replace
      usedLabels:
        - service
      position:
        start: 14
        end: 48
      type: function

---

[TestLabelsSource/109 - 1]
expr: label_replace(sum by (pod) (pod_status) > 0, "cluster", "$1", "pod", "(.*)")
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 18
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 14
                end: 39
        cluster:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 76
        pod:
            reason: Query is using aggregation with `by(pod)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 22
                end: 25
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] pod_status'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (pod) (pod_status)'
          op: sum
        - args:
            - '"cluster"'
            - '"$1"'
            - '"pod"'
            - '"(.*)"'
          node: '[*parser.Call] label_replace(sum by (pod) (pod_status) > 0, "cluster", "$1", "pod", "(.*)")'
          op: label_replace
      usedLabels:
        - pod
      position:
        start: 14
        end: 43
      type: function
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/110 - 1]
expr: (time() - my_metric) > 5*3600
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] my_metric'
          op: ""
      position:
        start: 10
        end: 19
      type: selector
      isConditional: true

---

[TestLabelsSource/111 - 1]
expr: up{instance="a", job="prometheus"} * ignoring(job) up{instance="a", job="pint"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 79
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using one-to-one vector matching with `ignoring(job)`, all labels included inside `ignoring(...)` will be removed on the results.
            kind: excluded
            fragment:
                start: 46
                end: 49
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{instance="a",job="prometheus"}'
          op: ""
      joins:
        - matchinglabels:
            - job
          addedlabels: []
          src:
            labels:
                instance:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 51
                        end: 79
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 51
                        end: 79
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] up{instance="a",job="pint"}'
                  op: ""
            position:
                start: 51
                end: 79
            type: selector
          op: 57395
          depth: 0
          ison: false
      usedLabels:
        - instance
      position:
        start: 0
        end: 34
      type: selector

---

[TestLabelsSource/112 - 1]
expr: |4

    avg without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"})
    < 0.5 > 0
    or sum without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"})
    < on() count(colo_router_tier:disabled_pops:max{tier="1",router=~"edge.*"}) * 0.4 > 0
    or avg without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"})
    < 0.1 > 0
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 101
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 21
                end: 28
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 30
                end: 38
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 13
                end: 19
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"}'
          op: ""
        - node: '[*parser.AggregateExpr] avg without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"})'
          op: avg
      position:
        start: 41
        end: 100
      type: aggregation
      isConditional: true
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 216
                end: 220
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 115
                end: 295
        cidr_use_case:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 216
                end: 220
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 135
                end: 142
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 144
                end: 152
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 127
                end: 133
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"})'
          op: sum
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 226
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 289
                router:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 226
                tier:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 226
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_router_tier:disabled_pops:max{router=~"edge.*",tier="1"}'
                  op: ""
                - node: '[*parser.AggregateExpr] count(colo_router_tier:disabled_pops:max{router=~"edge.*",tier="1"})'
                  op: count
            position:
                start: 227
                end: 288
            type: aggregation
            fixedLabels: true
          op: 57391
          depth: 0
          ison: true
      position:
        start: 155
        end: 212
      type: aggregation
      fixedLabels: true
      isConditional: true
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 303
                end: 404
        cidr_use_case:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 343
                end: 403
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 323
                end: 330
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 332
                end: 340
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 315
                end: 321
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"}'
          op: ""
        - node: '[*parser.AggregateExpr] avg without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"})'
          op: avg
      position:
        start: 343
        end: 403
      type: aggregation
      isConditional: true

---

[TestLabelsSource/113 - 1]
expr: label_replace(sum(foo) without(instance), "instance", "none", "", "")
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 14
                end: 40
        instance:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 69
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (instance) (foo)'
          op: sum
        - args:
            - '"instance"'
            - '"none"'
            - '""'
            - '""'
          node: '[*parser.Call] label_replace(sum without (instance) (foo), "instance", "none", "", "")'
          op: label_replace
      usedLabels:
        - ""
      position:
        start: 14
        end: 40
      type: function

---

[TestLabelsSource/114 - 1]
expr: |4-

    sum by (region, target, colo_name) (
        sum_over_time(probe_success{job="abc"}[5m])
     or
     vector(1)
    ) == 0
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 102
        colo_name:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 25
                end: 34
        job:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 35
        region:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 9
                end: 15
        target:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 17
                end: 23
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] probe_success{job="abc"}'
          op: ""
        - node: '[*parser.Call] sum_over_time(probe_success{job="abc"}[5m])'
          op: sum_over_time
        - node: '[*parser.AggregateExpr] sum by (region, target, colo_name) (sum_over_time(probe_success{job="abc"}[5m]) or vector(1))'
          op: sum
      usedLabels:
        - region
        - target
        - colo_name
      position:
        start: 56
        end: 84
      type: aggregation
      fixedLabels: true
      isConditional: true
    - labels:
        "":
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 102
        colo_name:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
        region:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
        target:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
      deadInfo:
        reason: '`vector(1) == 0` always evaluates to `1 == 0` which is not possible, so it will never return anything.'
        fragment:
            start: 91
            end: 100
      deadLabels:
        - name: region
          reason: You can't use `region` because this label is not possible here.
          labelreason: Calling `vector()` will return a vector value with no labels.
          usagefragment:
            start: 9
            end: 15
          labelfragment:
            start: 91
            end: 97
          kind: 0
        - name: target
          reason: You can't use `target` because this label is not possible here.
          labelreason: Calling `vector()` will return a vector value with no labels.
          usagefragment:
            start: 17
            end: 23
          labelfragment:
            start: 91
            end: 97
          kind: 0
        - name: colo_name
          reason: You can't use `colo_name` because this label is not possible here.
          labelreason: Calling `vector()` will return a vector value with no labels.
          usagefragment:
            start: 25
            end: 34
          labelfragment:
            start: 91
            end: 97
          kind: 0
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
        - node: '[*parser.AggregateExpr] sum by (region, target, colo_name) (sum_over_time(probe_success{job="abc"}[5m]) or vector(1))'
          op: sum
      usedLabels:
        - region
        - target
        - colo_name
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 91
            end: 100
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 91
        end: 100
      type: aggregation
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/115 - 1]
expr: vector(1) or foo
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedLabels: true
    - deadInfo:
        reason: The left hand side always returs something and so the right hand side is never used.
        fragment:
            start: 13
            end: 16
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 13
        end: 16
      type: selector

---

[TestLabelsSource/116 - 1]
expr: vector(0) > 0
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadInfo:
        reason: '`vector(0) > 0` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 0
            end: 9
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/117 - 1]
expr: vector(0) > vector(1)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadInfo:
        reason: '`vector(0) > vector(1)` always evaluates to `0 > 1` which is not possible, so it will never return anything.'
        fragment:
            start: 0
            end: 9
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 12
                        end: 18
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 12
                    end: 21
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 12
                end: 21
            type: function
            fixedLabels: true
          op: 57388
          depth: 0
          ison: false
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/118 - 1]
expr: sum(foo or vector(0)) > 0
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo or vector(0))'
          op: sum
      position:
        start: 4
        end: 7
      type: aggregation
      fixedLabels: true
      isConditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadInfo:
        reason: '`vector(0) > 0` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 11
            end: 20
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(foo or vector(0))'
          op: sum
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 11
            end: 20
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 11
        end: 20
      type: aggregation
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/119 - 1]
expr: (sum(foo or vector(1)) > 0) == 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo or vector(1))'
          op: sum
      position:
        start: 5
        end: 8
      type: aggregation
      fixedLabels: true
      isConditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadInfo:
        reason: '`vector(1) == 2` always evaluates to `1 == 2` which is not possible, so it will never return anything.'
        fragment:
            start: 12
            end: 21
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(foo or vector(1))'
          op: sum
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 12
            end: 21
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: aggregation
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/120 - 1]
expr: (sum(foo or vector(1)) > 0) != 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo or vector(1))'
          op: sum
      position:
        start: 5
        end: 8
      type: aggregation
      fixedLabels: true
      isConditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(foo or vector(1))'
          op: sum
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 12
            end: 21
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: aggregation
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/121 - 1]
expr: (sum(foo or vector(2)) > 0) != 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo or vector(2))'
          op: sum
      position:
        start: 5
        end: 8
      type: aggregation
      fixedLabels: true
      isConditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadInfo:
        reason: '`vector(2) != 2` always evaluates to `2 != 2` which is not possible, so it will never return anything.'
        fragment:
            start: 12
            end: 21
      returns: vector
      operations:
        - args:
            - "2"
          node: '[*parser.Call] vector(2)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(foo or vector(2))'
          op: sum
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 12
            end: 21
        returnednumber: 2
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: aggregation
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/122 - 1]
expr: |-
    (sum(sometimes{foo!="bar"} or vector(0)))
    or
    ((bob > 10) or sum(foo) or vector(1))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 40
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] sometimes{foo!="bar"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(sometimes{foo!="bar"} or vector(0))'
          op: sum
      position:
        start: 5
        end: 26
      type: aggregation
      fixedLabels: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 40
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(sometimes{foo!="bar"} or vector(0))'
          op: sum
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 30
            end: 39
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 30
        end: 39
      type: aggregation
      fixedLabels: true
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] bob'
          op: ""
      position:
        start: 47
        end: 50
      type: selector
      isConditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 60
                end: 63
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 60
                end: 68
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo)'
          op: sum
      position:
        start: 64
        end: 67
      type: aggregation
      fixedLabels: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 72
                end: 78
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 72
            end: 81
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 72
        end: 81
      type: function
      fixedLabels: true

---

[TestLabelsSource/123 - 1]
expr: |4-

    (
     sum(sometimes{foo!="bar"})
     or
     vector(1)
    ) and (
     ((bob > 10) or sum(bar))
     or
     notfound > 0
    )
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 4
                end: 7
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 4
                end: 30
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] sometimes{foo!="bar"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(sometimes{foo!="bar"})'
          op: sum
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bob'
                  op: ""
            position:
                start: 57
                end: 60
            type: selector
            isConditional: true
          op: 57389
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 73
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 78
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar)'
                  op: sum
            position:
                start: 74
                end: 77
            type: aggregation
            fixedLabels: true
          op: 57389
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] notfound'
                  op: ""
            position:
                start: 85
                end: 93
            type: selector
            isConditional: true
          op: 57389
          depth: 0
          ison: false
      position:
        start: 8
        end: 29
      type: aggregation
      fixedLabels: true
      isConditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 36
                end: 42
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bob'
                  op: ""
            position:
                start: 57
                end: 60
            type: selector
            isConditional: true
          op: 57389
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 73
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 78
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar)'
                  op: sum
            position:
                start: 74
                end: 77
            type: aggregation
            fixedLabels: true
          op: 57389
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] notfound'
                  op: ""
            position:
                start: 85
                end: 93
            type: selector
            isConditional: true
          op: 57389
          depth: 0
          ison: false
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 36
            end: 45
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 36
        end: 45
      type: function
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/124 - 1]
expr: foo offset 5m > 5
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo offset 5m'
          op: ""
      position:
        start: 0
        end: 13
      type: selector
      isConditional: true

---

[TestLabelsSource/125 - 1]
expr: |4

    (rate(metric2[5m]) or vector(0)) +
    (rate(metric1[5m]) or vector(1)) +
    (rate(metric3{log_name="samplerd"}[5m]) or vector(2)) > 0
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 124
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] metric2'
          op: ""
        - node: '[*parser.Call] rate(metric2[5m])'
          op: rate
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metric1'
                  op: ""
                - node: '[*parser.Call] rate(metric1[5m])'
                  op: rate
            position:
                start: 42
                end: 53
            type: function
          op: 57383
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 58
                        end: 64
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 58
                    end: 67
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 58
                end: 67
            type: function
            fixedLabels: true
          op: 57383
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                log_name:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 72
                        end: 110
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metric3{log_name="samplerd"}'
                  op: ""
                - node: '[*parser.Call] rate(metric3{log_name="samplerd"}[5m])'
                  op: rate
            usedLabels:
                - log_name
            position:
                start: 77
                end: 109
            type: function
          op: 57383
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 114
                        end: 120
            returns: vector
            operations:
                - args:
                    - "2"
                  node: '[*parser.Call] vector(2)'
                  op: vector
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 114
                    end: 123
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 114
                end: 123
            type: function
            fixedLabels: true
          op: 57383
          depth: 0
          ison: false
      position:
        start: 7
        end: 18
      type: function
      isConditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 23
                end: 29
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 124
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metric1'
                  op: ""
                - node: '[*parser.Call] rate(metric1[5m])'
                  op: rate
            position:
                start: 42
                end: 53
            type: function
          op: 57383
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 58
                        end: 64
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 58
                    end: 67
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 58
                end: 67
            type: function
            fixedLabels: true
          op: 57383
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                log_name:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 72
                        end: 110
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metric3{log_name="samplerd"}'
                  op: ""
                - node: '[*parser.Call] rate(metric3{log_name="samplerd"}[5m])'
                  op: rate
            usedLabels:
                - log_name
            position:
                start: 77
                end: 109
            type: function
          op: 57383
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 114
                        end: 120
            returns: vector
            operations:
                - args:
                    - "2"
                  node: '[*parser.Call] vector(2)'
                  op: vector
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 114
                    end: 123
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 114
                end: 123
            type: function
            fixedLabels: true
          op: 57383
          depth: 0
          ison: false
      returnInfo:
        logicalexpr: vector(0) + vector(1) + vector(2)
        valueposition:
            start: 23
            end: 32
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 23
        end: 32
      type: function
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/126 - 1]
expr: label_replace(vector(1), "nexthop_tag", "$1", "nexthop", "(.+)")
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 14
                end: 20
        nexthop_tag:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 64
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
        - args:
            - '"nexthop_tag"'
            - '"$1"'
            - '"nexthop"'
            - '"(.+)"'
          node: '[*parser.Call] label_replace(vector(1), "nexthop_tag", "$1", "nexthop", "(.+)")'
          op: label_replace
      usedLabels:
        - nexthop
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 14
            end: 23
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 14
        end: 23
      type: function
      fixedLabels: true

---

[TestLabelsSource/127 - 1]
expr: (sum(foo{job="myjob"}))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo{job="myjob"})'
          op: sum
      position:
        start: 5
        end: 21
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/128 - 1]
expr: (-foo{job="myjob"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 2
                end: 18
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
      position:
        start: 2
        end: 18
      type: selector

---

[TestLabelsSource/129 - 1]
expr: |4-

    ((( group(vector(0)) ))) > 0
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 5
                end: 10
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 5
                end: 21
      deadInfo:
        reason: '`vector(0) > 0` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 11
            end: 20
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
        - node: '[*parser.AggregateExpr] group(vector(0))'
          op: group
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 11
            end: 20
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 11
        end: 20
      type: aggregation
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/130 - 1]
expr: 1 > bool 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadInfo:
        reason: '`1 > 5` always evaluates to `1 > 5` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 0
            end: 1
      returns: scalar
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 1
      type: number
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/131 - 1]
expr: prometheus_ready{job="prometheus"} unless vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
          op: ""
      unless:
        - matchinglabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 48
            deadInfo:
                reason: The right hand side will never be matched because it doesn't have the `job` label while the left hand side will. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 42
                    end: 48
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 42
                    end: 51
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 42
                end: 51
            type: function
            fixedLabels: true
          ison: false
      usedLabels:
        - job
      position:
        start: 0
        end: 34
      type: selector

---

[TestLabelsSource/132 - 1]
expr: prometheus_ready{job="prometheus"} unless on() vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      deadInfo:
        reason: This query will never return anything because the `unless` query always returns something.
        fragment:
            start: 47
            end: 56
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
          op: ""
      unless:
        - matchinglabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 47
                        end: 53
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 47
                    end: 56
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 47
                end: 56
            type: function
            fixedLabels: true
          ison: true
      position:
        start: 0
        end: 34
      type: selector

---

[TestLabelsSource/133 - 1]
expr: prometheus_ready{job="prometheus"} unless on(job) vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
          op: ""
      unless:
        - matchinglabels:
            - job
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 50
                        end: 56
            deadInfo:
                reason: The right hand side will never be matched because it doesn't have the `job` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 50
                    end: 56
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 50
                    end: 59
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 50
                end: 59
            type: function
            fixedLabels: true
          ison: true
      usedLabels:
        - job
      position:
        start: 0
        end: 34
      type: selector

---

[TestLabelsSource/134 - 1]
expr: |4

    max by (instance, cluster) (cf_node_role{kubernetes_role="master",role="kubernetes"})
    unless
       sum by (instance, cluster) (time() - node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"})
       * on (instance) group_left (cluster)
        cf_node_role{kubernetes_role="master",role="kubernetes"}
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 86
        cluster:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 19
                end: 26
        instance:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 9
                end: 17
        kubernetes_role:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 27
        role:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 27
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] cf_node_role{kubernetes_role="master",role="kubernetes"}'
          op: ""
        - node: '[*parser.AggregateExpr] max by (instance, cluster) (cf_node_role{kubernetes_role="master",role="kubernetes"})'
          op: max
      unless:
        - matchinglabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 99
                        end: 102
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 95
                        end: 303
                cluster:
                    reason: Query is using `group_left(cluster)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 234
                        end: 241
                instance:
                    reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 212
                        end: 220
                name:
                    reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 99
                        end: 121
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum by (instance, cluster) (time() - node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"})'
                  op: sum
            joins:
                - matchinglabels:
                    - instance
                  addedlabels:
                    - cluster
                  src:
                    labels:
                        kubernetes_role:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 247
                                end: 303
                        role:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 247
                                end: 303
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] cf_node_role{kubernetes_role="master",role="kubernetes"}'
                          op: ""
                    position:
                        start: 247
                        end: 303
                    type: selector
                  op: 57395
                  depth: 0
                  ison: true
            usedLabels:
                - instance
                - cluster
            position:
                start: 132
                end: 201
            type: aggregation
            fixedLabels: true
          ison: false
      usedLabels:
        - instance
        - cluster
      position:
        start: 29
        end: 85
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/135 - 1]
expr: foo{a="1"} * on() bar{b="2"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 17
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 28
        a:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 17
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 18
                        end: 28
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
            position:
                start: 18
                end: 28
            type: selector
          op: 57395
          depth: 0
          ison: true
      position:
        start: 0
        end: 10
      type: selector
      fixedLabels: true

---

[TestLabelsSource/136 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) bar{b="2"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 52
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using `group_left(c, d)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 37
                end: 38
        d:
            reason: Query is using `group_left(c, d)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 39
                end: 40
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 16
                end: 24
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - c
            - d
          src:
            labels:
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 42
                        end: 52
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
            position:
                start: 42
                end: 52
            type: selector
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 0
        end: 10
      type: selector

---

[TestLabelsSource/137 - 1]
expr: foo{a="1"} * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 53
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 43
                end: 53
        c:
            reason: Query is using `group_right(c, d)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 38
                end: 39
        d:
            reason: Query is using `group_right(c, d)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 40
                end: 41
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 16
                end: 24
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{b="2"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - c
            - d
          src:
            labels:
                a:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 0
                        end: 10
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{a="1"}'
                  op: ""
            position:
                start: 0
                end: 10
            type: selector
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 43
        end: 53
      type: selector

---

[TestLabelsSource/138 - 1]
expr: foo{a="1"} * on(instance) sum(bar{b="2"})
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 25
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 41
        a:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 25
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 16
                end: 24
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 26
                        end: 29
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 26
                        end: 41
                b:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 26
                        end: 29
            deadInfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 26
                    end: 29
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar{b="2"})'
                  op: sum
            position:
                start: 30
                end: 40
            type: aggregation
            fixedLabels: true
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 0
        end: 10
      type: selector
      fixedLabels: true

---

[TestLabelsSource/139 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) sum(bar{b="2"})
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 57
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using `group_left(c, d)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 37
                end: 38
        d:
            reason: Query is using `group_left(c, d)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 39
                end: 40
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 16
                end: 24
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - c
            - d
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 45
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 57
                b:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 45
            deadInfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 42
                    end: 45
            deadLabels:
                - name: c
                  reason: You can't use `c` because this label is not possible here.
                  labelreason: Query is using aggregation that removes all labels.
                  usagefragment:
                    start: 37
                    end: 38
                  labelfragment:
                    start: 42
                    end: 45
                  kind: 0
                - name: d
                  reason: You can't use `d` because this label is not possible here.
                  labelreason: Query is using aggregation that removes all labels.
                  usagefragment:
                    start: 39
                    end: 40
                  labelfragment:
                    start: 42
                    end: 45
                  kind: 0
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar{b="2"})'
                  op: sum
            position:
                start: 46
                end: 56
            type: aggregation
            fixedLabels: true
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 0
        end: 10
      type: selector

---

[TestLabelsSource/140 - 1]
expr: sum(foo{a="1"}) * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 58
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 48
                end: 58
        c:
            reason: Query is using `group_right(c, d)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 43
                end: 44
        d:
            reason: Query is using `group_right(c, d)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 45
                end: 46
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 21
                end: 29
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{b="2"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - c
            - d
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 3
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 15
                a:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 3
            deadInfo:
                reason: The left hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 0
                    end: 3
            deadLabels:
                - name: c
                  reason: You can't use `c` because this label is not possible here.
                  labelreason: Query is using aggregation that removes all labels.
                  usagefragment:
                    start: 43
                    end: 44
                  labelfragment:
                    start: 0
                    end: 3
                  kind: 0
                - name: d
                  reason: You can't use `d` because this label is not possible here.
                  labelreason: Query is using aggregation that removes all labels.
                  usagefragment:
                    start: 45
                    end: 46
                  labelfragment:
                    start: 0
                    end: 3
                  kind: 0
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{a="1"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(foo{a="1"})'
                  op: sum
            position:
                start: 4
                end: 14
            type: aggregation
            fixedLabels: true
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 48
        end: 58
      type: selector

---

[TestLabelsSource/141 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) sum(bar{b="2"}) without(instance)
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 75
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using `group_left(c, d)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 37
                end: 38
        d:
            reason: Query is using `group_left(c, d)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 39
                end: 40
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 16
                end: 24
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - c
            - d
          src:
            labels:
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 75
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 46
                        end: 56
                instance:
                    reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                    kind: excluded
                    fragment:
                        start: 66
                        end: 74
            deadInfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                fragment:
                    start: 66
                    end: 74
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum without (instance) (bar{b="2"})'
                  op: sum
            position:
                start: 46
                end: 56
            type: aggregation
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 0
        end: 10
      type: selector

---

[TestLabelsSource/142 - 1]
expr: sum(foo{a="1"}) without(instance) * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 76
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 66
                end: 76
        c:
            reason: Query is using `group_right(c, d)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 61
                end: 62
        d:
            reason: Query is using `group_right(c, d)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 63
                end: 64
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 39
                end: 47
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{b="2"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - c
            - d
          src:
            labels:
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 33
                a:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 4
                        end: 14
                instance:
                    reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 32
            deadInfo:
                reason: The left hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                fragment:
                    start: 24
                    end: 32
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{a="1"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum without (instance) (foo{a="1"})'
                  op: sum
            position:
                start: 4
                end: 14
            type: aggregation
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 66
        end: 76
      type: selector

---

[TestLabelsSource/143 - 1]
expr: |4

     max without (source_instance) (
       increase(kernel_device_io_errors_total{device!~"loop.+"}[120m]) > 3 unless on(instance, device) (
         increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[125m])*2 > increase(kernel_device_io_errors_total[120m])
       )
       and on(device, instance) absent(node_disk_info)
     ) * on(instance) group_left(group) label_replace(salt_highstate_runner_configured_minions, "instance", "$1", "minion", "(.+)")
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 2
                end: 442
        device:
            reason: Query is using many-to-many vector matching with `on(device, instance)`, labels included inside `on(...)` will be present on the results if matched time series have them.
            kind: included
            fragment:
                start: 274
                end: 280
        group:
            reason: Query is using `group_left(group)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 344
                end: 349
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 323
                end: 331
        source_instance:
            reason: Query is using aggregation with `without(source_instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 15
                end: 30
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] kernel_device_io_errors_total{device!~"loop.+"}'
          op: ""
        - node: '[*parser.Call] increase(kernel_device_io_errors_total{device!~"loop.+"}[2h])'
          op: increase
        - node: '[*parser.AggregateExpr] max without (source_instance) (increase(kernel_device_io_errors_total{device!~"loop.+"}[2h]) > 3 unless on (instance, device) (increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[2h5m]) * 2 > increase(kernel_device_io_errors_total[2h])) and on (device, instance) absent(node_disk_info))'
          op: max
      joins:
        - matchinglabels:
            - device
            - instance
          addedlabels: []
          src:
            labels:
                "":
                    reason: |-
                        The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                        You will only get any results back if the metric selector you pass doesn't match anything.
                        Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                        This means that the only labels you can get back from absent call are the ones you pass to it.
                        If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
                    kind: excluded
                    fragment:
                        start: 292
                        end: 298
            deadInfo:
                reason: |-
                    The right hand side will never be matched because it doesn't have the `device` label from `on(...)`. The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                    You will only get any results back if the metric selector you pass doesn't match anything.
                    Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                    This means that the only labels you can get back from absent call are the ones you pass to it.
                    If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
                fragment:
                    start: 292
                    end: 298
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] node_disk_info'
                  op: ""
                - node: '[*parser.Call] absent(node_disk_info)'
                  op: absent
            position:
                start: 299
                end: 313
            type: function
            fixedLabels: true
          op: 57389
          depth: 1
          ison: true
        - matchinglabels:
            - instance
          addedlabels:
            - group
          src:
            labels:
                instance:
                    reason: This label will be added to the result by label_replace() call.
                    kind: guaranteed
                    fragment:
                        start: 351
                        end: 442
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] salt_highstate_runner_configured_minions'
                  op: ""
                - args:
                    - '"instance"'
                    - '"$1"'
                    - '"minion"'
                    - '"(.+)"'
                  node: '[*parser.Call] label_replace(salt_highstate_runner_configured_minions, "instance", "$1", "minion", "(.+)")'
                  op: label_replace
            usedLabels:
                - minion
            position:
                start: 365
                end: 405
            type: function
          op: 57395
          depth: 0
          ison: true
      unless:
        - matchinglabels:
            - instance
            - device
          src:
            labels:
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 140
                        end: 258
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] kernel_device_io_soft_errors_total{device!~"loop.+"}'
                  op: ""
                - node: '[*parser.Call] increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[2h5m])'
                  op: increase
            joins:
                - matchinglabels: []
                  addedlabels: []
                  src:
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] kernel_device_io_errors_total'
                          op: ""
                        - node: '[*parser.Call] increase(kernel_device_io_errors_total[2h])'
                          op: increase
                    position:
                        start: 222
                        end: 257
                    type: function
                  op: 57388
                  depth: 0
                  ison: false
            position:
                start: 149
                end: 207
            type: function
            isConditional: true
          ison: true
      usedLabels:
        - instance
        - device
      position:
        start: 46
        end: 99
      type: aggregation
      isConditional: true

---

[TestLabelsSource/144 - 1]
expr: sum(foo{a="1"}) by(job) * on() bar{b="2"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 26
                end: 30
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 41
        a:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 16
                end: 23
        job:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 26
                end: 30
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job) (foo{a="1"})'
          op: sum
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 31
                        end: 41
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
            position:
                start: 31
                end: 41
            type: selector
          op: 57395
          depth: 0
          ison: true
      position:
        start: 4
        end: 14
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/145 - 1]
expr: sum(sum(foo) without(job)) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 27
                end: 29
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 21
                end: 24
      deadLabels:
        - name: job
          reason: You can't use `job` because this label is not possible here.
          labelreason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
          usagefragment:
            start: 30
            end: 33
          labelfragment:
            start: 21
            end: 24
          kind: 0
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (job) (foo)'
          op: sum
        - node: '[*parser.AggregateExpr] sum by (job) (sum without (job) (foo))'
          op: sum
      usedLabels:
        - job
      position:
        start: 8
        end: 11
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/146 - 1]
expr: |4

    prometheus:scrape_series_added:since_gc:sum
    * on(prometheus) group_left()
    label_replace(
      max(max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])) by(instance)
      /
      max(max_over_time(prometheus_tsdb_head_series[2h])) by(instance),
      "prometheus", "$1",
      "instance", "(.+)"
    )
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 287
        prometheus:
            reason: Query is using many-to-one vector matching with `on(prometheus)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 50
                end: 60
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus:scrape_series_added:since_gc:sum'
          op: ""
      joins:
        - matchinglabels:
            - prometheus
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 158
                        end: 160
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 92
                        end: 241
                instance:
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 161
                        end: 169
                job:
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 158
                        end: 170
                prometheus:
                    reason: This label will be added to the result by label_replace() call.
                    kind: guaranteed
                    fragment:
                        start: 75
                        end: 287
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] go_memstats_alloc_bytes{job="prometheus"}'
                  op: ""
                - node: '[*parser.Call] max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])'
                  op: max_over_time
                - node: '[*parser.AggregateExpr] max by (instance) (max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h]))'
                  op: max
                - args:
                    - '"prometheus"'
                    - '"$1"'
                    - '"instance"'
                    - '"(.+)"'
                  node: '[*parser.Call] label_replace(max by (instance) (max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])) / max by (instance) (max_over_time(prometheus_tsdb_head_series[2h])), "prometheus", "$1", "instance", "(.+)")'
                  op: label_replace
            joins:
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 229
                                end: 231
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 177
                                end: 241
                        instance:
                            reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 232
                                end: 240
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] prometheus_tsdb_head_series'
                          op: ""
                        - node: '[*parser.Call] max_over_time(prometheus_tsdb_head_series[2h])'
                          op: max_over_time
                        - node: '[*parser.AggregateExpr] max by (instance) (max_over_time(prometheus_tsdb_head_series[2h]))'
                          op: max
                    usedLabels:
                        - instance
                    position:
                        start: 195
                        end: 226
                    type: aggregation
                    fixedLabels: true
                  op: 57384
                  depth: 0
                  ison: false
            usedLabels:
                - instance
            position:
                start: 92
                end: 241
            type: function
            fixedLabels: true
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - prometheus
      position:
        start: 1
        end: 44
      type: selector

---

[TestLabelsSource/147 - 1]
expr: (day_of_week() == 6 and hour() < 1) or vector(1)
output:
    - labels:
        "":
            reason: Calling `day_of_week()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 14
      returns: vector
      operations:
        - node: '[*parser.Call] day_of_week()'
          op: day_of_week
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `hour()` with no arguments will return an empty time series with no labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 30
            returns: vector
            operations:
                - node: '[*parser.Call] hour()'
                  op: hour
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: true
                knownreturn: false
                isreturnbool: false
            position:
                start: 24
                end: 30
            type: function
            fixedLabels: true
            isConditional: true
          op: 57389
          depth: 0
          ison: false
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 14
      type: function
      fixedLabels: true
      isConditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 39
                end: 45
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 39
            end: 48
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 39
        end: 48
      type: function
      fixedLabels: true

---

[TestLabelsSource/148 - 1]
expr: |4-

    sum by (foo, bar) (
        rate(errors_total[5m])
      * on (instance) group_left (bob, alice)
        server_errors_total
    )
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 115
        alice:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 18
        bar:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 14
                end: 17
        bob:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 18
        foo:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 9
                end: 12
        instance:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 18
      deadLabels:
        - name: bob
          reason: Previously joined label `bob` is being removed from the results.
          labelreason: Query is using `group_left(bob, alice)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 5
            end: 18
          labelfragment:
            start: 78
            end: 81
          kind: 3
        - name: alice
          reason: Previously joined label `alice` is being removed from the results.
          labelreason: Query is using `group_left(bob, alice)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 5
            end: 18
          labelfragment:
            start: 83
            end: 88
          kind: 3
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] errors_total'
          op: ""
        - node: '[*parser.Call] rate(errors_total[5m])'
          op: rate
        - node: '[*parser.AggregateExpr] sum by (foo, bar) (rate(errors_total[5m]) * on (instance) group_left (bob, alice) server_errors_total)'
          op: sum
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - bob
            - alice
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] server_errors_total'
                  op: ""
            position:
                start: 94
                end: 113
            type: selector
          op: 57395
          depth: 1
          ison: true
      usedLabels:
        - foo
        - bar
      position:
        start: 30
        end: 46
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/149 - 1]
expr: 1 - (foo or vector(0)) < 0.999
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 5
        end: 8
      type: selector
      isConditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 12
                end: 18
      deadInfo:
        reason: '`1 - vector(0) < 0.999` always evaluates to `1 < 0.999` which is not possible, so it will never return anything.'
        fragment:
            start: 12
            end: 21
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      returnInfo:
        logicalexpr: 1 - vector(0)
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: function
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/150 - 1]
expr: |4

    (
      vector(1) and month() == 2
    ) or vector(0)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 5
                end: 11
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `month()` with no arguments will return an empty time series with no labels.
                    kind: excluded
                    fragment:
                        start: 19
                        end: 26
            returns: vector
            operations:
                - node: '[*parser.Call] month()'
                  op: month
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: true
                knownreturn: false
                isreturnbool: false
            position:
                start: 19
                end: 26
            type: function
            fixedLabels: true
            isConditional: true
          op: 57389
          depth: 0
          ison: false
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 5
            end: 14
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 5
        end: 14
      type: function
      fixedLabels: true
      isConditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 37
                end: 43
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      returnInfo:
        logicalexpr: ""
        valueposition:
            start: 37
            end: 46
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 37
        end: 46
      type: function
      fixedLabels: true

---

[TestLabelsSource/151 - 1]
expr: count by (region) (stddev by (colo_name, region) (error_total))
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 9
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 63
        colo_name:
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 17
        region:
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 10
                end: 16
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] error_total'
          op: ""
        - node: '[*parser.AggregateExpr] stddev by (colo_name, region) (error_total)'
          op: stddev
        - node: '[*parser.AggregateExpr] count by (region) (stddev by (colo_name, region) (error_total))'
          op: count
      usedLabels:
        - region
      position:
        start: 50
        end: 61
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/152 - 1]
expr: |4

    (
      avg(
        rate(foo_rejections[6h])
        or
        vector(0)
      ) by (colo_name)
      /
      (
        avg(
          rate(foo_total[6h])
       or
       vector(1)
        ) by (colo_name)
      )
    ) > 5
    *
    (
      avg(
        rate(foo_rejections[6h] offset 1d)
     or
     vector(0)
      ) by (colo_name)
      /
      avg(
        rate(foo_total[6h] offset 1d)
     or
     vector(1)
      ) by (colo_name)
    ) and on (colo_name) (colo_job:foo_total:rate2m or vector(0)) > 80
      and on (colo_name) (colo_job:foo_total:rate2m offset 1d or vector(0)) > 80
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 64
                end: 67
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 336
        colo_name:
            reason: Query is using many-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results if matched time series have them.
            kind: included
            fragment:
                start: 412
                end: 421
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo_rejections'
          op: ""
        - node: '[*parser.Call] rate(foo_rejections[6h])'
          op: rate
        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h]) or vector(0))'
          op: avg
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 151
                        end: 160
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo_total'
                  op: ""
                - node: '[*parser.Call] rate(foo_total[6h])'
                  op: rate
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
                  op: avg
            usedLabels:
                - colo_name
            position:
                start: 107
                end: 120
            type: aggregation
            fixedLabels: true
          op: 57384
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 131
                        end: 137
            deadLabels:
                - name: colo_name
                  reason: You can't use `colo_name` because this label is not possible here.
                  labelreason: Calling `vector()` will return a vector value with no labels.
                  usagefragment:
                    start: 151
                    end: 160
                  labelfragment:
                    start: 131
                    end: 137
                  kind: 0
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
                  op: avg
            usedLabels:
                - colo_name
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 131
                    end: 140
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 131
                end: 140
            type: aggregation
            fixedLabels: true
          op: 57384
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 334
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 245
                        end: 254
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo_rejections offset 1d'
                  op: ""
                - node: '[*parser.Call] rate(foo_rejections[6h] offset 1d)'
                  op: rate
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
                  op: avg
            joins:
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 324
                                end: 333
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] foo_total offset 1d'
                          op: ""
                        - node: '[*parser.Call] rate(foo_total[6h] offset 1d)'
                          op: rate
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    usedLabels:
                        - colo_name
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedLabels: true
                  op: 57384
                  depth: 0
                  ison: false
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadLabels:
                        - name: colo_name
                          reason: You can't use `colo_name` because this label is not possible here.
                          labelreason: Calling `vector()` will return a vector value with no labels.
                          usagefragment:
                            start: 324
                            end: 333
                          labelfragment:
                            start: 306
                            end: 312
                          kind: 0
                    returns: vector
                    operations:
                        - args:
                            - "1"
                          node: '[*parser.Call] vector(1)'
                          op: vector
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    usedLabels:
                        - colo_name
                    returnInfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedLabels: true
                  op: 57384
                  depth: 0
                  ison: false
            usedLabels:
                - colo_name
            position:
                start: 192
                end: 220
            type: aggregation
            fixedLabels: true
          op: 57388
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 334
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 227
                        end: 233
            deadLabels:
                - name: colo_name
                  reason: You can't use `colo_name` because this label is not possible here.
                  labelreason: Calling `vector()` will return a vector value with no labels.
                  usagefragment:
                    start: 245
                    end: 254
                  labelfragment:
                    start: 227
                    end: 233
                  kind: 0
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
                  op: avg
            joins:
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 324
                                end: 333
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] foo_total offset 1d'
                          op: ""
                        - node: '[*parser.Call] rate(foo_total[6h] offset 1d)'
                          op: rate
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    usedLabels:
                        - colo_name
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedLabels: true
                  op: 57384
                  depth: 0
                  ison: false
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadLabels:
                        - name: colo_name
                          reason: You can't use `colo_name` because this label is not possible here.
                          labelreason: Calling `vector()` will return a vector value with no labels.
                          usagefragment:
                            start: 324
                            end: 333
                          labelfragment:
                            start: 306
                            end: 312
                          kind: 0
                    returns: vector
                    operations:
                        - args:
                            - "1"
                          node: '[*parser.Call] vector(1)'
                          op: vector
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    usedLabels:
                        - colo_name
                    returnInfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedLabels: true
                  op: 57384
                  depth: 0
                  ison: false
            usedLabels:
                - colo_name
            returnInfo:
                logicalexpr: 5 * vector(0) / vector(1)
                valueposition:
                    start: 170
                    end: 171
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 227
                end: 236
            type: aggregation
            fixedLabels: true
          op: 57388
          depth: 0
          ison: false
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_job:foo_total:rate2m'
                  op: ""
            position:
                start: 357
                end: 382
            type: selector
            isConditional: true
          op: 57389
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 386
                        end: 392
            deadInfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 386
                    end: 392
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 386
                    end: 395
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 386
                end: 395
            type: function
            fixedLabels: true
            isConditional: true
          op: 57389
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_job:foo_total:rate2m offset 1d'
                  op: ""
            position:
                start: 424
                end: 459
            type: selector
            isConditional: true
          op: 57389
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 463
                        end: 469
            deadInfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 463
                    end: 469
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 463
                    end: 472
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 463
                end: 472
            type: function
            fixedLabels: true
            isConditional: true
          op: 57389
          depth: 0
          ison: true
      usedLabels:
        - colo_name
      position:
        start: 19
        end: 37
      type: aggregation
      fixedLabels: true
      isConditional: true
    - labels:
        "":
            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 64
                end: 67
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 336
        colo_name:
            reason: Query is using many-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results if matched time series have them.
            kind: included
            fragment:
                start: 412
                end: 421
      deadInfo:
        reason: '`vector(0) / vector(1) > 5 * vector(0) / vector(1)` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 50
            end: 59
      deadLabels:
        - name: colo_name
          reason: You can't use `colo_name` because this label is not possible here.
          labelreason: Calling `vector()` will return a vector value with no labels.
          usagefragment:
            start: 68
            end: 77
          labelfragment:
            start: 50
            end: 56
          kind: 0
        - name: colo_name
          reason: You can't use `colo_name` because this label is not possible here.
          labelreason: Calling `vector()` will return a vector value with no labels.
          usagefragment:
            start: 345
            end: 354
          labelfragment:
            start: 50
            end: 56
          kind: 0
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h]) or vector(0))'
          op: avg
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 151
                        end: 160
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo_total'
                  op: ""
                - node: '[*parser.Call] rate(foo_total[6h])'
                  op: rate
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
                  op: avg
            usedLabels:
                - colo_name
            position:
                start: 107
                end: 120
            type: aggregation
            fixedLabels: true
          op: 57384
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 131
                        end: 137
            deadLabels:
                - name: colo_name
                  reason: You can't use `colo_name` because this label is not possible here.
                  labelreason: Calling `vector()` will return a vector value with no labels.
                  usagefragment:
                    start: 151
                    end: 160
                  labelfragment:
                    start: 131
                    end: 137
                  kind: 0
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
                  op: avg
            usedLabels:
                - colo_name
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 131
                    end: 140
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 131
                end: 140
            type: aggregation
            fixedLabels: true
          op: 57384
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 334
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 245
                        end: 254
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo_rejections offset 1d'
                  op: ""
                - node: '[*parser.Call] rate(foo_rejections[6h] offset 1d)'
                  op: rate
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
                  op: avg
            joins:
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 324
                                end: 333
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] foo_total offset 1d'
                          op: ""
                        - node: '[*parser.Call] rate(foo_total[6h] offset 1d)'
                          op: rate
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    usedLabels:
                        - colo_name
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedLabels: true
                  op: 57384
                  depth: 0
                  ison: false
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadLabels:
                        - name: colo_name
                          reason: You can't use `colo_name` because this label is not possible here.
                          labelreason: Calling `vector()` will return a vector value with no labels.
                          usagefragment:
                            start: 324
                            end: 333
                          labelfragment:
                            start: 306
                            end: 312
                          kind: 0
                    returns: vector
                    operations:
                        - args:
                            - "1"
                          node: '[*parser.Call] vector(1)'
                          op: vector
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    usedLabels:
                        - colo_name
                    returnInfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedLabels: true
                  op: 57384
                  depth: 0
                  ison: false
            usedLabels:
                - colo_name
            position:
                start: 192
                end: 220
            type: aggregation
            fixedLabels: true
          op: 57388
          depth: 0
          ison: false
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 334
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 227
                        end: 233
            deadLabels:
                - name: colo_name
                  reason: You can't use `colo_name` because this label is not possible here.
                  labelreason: Calling `vector()` will return a vector value with no labels.
                  usagefragment:
                    start: 245
                    end: 254
                  labelfragment:
                    start: 227
                    end: 233
                  kind: 0
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
                  op: avg
            joins:
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 324
                                end: 333
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] foo_total offset 1d'
                          op: ""
                        - node: '[*parser.Call] rate(foo_total[6h] offset 1d)'
                          op: rate
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    usedLabels:
                        - colo_name
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedLabels: true
                  op: 57384
                  depth: 0
                  ison: false
                - matchinglabels: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadLabels:
                        - name: colo_name
                          reason: You can't use `colo_name` because this label is not possible here.
                          labelreason: Calling `vector()` will return a vector value with no labels.
                          usagefragment:
                            start: 324
                            end: 333
                          labelfragment:
                            start: 306
                            end: 312
                          kind: 0
                    returns: vector
                    operations:
                        - args:
                            - "1"
                          node: '[*parser.Call] vector(1)'
                          op: vector
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    usedLabels:
                        - colo_name
                    returnInfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedLabels: true
                  op: 57384
                  depth: 0
                  ison: false
            usedLabels:
                - colo_name
            returnInfo:
                logicalexpr: 5 * vector(0) / vector(1)
                valueposition:
                    start: 170
                    end: 171
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 227
                end: 236
            type: aggregation
            fixedLabels: true
          op: 57388
          depth: 0
          ison: false
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_job:foo_total:rate2m'
                  op: ""
            position:
                start: 357
                end: 382
            type: selector
            isConditional: true
          op: 57389
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 386
                        end: 392
            deadInfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 386
                    end: 392
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 386
                    end: 395
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 386
                end: 395
            type: function
            fixedLabels: true
            isConditional: true
          op: 57389
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_job:foo_total:rate2m offset 1d'
                  op: ""
            position:
                start: 424
                end: 459
            type: selector
            isConditional: true
          op: 57389
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 463
                        end: 469
            deadInfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 463
                    end: 469
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            returnInfo:
                logicalexpr: ""
                valueposition:
                    start: 463
                    end: 472
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 463
                end: 472
            type: function
            fixedLabels: true
            isConditional: true
          op: 57389
          depth: 0
          ison: true
      usedLabels:
        - colo_name
      returnInfo:
        logicalexpr: vector(0) / vector(1)
        valueposition:
            start: 50
            end: 59
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 50
        end: 59
      type: aggregation
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/153 - 1]
expr: sum(selector) / sum(selector offset 30m) > 5
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 40
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] selector'
          op: ""
        - node: '[*parser.AggregateExpr] sum(selector)'
          op: sum
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 16
                        end: 19
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 16
                        end: 40
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] selector offset 30m'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(selector offset 30m)'
                  op: sum
            position:
                start: 20
                end: 39
            type: aggregation
            fixedLabels: true
          op: 57384
          depth: 0
          ison: false
      position:
        start: 4
        end: 12
      type: aggregation
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/154 - 1]
expr: |4-

    count by (dc) (
      max(0 < (token_expiration - time()) < (6*60*60)) by (instance)
      * on (instance) group_right label_replace(
        configured_minions, "instance", "$1", "minion", "(.+)")
      ) > 5
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(dc)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 10
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 190
        dc:
            reason: Query is using aggregation with `by(dc)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 13
        instance:
            reason: Query is using aggregation with `by(dc)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 14
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] configured_minions'
          op: ""
        - args:
            - '"instance"'
            - '"$1"'
            - '"minion"'
            - '"(.+)"'
          node: '[*parser.Call] label_replace(configured_minions, "instance", "$1", "minion", "(.+)")'
          op: label_replace
        - node: '[*parser.AggregateExpr] count by (dc) (max by (instance) (0 < (token_expiration - time()) < (6 * 60 * 60)) * on (instance) group_right () label_replace(configured_minions, "instance", "$1", "minion", "(.+)"))'
          op: count
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 68
                        end: 71
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 19
                        end: 81
                instance:
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 72
                        end: 80
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] token_expiration'
                  op: ""
                - node: '[*parser.AggregateExpr] max by (instance) (0 < (token_expiration - time()) < (6 * 60 * 60))'
                  op: max
            usedLabels:
                - instance
            position:
                start: 28
                end: 44
            type: aggregation
            fixedLabels: true
            isConditional: true
          op: 57395
          depth: 1
          ison: true
      usedLabels:
        - dc
      position:
        start: 131
        end: 149
      type: aggregation
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/155 - 1]
expr: topk(10, prometheus_build_info*prometheus_ready)
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 9
                end: 47
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_build_info'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, prometheus_build_info * prometheus_ready)'
          op: topk
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] prometheus_ready'
                  op: ""
            position:
                start: 31
                end: 47
            type: selector
          op: 57395
          depth: 1
          ison: false
      position:
        start: 9
        end: 30
      type: aggregation

---

[TestLabelsSource/156 - 1]
expr: bottomk(10, prometheus_build_info*prometheus_ready)
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 12
                end: 50
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_build_info'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] bottomk(10, prometheus_build_info * prometheus_ready)'
          op: bottomk
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] prometheus_ready'
                  op: ""
            position:
                start: 34
                end: 50
            type: selector
          op: 57395
          depth: 1
          ison: false
      position:
        start: 12
        end: 33
      type: aggregation

---

[TestLabelsSource/157 - 1]
expr: histogram_fraction(0, 0.1, metric)
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] metric'
          op: ""
        - args:
            - "0"
            - "0.1"
          node: '[*parser.Call] histogram_fraction(0, 0.1, metric)'
          op: histogram_fraction
      position:
        start: 27
        end: 33
      type: function

---

[TestLabelsSource/158 - 1]
expr: 'foo * foo '
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 9
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels: []
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo'
                  op: ""
            position:
                start: 6
                end: 9
            type: selector
          op: 57395
          depth: 0
          ison: false
      position:
        start: 0
        end: 3
      type: selector

---

[TestLabelsSource/159 - 1]
expr: 'foo + on(__name__, job) foo '
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(__name__, job)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 23
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 27
        job:
            reason: Query is using one-to-one vector matching with `on(__name__, job)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 19
                end: 22
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - __name__
            - job
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo'
                  op: ""
            position:
                start: 24
                end: 27
            type: selector
          op: 57383
          depth: 0
          ison: true
      usedLabels:
        - job
      position:
        start: 0
        end: 3
      type: selector
      fixedLabels: true

---

[TestLabelsSource/160 - 1]
expr: 'foo + on(__name__, job) group_left foo '
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 38
        job:
            reason: Query is using many-to-one vector matching with `on(__name__, job)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 19
                end: 22
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - __name__
            - job
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo'
                  op: ""
            position:
                start: 35
                end: 38
            type: selector
          op: 57383
          depth: 0
          ison: true
      usedLabels:
        - job
      position:
        start: 0
        end: 3
      type: selector

---

[TestLabelsSource/161 - 1]
expr: 'foo + on(__name__, job) group_right foo '
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 39
        job:
            reason: Query is using one-to-many vector matching with `on(__name__, job)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 19
                end: 22
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - __name__
            - job
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo'
                  op: ""
            position:
                start: 0
                end: 3
            type: selector
          op: 57383
          depth: 0
          ison: true
      usedLabels:
        - job
      position:
        start: 36
        end: 39
      type: selector

---

[TestLabelsSource/162 - 1]
expr: |-
    group by (env, cluster) (
          up{env="prod", job="foo"} and on (instance) (services_enabled == 999)
     )
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(env, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 9
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 104
        cluster:
            reason: Query is using aggregation with `by(env, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 15
                end: 22
        env:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 32
                end: 57
        instance:
            reason: Query is using aggregation with `by(env, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 23
        job:
            reason: Query is using aggregation with `by(env, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 23
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{env="prod",job="foo"}'
          op: ""
        - node: '[*parser.AggregateExpr] group by (env, cluster) (up{env="prod",job="foo"} and on (instance) (services_enabled == 999))'
          op: group
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] services_enabled'
                  op: ""
            position:
                start: 77
                end: 93
            type: selector
            isConditional: true
          op: 57389
          depth: 1
          ison: true
      usedLabels:
        - env
        - cluster
      position:
        start: 32
        end: 57
      type: aggregation
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/163 - 1]
expr: |-
    group by (env, cluster) (
          up{env="prod", job="foo"} * on (instance) (services_enabled == 999)
     )
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(env, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 9
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 102
        cluster:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 60
                end: 73
        env:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 60
                end: 73
        instance:
            reason: Query is using aggregation with `by(env, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 23
        job:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 60
                end: 73
      deadLabels:
        - name: env
          reason: You can't use `env` because this label is not possible here.
          labelreason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
          usagefragment:
            start: 10
            end: 13
          labelfragment:
            start: 60
            end: 73
          kind: 0
        - name: cluster
          reason: You can't use `cluster` because this label is not possible here.
          labelreason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
          usagefragment:
            start: 15
            end: 22
          labelfragment:
            start: 60
            end: 73
          kind: 0
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{env="prod",job="foo"}'
          op: ""
        - node: '[*parser.AggregateExpr] group by (env, cluster) (up{env="prod",job="foo"} * on (instance) (services_enabled == 999))'
          op: group
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] services_enabled'
                  op: ""
            position:
                start: 75
                end: 91
            type: selector
            isConditional: true
          op: 57395
          depth: 1
          ison: true
      usedLabels:
        - env
        - cluster
      position:
        start: 32
        end: 57
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/164 - 1]
expr: foo / on(instance) sum(bar)
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 18
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 27
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 9
                end: 17
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 19
                        end: 22
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 19
                        end: 27
            deadInfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 19
                    end: 22
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar)'
                  op: sum
            position:
                start: 23
                end: 26
            type: aggregation
            fixedLabels: true
          op: 57384
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 0
        end: 3
      type: selector
      fixedLabels: true

---

[TestLabelsSource/165 - 1]
expr: foo / on(instance) group_left(cluster) sum(bar)
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 47
        cluster:
            reason: Query is using `group_left(cluster)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 30
                end: 37
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 9
                end: 17
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - cluster
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 39
                        end: 42
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 39
                        end: 47
            deadInfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 39
                    end: 42
            deadLabels:
                - name: cluster
                  reason: You can't use `cluster` because this label is not possible here.
                  labelreason: Query is using aggregation that removes all labels.
                  usagefragment:
                    start: 30
                    end: 37
                  labelfragment:
                    start: 39
                    end: 42
                  kind: 0
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar)'
                  op: sum
            position:
                start: 43
                end: 46
            type: aggregation
            fixedLabels: true
          op: 57384
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 0
        end: 3
      type: selector

---

[TestLabelsSource/166 - 1]
expr: sum(bar) / on(instance) group_right(cluster) foo
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 48
        cluster:
            reason: Query is using `group_right(cluster)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 36
                end: 43
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 14
                end: 22
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - cluster
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 3
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 8
            deadInfo:
                reason: The left hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 0
                    end: 3
            deadLabels:
                - name: cluster
                  reason: You can't use `cluster` because this label is not possible here.
                  labelreason: Query is using aggregation that removes all labels.
                  usagefragment:
                    start: 36
                    end: 43
                  labelfragment:
                    start: 0
                    end: 3
                  kind: 0
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar)'
                  op: sum
            position:
                start: 4
                end: 7
            type: aggregation
            fixedLabels: true
          op: 57384
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 45
        end: 48
      type: selector

---

[TestLabelsSource/167 - 1]
expr: sum(bar) * on(cluster) sum(foo)
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(cluster)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 11
                end: 22
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 31
        cluster:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      deadLabels:
        - name: cluster
          reason: You can't use `cluster` because this label is not possible here.
          labelreason: Query is using aggregation that removes all labels.
          usagefragment:
            start: 14
            end: 21
          labelfragment:
            start: 0
            end: 3
          kind: 0
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
        - node: '[*parser.AggregateExpr] sum(bar)'
          op: sum
      joins:
        - matchinglabels:
            - cluster
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 23
                        end: 26
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 23
                        end: 31
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(foo)'
                  op: sum
            position:
                start: 27
                end: 30
            type: aggregation
            fixedLabels: true
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - cluster
      position:
        start: 4
        end: 7
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/168 - 1]
expr: |4-

    group by (colo_name, instance, tier, animal, brand, sliver, pop_name) (
      up{node_status="v", job="node_exporter"}
      and on (instance) (metal_services_enabled == 999)
      * on (colo_name) group_left(tier, animal, brand, pop_name) colo_metadata{colo_status="v"}
      * on (instance) group_left (sliver) sliver_metadata{node_status="v"}
    )
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 10
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 332
        animal:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 38
                end: 44
        brand:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 46
                end: 51
        colo_name:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 20
        instance:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 22
                end: 30
        job:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 70
        node_status:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 70
        pop_name:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 61
                end: 69
        sliver:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 53
                end: 59
        tier:
            reason: Query is using aggregation with `by(colo_name, instance, tier, animal, brand, sliver, pop_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 32
                end: 36
      deadLabels:
        - name: tier
          reason: This binary operation prevents previously joined label `tier` from being added to the results.
          labelreason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 118
            end: 121
          labelfragment:
            start: 198
            end: 202
          kind: 1
        - name: animal
          reason: This binary operation prevents previously joined label `animal` from being added to the results.
          labelreason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 118
            end: 121
          labelfragment:
            start: 204
            end: 210
          kind: 1
        - name: brand
          reason: This binary operation prevents previously joined label `brand` from being added to the results.
          labelreason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 118
            end: 121
          labelfragment:
            start: 212
            end: 217
          kind: 1
        - name: pop_name
          reason: This binary operation prevents previously joined label `pop_name` from being added to the results.
          labelreason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 118
            end: 121
          labelfragment:
            start: 219
            end: 227
          kind: 1
        - name: sliver
          reason: This binary operation prevents previously joined label `sliver` from being added to the results.
          labelreason: Query is using `group_left(sliver)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 118
            end: 121
          labelfragment:
            start: 290
            end: 296
          kind: 1
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="node_exporter",node_status="v"}'
          op: ""
        - node: '[*parser.AggregateExpr] group by (colo_name, instance, tier, animal, brand, sliver, pop_name) (up{job="node_exporter",node_status="v"} and on (instance) (metal_services_enabled == 999) * on (colo_name) group_left (tier, animal, brand, pop_name) colo_metadata{colo_status="v"} * on (instance) group_left (sliver) sliver_metadata{node_status="v"})'
          op: group
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels:
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 136
                        end: 330
                animal:
                    reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 204
                        end: 210
                brand:
                    reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 212
                        end: 217
                colo_name:
                    reason: Query is using many-to-one vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 176
                        end: 185
                instance:
                    reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 268
                        end: 276
                pop_name:
                    reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 219
                        end: 227
                sliver:
                    reason: Query is using `group_left(sliver)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 290
                        end: 296
                tier:
                    reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 198
                        end: 202
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metal_services_enabled'
                  op: ""
            joins:
                - matchinglabels:
                    - colo_name
                  addedlabels:
                    - tier
                    - animal
                    - brand
                    - pop_name
                  src:
                    labels:
                        colo_status:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 229
                                end: 259
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] colo_metadata{colo_status="v"}'
                          op: ""
                    position:
                        start: 229
                        end: 259
                    type: selector
                  op: 57395
                  depth: 0
                  ison: true
                - matchinglabels:
                    - instance
                  addedlabels:
                    - sliver
                  src:
                    labels:
                        node_status:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 298
                                end: 330
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] sliver_metadata{node_status="v"}'
                          op: ""
                    position:
                        start: 298
                        end: 330
                    type: selector
                  op: 57395
                  depth: 0
                  ison: true
            usedLabels:
                - colo_name
                - instance
            position:
                start: 137
                end: 159
            type: selector
            isConditional: true
          op: 57389
          depth: 1
          ison: true
      usedLabels:
        - instance
        - colo_name
        - tier
        - animal
        - brand
        - sliver
        - pop_name
      position:
        start: 75
        end: 115
      type: aggregation
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/169 - 1]
expr: |4

    up{node_status="v", job="node_exporter"}
    * on (colo_name) group_left(tier) colo_metadata{colo_status="v"}
    * on (instance) group_left (sliver) sliver_metadata{node_status="v"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 175
        colo_name:
            reason: Query is using many-to-one vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 48
                end: 57
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 113
                end: 121
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 1
                end: 41
        node_status:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 1
                end: 41
        sliver:
            reason: Query is using `group_left(sliver)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 135
                end: 141
        tier:
            reason: Query is using `group_left(tier)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 70
                end: 74
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="node_exporter",node_status="v"}'
          op: ""
      joins:
        - matchinglabels:
            - colo_name
          addedlabels:
            - tier
          src:
            labels:
                colo_status:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 76
                        end: 106
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_metadata{colo_status="v"}'
                  op: ""
            position:
                start: 76
                end: 106
            type: selector
          op: 57395
          depth: 0
          ison: true
        - matchinglabels:
            - instance
          addedlabels:
            - sliver
          src:
            labels:
                node_status:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 143
                        end: 175
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] sliver_metadata{node_status="v"}'
                  op: ""
            position:
                start: 143
                end: 175
            type: selector
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - colo_name
        - instance
      position:
        start: 1
        end: 41
      type: selector

---

[TestLabelsSource/170 - 1]
expr: |4

    up{node_status="v", job="node_exporter"}
    and on (colo_name) colo_metadata{colo_status="v"}
    * on (instance) group_left (sliver) sliver_metadata{node_status="v"}
output:
    - labels:
        colo_name:
            reason: Query is using many-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results if matched time series have them.
            kind: included
            fragment:
                start: 50
                end: 59
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 1
                end: 41
        node_status:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 1
                end: 41
      deadLabels:
        - name: sliver
          reason: This binary operation prevents previously joined label `sliver` from being added to the results.
          labelreason: Query is using `group_left(sliver)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
          usagefragment:
            start: 42
            end: 45
          labelfragment:
            start: 120
            end: 126
          kind: 1
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="node_exporter",node_status="v"}'
          op: ""
      joins:
        - matchinglabels:
            - colo_name
          addedlabels: []
          src:
            labels:
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 61
                        end: 160
                colo_status:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 61
                        end: 91
                instance:
                    reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 98
                        end: 106
                sliver:
                    reason: Query is using `group_left(sliver)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 120
                        end: 126
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_metadata{colo_status="v"}'
                  op: ""
            joins:
                - matchinglabels:
                    - instance
                  addedlabels:
                    - sliver
                  src:
                    labels:
                        node_status:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 128
                                end: 160
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] sliver_metadata{node_status="v"}'
                          op: ""
                    position:
                        start: 128
                        end: 160
                    type: selector
                  op: 57395
                  depth: 0
                  ison: true
            usedLabels:
                - instance
            position:
                start: 61
                end: 91
            type: selector
          op: 57389
          depth: 0
          ison: true
      usedLabels:
        - colo_name
      position:
        start: 1
        end: 41
      type: selector

---

[TestLabelsSource/171 - 1]
expr: |4

    colo_metadata{colo_status="v"} * on (colo_name) group_right(tier, animal, brand, pop_name)
    sliver_metadata{node_status="v"} * on (instance) group_right (sliver)
    (metal_services_enabled == 999) * on (instance)
    up{node_status="v", job="node_exporter"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 1
                end: 250
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 250
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 200
                end: 208
        sliver:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 1
                end: 250
      deadLabels:
        - name: tier
          reason: This binary operation prevents previously joined label `tier` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 125
            end: 126
          labelfragment:
            start: 125
            end: 126
          kind: 1
        - name: animal
          reason: This binary operation prevents previously joined label `animal` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 125
            end: 126
          labelfragment:
            start: 125
            end: 126
          kind: 1
        - name: brand
          reason: This binary operation prevents previously joined label `brand` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 125
            end: 126
          labelfragment:
            start: 125
            end: 126
          kind: 1
        - name: pop_name
          reason: This binary operation prevents previously joined label `pop_name` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 125
            end: 126
          labelfragment:
            start: 125
            end: 126
          kind: 1
        - name: sliver
          reason: This binary operation prevents previously joined label `sliver` from being added to the results.
          labelreason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
          usagefragment:
            start: 194
            end: 195
          labelfragment:
            start: 1
            end: 250
          kind: 1
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] metal_services_enabled'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - sliver
          src:
            labels:
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 1
                        end: 124
                animal:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 67
                        end: 73
                brand:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 75
                        end: 80
                colo_name:
                    reason: Query is using one-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 38
                        end: 47
                node_status:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 92
                        end: 124
                pop_name:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 82
                        end: 90
                tier:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 61
                        end: 65
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] sliver_metadata{node_status="v"}'
                  op: ""
            joins:
                - matchinglabels:
                    - colo_name
                  addedlabels:
                    - tier
                    - animal
                    - brand
                    - pop_name
                  src:
                    labels:
                        colo_status:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 1
                                end: 31
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] colo_metadata{colo_status="v"}'
                          op: ""
                    position:
                        start: 1
                        end: 31
                    type: selector
                  op: 57395
                  depth: 0
                  ison: true
            usedLabels:
                - colo_name
            position:
                start: 92
                end: 124
            type: selector
          op: 57395
          depth: 0
          ison: true
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels:
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 210
                        end: 250
                node_status:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 210
                        end: 250
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] up{job="node_exporter",node_status="v"}'
                  op: ""
            position:
                start: 210
                end: 250
            type: selector
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 163
        end: 185
      type: selector
      fixedLabels: true
      isConditional: true

---

[TestLabelsSource/172 - 1]
expr: |4

    colo_metadata{colo_status="v"} * on (colo_name) group_right(tier, animal, brand, pop_name)
    sliver_metadata{node_status="v"} * on (instance) group_right (sliver)
    (metal_services_enabled == 999) * on (instance) group_right()
    up{node_status="v", job="node_exporter"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 264
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 200
                end: 208
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 224
                end: 264
        node_status:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 224
                end: 264
      deadLabels:
        - name: sliver
          reason: This binary operation prevents previously joined label `sliver` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 194
            end: 195
          labelfragment:
            start: 194
            end: 195
          kind: 1
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="node_exporter",node_status="v"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels: []
          src:
            labels:
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 1
                        end: 193
                instance:
                    reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 131
                        end: 139
                sliver:
                    reason: Query is using `group_right(sliver)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 154
                        end: 160
            deadLabels:
                - name: tier
                  reason: This binary operation prevents previously joined label `tier` from being added to the results.
                  labelreason: ""
                  usagefragment:
                    start: 125
                    end: 126
                  labelfragment:
                    start: 125
                    end: 126
                  kind: 1
                - name: animal
                  reason: This binary operation prevents previously joined label `animal` from being added to the results.
                  labelreason: ""
                  usagefragment:
                    start: 125
                    end: 126
                  labelfragment:
                    start: 125
                    end: 126
                  kind: 1
                - name: brand
                  reason: This binary operation prevents previously joined label `brand` from being added to the results.
                  labelreason: ""
                  usagefragment:
                    start: 125
                    end: 126
                  labelfragment:
                    start: 125
                    end: 126
                  kind: 1
                - name: pop_name
                  reason: This binary operation prevents previously joined label `pop_name` from being added to the results.
                  labelreason: ""
                  usagefragment:
                    start: 125
                    end: 126
                  labelfragment:
                    start: 125
                    end: 126
                  kind: 1
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metal_services_enabled'
                  op: ""
            joins:
                - matchinglabels:
                    - instance
                  addedlabels:
                    - sliver
                  src:
                    labels:
                        __name__:
                            reason: Binary operation between two vectors removes metric names.
                            kind: excluded
                            fragment:
                                start: 1
                                end: 124
                        animal:
                            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                            kind: included
                            fragment:
                                start: 67
                                end: 73
                        brand:
                            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                            kind: included
                            fragment:
                                start: 75
                                end: 80
                        colo_name:
                            reason: Query is using one-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 38
                                end: 47
                        node_status:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 92
                                end: 124
                        pop_name:
                            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                            kind: included
                            fragment:
                                start: 82
                                end: 90
                        tier:
                            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                            kind: included
                            fragment:
                                start: 61
                                end: 65
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] sliver_metadata{node_status="v"}'
                          op: ""
                    joins:
                        - matchinglabels:
                            - colo_name
                          addedlabels:
                            - tier
                            - animal
                            - brand
                            - pop_name
                          src:
                            labels:
                                colo_status:
                                    reason: Query will only return series where these labels are present.
                                    kind: guaranteed
                                    fragment:
                                        start: 1
                                        end: 31
                            returns: vector
                            operations:
                                - node: '[*parser.VectorSelector] colo_metadata{colo_status="v"}'
                                  op: ""
                            position:
                                start: 1
                                end: 31
                            type: selector
                          op: 57395
                          depth: 0
                          ison: true
                    usedLabels:
                        - colo_name
                    position:
                        start: 92
                        end: 124
                    type: selector
                  op: 57395
                  depth: 0
                  ison: true
            usedLabels:
                - instance
            position:
                start: 163
                end: 185
            type: selector
            isConditional: true
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 224
        end: 264
      type: selector

---

[TestLabelsSource/173 - 1]
expr: |4

    sliver_metadata{node_status="v"} * on (instance) group_right (sliver)
    (metal_services_enabled == 999) * on (colo_name) group_left(tier, animal, brand, pop_name)
    colo_metadata{colo_status="v"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 192
        animal:
            reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 137
                end: 143
        brand:
            reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 145
                end: 150
        colo_name:
            reason: Query is using many-to-one vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 109
                end: 118
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 40
                end: 48
        pop_name:
            reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 152
                end: 160
        sliver:
            reason: Query is using `group_right(sliver)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 63
                end: 69
        tier:
            reason: Query is using `group_left(tier, animal, brand, pop_name)`, all labels included inside `group_left(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 131
                end: 135
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] metal_services_enabled'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - sliver
          src:
            labels:
                node_status:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 1
                        end: 33
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] sliver_metadata{node_status="v"}'
                  op: ""
            position:
                start: 1
                end: 33
            type: selector
          op: 57395
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels:
            - tier
            - animal
            - brand
            - pop_name
          src:
            labels:
                colo_status:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 162
                        end: 192
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_metadata{colo_status="v"}'
                  op: ""
            position:
                start: 162
                end: 192
            type: selector
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
        - colo_name
      position:
        start: 72
        end: 94
      type: selector
      isConditional: true

---

[TestLabelsSource/174 - 1]
expr: |4

    colo_metadata * on (colo_name) group_right(tier, animal, brand, pop_name)
    sliver_metadata * on (instance) group_right (sliver)
    metal_services_enabled
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 150
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 97
                end: 105
        sliver:
            reason: Query is using `group_right(sliver)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 120
                end: 126
      deadLabels:
        - name: tier
          reason: This binary operation prevents previously joined label `tier` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 91
            end: 92
          labelfragment:
            start: 91
            end: 92
          kind: 1
        - name: animal
          reason: This binary operation prevents previously joined label `animal` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 91
            end: 92
          labelfragment:
            start: 91
            end: 92
          kind: 1
        - name: brand
          reason: This binary operation prevents previously joined label `brand` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 91
            end: 92
          labelfragment:
            start: 91
            end: 92
          kind: 1
        - name: pop_name
          reason: This binary operation prevents previously joined label `pop_name` from being added to the results.
          labelreason: ""
          usagefragment:
            start: 91
            end: 92
          labelfragment:
            start: 91
            end: 92
          kind: 1
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] metal_services_enabled'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - sliver
          src:
            labels:
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 1
                        end: 90
                animal:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 50
                        end: 56
                brand:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 58
                        end: 63
                colo_name:
                    reason: Query is using one-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 21
                        end: 30
                pop_name:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 65
                        end: 73
                tier:
                    reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
                    kind: included
                    fragment:
                        start: 44
                        end: 48
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] sliver_metadata'
                  op: ""
            joins:
                - matchinglabels:
                    - colo_name
                  addedlabels:
                    - tier
                    - animal
                    - brand
                    - pop_name
                  src:
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] colo_metadata'
                          op: ""
                    position:
                        start: 1
                        end: 14
                    type: selector
                  op: 57395
                  depth: 0
                  ison: true
            usedLabels:
                - colo_name
            position:
                start: 75
                end: 90
            type: selector
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 128
        end: 150
      type: selector

---

[TestLabelsSource/175 - 1]
expr: |4

    colo_metadata * on (colo_name) group_right(tier, animal, brand, pop_name)
    (
        sliver_metadata * on (instance) group_right (sliver)
        metal_services_enabled
    )
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 162
        animal:
            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 50
                end: 56
        brand:
            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 58
                end: 63
        colo_name:
            reason: Query is using one-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 21
                end: 30
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 103
                end: 111
        pop_name:
            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 65
                end: 73
        sliver:
            reason: Query is using `group_right(sliver)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 126
                end: 132
        tier:
            reason: Query is using `group_right(tier, animal, brand, pop_name)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 44
                end: 48
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] metal_services_enabled'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - sliver
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] sliver_metadata'
                  op: ""
            position:
                start: 81
                end: 96
            type: selector
          op: 57395
          depth: 0
          ison: true
        - matchinglabels:
            - colo_name
          addedlabels:
            - tier
            - animal
            - brand
            - pop_name
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_metadata'
                  op: ""
            position:
                start: 1
                end: 14
            type: selector
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
        - colo_name
      position:
        start: 138
        end: 160
      type: selector

---

[TestLabelsSource/176 - 1]
expr: |4

    up{node_status="v", job="node_exporter"}
    * on(instance) group_left(node_status) sliver_metadata
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 96
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 47
                end: 55
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 1
                end: 41
        node_status:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 1
                end: 41
      deadLabels:
        - name: node_status
          reason: Query is trying to join the `node_status` label that is already present on the other side of the query.
          labelreason: Query will only return series where these labels are present.
          usagefragment:
            start: 68
            end: 79
          labelfragment:
            start: 1
            end: 41
          kind: 2
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="node_exporter",node_status="v"}'
          op: ""
      joins:
        - matchinglabels:
            - instance
          addedlabels:
            - node_status
          src:
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] sliver_metadata'
                  op: ""
            position:
                start: 81
                end: 96
            type: selector
          op: 57395
          depth: 0
          ison: true
      usedLabels:
        - instance
      position:
        start: 1
        end: 41
      type: selector

---

[TestLabelsSource/177 - 1]
expr: services_enabled{job=""}
output:
    - labels:
        job:
            reason: Query uses `{job=""}` selector which will filter out any time series with the `job` label set.
            kind: excluded
            fragment:
                start: 0
                end: 24
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] services_enabled{job=""}'
          op: ""
      position:
        start: 0
        end: 24
      type: selector

---

[TestLabelsSource/178 - 1]
expr: |4

    group by (cluster, namespace, workload, workload_type, pod) (
      label_join(
        label_join(
          group by (cluster, namespace, job_name, pod) (
            label_join(
              kube_pod_owner{job="kube-state-metrics", owner_kind="Job"}
            , "job_name", "", "owner_name")
          )
          * on (cluster, namespace, job_name) group_left(owner_kind, owner_name)
          group by (cluster, namespace, job_name, owner_kind, owner_name) (
            kube_job_owner{job="kube-state-metrics", owner_kind!="Pod", owner_kind!=""}
          )
        , "workload", "", "owner_name")
      , "workload_type", "", "owner_kind")
    )
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(cluster, namespace, workload, workload_type, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 10
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 600
        cluster:
            reason: Query is using aggregation with `by(cluster, namespace, workload, workload_type, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 18
        job:
            reason: Query is using aggregation with `by(cluster, namespace, job_name, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 105
                end: 143
        job_name:
            reason: Query is using aggregation with `by(cluster, namespace, workload, workload_type, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 60
        namespace:
            reason: Query is using aggregation with `by(cluster, namespace, workload, workload_type, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 20
                end: 29
        owner_kind:
            reason: Query is using aggregation with `by(cluster, namespace, workload, workload_type, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 60
        owner_name:
            reason: Query is using aggregation with `by(cluster, namespace, workload, workload_type, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 60
        pod:
            reason: Query is using aggregation with `by(cluster, namespace, workload, workload_type, pod)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 56
                end: 59
        workload:
            reason: This label will be added to the result by label_join() call.
            kind: guaranteed
            fragment:
                start: 81
                end: 559
        workload_type:
            reason: This label will be added to the result by label_join() call.
            kind: guaranteed
            fragment:
                start: 65
                end: 598
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] kube_pod_owner{job="kube-state-metrics",owner_kind="Job"}'
          op: ""
        - args:
            - '"job_name"'
            - '""'
            - '"owner_name"'
          node: '[*parser.Call] label_join(kube_pod_owner{job="kube-state-metrics",owner_kind="Job"}, "job_name", "", "owner_name")'
          op: label_join
        - node: '[*parser.AggregateExpr] group by (cluster, namespace, job_name, pod) (label_join(kube_pod_owner{job="kube-state-metrics",owner_kind="Job"}, "job_name", "", "owner_name"))'
          op: group
        - args:
            - '"workload"'
            - '""'
            - '"owner_name"'
          node: '[*parser.Call] label_join(group by (cluster, namespace, job_name, pod) (label_join(kube_pod_owner{job="kube-state-metrics",owner_kind="Job"}, "job_name", "", "owner_name")) * on (cluster, namespace, job_name) group_left (owner_kind, owner_name) group by (cluster, namespace, job_name, owner_kind, owner_name) (kube_job_owner{job="kube-state-metrics",owner_kind!="",owner_kind!="Pod"}), "workload", "", "owner_name")'
          op: label_join
        - args:
            - '"workload_type"'
            - '""'
            - '"owner_kind"'
          node: '[*parser.Call] label_join(label_join(group by (cluster, namespace, job_name, pod) (label_join(kube_pod_owner{job="kube-state-metrics",owner_kind="Job"}, "job_name", "", "owner_name")) * on (cluster, namespace, job_name) group_left (owner_kind, owner_name) group by (cluster, namespace, job_name, owner_kind, owner_name) (kube_job_owner{job="kube-state-metrics",owner_kind!="",owner_kind!="Pod"}), "workload", "", "owner_name"), "workload_type", "", "owner_kind")'
          op: label_join
        - node: '[*parser.AggregateExpr] group by (cluster, namespace, workload, workload_type, pod) (label_join(label_join(group by (cluster, namespace, job_name, pod) (label_join(kube_pod_owner{job="kube-state-metrics",owner_kind="Job"}, "job_name", "", "owner_name")) * on (cluster, namespace, job_name) group_left (owner_kind, owner_name) group by (cluster, namespace, job_name, owner_kind, owner_name) (kube_job_owner{job="kube-state-metrics",owner_kind!="",owner_kind!="Pod"}), "workload", "", "owner_name"), "workload_type", "", "owner_kind"))'
          op: group
      joins:
        - matchinglabels:
            - cluster
            - namespace
            - job_name
          addedlabels:
            - owner_kind
            - owner_name
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(cluster, namespace, job_name, owner_kind, owner_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 372
                        end: 375
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 366
                        end: 523
                cluster:
                    reason: Query is using aggregation with `by(cluster, namespace, job_name, owner_kind, owner_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 376
                        end: 383
                job:
                    reason: Query is using aggregation with `by(cluster, namespace, job_name, owner_kind, owner_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 372
                        end: 429
                job_name:
                    reason: Query is using aggregation with `by(cluster, namespace, job_name, owner_kind, owner_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 396
                        end: 404
                namespace:
                    reason: Query is using aggregation with `by(cluster, namespace, job_name, owner_kind, owner_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 385
                        end: 394
                owner_kind:
                    reason: Query is using aggregation with `by(cluster, namespace, job_name, owner_kind, owner_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 406
                        end: 416
                owner_name:
                    reason: Query is using aggregation with `by(cluster, namespace, job_name, owner_kind, owner_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 418
                        end: 428
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] kube_job_owner{job="kube-state-metrics",owner_kind!="",owner_kind!="Pod"}'
                  op: ""
                - node: '[*parser.AggregateExpr] group by (cluster, namespace, job_name, owner_kind, owner_name) (kube_job_owner{job="kube-state-metrics",owner_kind!="",owner_kind!="Pod"})'
                  op: group
            usedLabels:
                - cluster
                - namespace
                - job_name
                - owner_kind
                - owner_name
            position:
                start: 440
                end: 515
            type: aggregation
            fixedLabels: true
          op: 57395
          depth: 1
          ison: true
      usedLabels:
        - cluster
        - namespace
        - pod
        - workload
        - workload_type
      position:
        start: 81
        end: 559
      type: aggregation
      fixedLabels: true

---

[TestLabelsSource/179 - 1]
expr: foo{job="xxx"} + on(job) group_right(instance) bar{}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 52
        instance:
            reason: Query is using `group_right(instance)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 37
                end: 45
        job:
            reason: Query is using one-to-many vector matching with `on(job)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 20
                end: 23
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      joins:
        - matchinglabels:
            - job
          addedlabels:
            - instance
          src:
            labels:
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 0
                        end: 14
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{job="xxx"}'
                  op: ""
            position:
                start: 0
                end: 14
            type: selector
          op: 57383
          depth: 0
          ison: true
      usedLabels:
        - job
      position:
        start: 47
        end: 52
      type: selector

---

[TestLabelsSource/180 - 1]
expr: foo{job="xxx"} + ignoring(job) group_right(instance) bar{job="zzz"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 67
        instance:
            reason: Query is using `group_right(instance)`, all labels included inside `group_right(...)` will be joined to the results on the other side of the query.
            kind: included
            fragment:
                start: 43
                end: 51
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 53
                end: 67
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{job="zzz"}'
          op: ""
      joins:
        - matchinglabels:
            - job
          addedlabels:
            - instance
          src:
            labels:
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 0
                        end: 14
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{job="xxx"}'
                  op: ""
            position:
                start: 0
                end: 14
            type: selector
          op: 57383
          depth: 0
          ison: false
      usedLabels:
        - instance
      position:
        start: 53
        end: 67
      type: selector

---

[TestLabelsSource/181 - 1]
expr: foo or ignoring(job) bar
output:
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      position:
        start: 0
        end: 3
      type: selector
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      position:
        start: 21
        end: 24
      type: selector

---

[TestLabelsSource/182 - 1]
expr: foo or on(job) bar
output:
    - labels:
        job:
            reason: Query is using many-to-many vector matching with `on(job)`, labels included inside `on(...)` will be present on the results if matched time series have them.
            kind: included
            fragment:
                start: 10
                end: 13
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      usedLabels:
        - job
      position:
        start: 0
        end: 3
      type: selector
    - returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      position:
        start: 15
        end: 18
      type: selector

---
