
[TestLabelsSource/1 - 1]
expr: "1"
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 1
      returnednumber: 1
      type: 1
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/2 - 1]
expr: 1 / 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 1
      returnednumber: 0.2
      type: 1
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/3 - 1]
expr: (2 ^ 5) == bool 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      deadinfo:
        reason: this query always evaluates to `32 == 5` which is not possible, so it will never return anything
        fragment:
            start: 1
            end: 2
      position:
        start: 1
        end: 2
      returnednumber: 32
      type: 1
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: true

---

[TestLabelsSource/4 - 1]
expr: (2 ^ 5 + 11) % 5 <= bool 2
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      deadinfo:
        reason: this query always evaluates to `3 <= 2` which is not possible, so it will never return anything
        fragment:
            start: 1
            end: 2
      position:
        start: 1
        end: 2
      returnednumber: 3
      type: 1
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: true

---

[TestLabelsSource/5 - 1]
expr: (2 ^ 5 + 11) % 5 >= bool 20
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      deadinfo:
        reason: this query always evaluates to `3 >= 20` which is not possible, so it will never return anything
        fragment:
            start: 1
            end: 2
      position:
        start: 1
        end: 2
      returnednumber: 3
      type: 1
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: true

---

[TestLabelsSource/6 - 1]
expr: (2 ^ 5 + 11) % 5 <= bool 3
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 1
        end: 2
      returnednumber: 3
      type: 1
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: true

---

[TestLabelsSource/7 - 1]
expr: (2 ^ 5 + 11) % 5 < bool 1
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      deadinfo:
        reason: this query always evaluates to `3 < 1` which is not possible, so it will never return anything
        fragment:
            start: 1
            end: 2
      position:
        start: 1
        end: 2
      returnednumber: 3
      type: 1
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: true

---

[TestLabelsSource/8 - 1]
expr: 20 - 15 < bool 1
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 2
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      deadinfo:
        reason: this query always evaluates to `5 < 1` which is not possible, so it will never return anything
        fragment:
            start: 0
            end: 2
      position:
        start: 0
        end: 2
      returnednumber: 5
      type: 1
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: true

---

[TestLabelsSource/9 - 1]
expr: 2 * 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 1
      returnednumber: 10
      type: 1
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/10 - 1]
expr: (foo or bar) * 5
output:
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 1
        end: 4
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 8
        end: 11
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/11 - 1]
expr: (foo or vector(2)) * 5
output:
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 1
        end: 4
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 8
                end: 14
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(2)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 8
        end: 17
      returnednumber: 10
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/12 - 1]
expr: (foo or vector(5)) * (vector(2) or bar)
output:
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - labels:
            "":
                reason: Calling `vector()` will return a vector value with no labels.
                kind: excluded
                fragment:
                    start: 22
                    end: 28
          operation: vector
          returns: vector
          operations:
            - '[*parser.Call] vector(2)'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 22
            end: 31
          returnednumber: 2
          type: 4
          fixedlabels: true
          alwaysreturns: true
          knownreturn: true
          isconditional: false
          isreturnbool: false
        - labels: {}
          operation: many-to-many
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo:
            reason: the left hand side always returs something and so the right hand side is never used
            fragment:
                start: 35
                end: 38
          position:
            start: 35
            end: 38
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 1
        end: 4
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 8
                end: 14
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(5)'
      joins:
        - labels:
            "":
                reason: Calling `vector()` will return a vector value with no labels.
                kind: excluded
                fragment:
                    start: 22
                    end: 28
          operation: vector
          returns: vector
          operations:
            - '[*parser.Call] vector(2)'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 22
            end: 31
          returnednumber: 2
          type: 4
          fixedlabels: true
          alwaysreturns: true
          knownreturn: true
          isconditional: false
          isreturnbool: false
        - labels: {}
          operation: many-to-many
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo:
            reason: the left hand side always returs something and so the right hand side is never used
            fragment:
                start: 35
                end: 38
          position:
            start: 35
            end: 38
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 8
        end: 17
      returnednumber: 10
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/13 - 1]
expr: 1 > bool 0
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 1
      returnednumber: 1
      type: 1
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: true

---

[TestLabelsSource/14 - 1]
expr: 20 > bool 10
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 2
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 2
      returnednumber: 20
      type: 1
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: true

---

[TestLabelsSource/15 - 1]
expr: '"test"'
output:
    - labels:
        "":
            reason: This query returns a string value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      operation: ""
      returns: string
      operations: []
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 6
      returnednumber: 0
      type: 2
      fixedlabels: true
      alwaysreturns: true
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/16 - 1]
expr: foo
output:
    - labels: {}
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/17 - 1]
expr: (foo > 1) > bool 1
output:
    - labels: {}
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 1
        end: 4
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/18 - 1]
expr: foo > bool 5
output:
    - labels: {}
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: true

---

[TestLabelsSource/19 - 1]
expr: foo > bool 5 == 1
output:
    - labels: {}
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/20 - 1]
expr: foo > bool bar
output:
    - labels: {}
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 11
            end: 14
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: true

---

[TestLabelsSource/21 - 1]
expr: (foo > bool bar) == 0
output:
    - labels: {}
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 12
            end: 15
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 1
        end: 4
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/22 - 1]
expr: foo > bool on(instance) bar
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 11
                end: 13
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 13
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 24
            end: 27
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: true

---

[TestLabelsSource/23 - 1]
expr: (foo > bool on(instance) bar) == 1
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 12
                end: 14
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 12
                end: 14
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 25
            end: 28
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 1
        end: 4
      returnednumber: 0
      type: 3
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/24 - 1]
expr: foo > bool on(instance) group_left(version) bar
output:
    - labels:
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 13
        version:
            reason: Query is using many-to-one vector matching with `group_left(version)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 24
                end: 34
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 44
            end: 47
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: true

---

[TestLabelsSource/25 - 1]
expr: bar > bool on(instance) group_right(version) foo
output:
    - labels:
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 13
        version:
            reason: Query is using one-to-many vector matching with `group_right(version)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 24
                end: 35
      operation: one-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 0
            end: 3
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 45
        end: 48
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: true

---

[TestLabelsSource/26 - 1]
expr: foo and bar > bool 0
output:
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 8
            end: 11
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: true
          isreturnbool: true
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/27 - 1]
expr: foo offset 5m
output:
    - labels: {}
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo offset 5m'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 13
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/28 - 1]
expr: foo{job="bar"}
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="bar"}'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 14
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/29 - 1]
expr: foo{job=""}
output:
    - labels:
        job:
            reason: Query uses `{job=""}` selector which will filter out any time series with the `job` label set.
            kind: excluded
            fragment:
                start: 0
                end: 11
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job=""}'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 11
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/30 - 1]
expr: foo{job="bar"} or bar{job="foo"}
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="bar"}'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 14
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 18
                end: 32
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{job="foo"}'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 18
        end: 32
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/31 - 1]
expr: foo{a="bar"} or bar{b="foo"}
output:
    - labels:
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 12
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{a="bar"}'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 12
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels:
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 16
                end: 28
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{b="foo"}'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 16
        end: 28
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/32 - 1]
expr: foo[5m]
output:
    - labels: {}
      operation: ""
      returns: matrix
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/33 - 1]
expr: prometheus_build_info[2m:1m]
output:
    - labels: {}
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] prometheus_build_info'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 21
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/34 - 1]
expr: deriv(rate(distance_covered_meters_total[1m])[5m:1m])
output:
    - labels: {}
      operation: deriv
      returns: vector
      operations:
        - '[*parser.VectorSelector] distance_covered_meters_total'
        - '[*parser.Call] rate(distance_covered_meters_total[1m])'
        - '[*parser.Call] deriv(rate(distance_covered_meters_total[1m])[5m:1m])'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 6
        end: 52
      returnednumber: 0
      type: 4
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/35 - 1]
expr: foo - 1
output:
    - labels: {}
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/36 - 1]
expr: foo / 5
output:
    - labels: {}
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/37 - 1]
expr: -foo
output:
    - labels: {}
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 1
        end: 4
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/38 - 1]
expr: sum(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] sum(foo{job="myjob"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 20
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/39 - 1]
expr: sum(count(foo{job="myjob"}) by(instance))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 41
        instance:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        job:
            reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 28
                end: 30
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] count by (instance) (foo{job="myjob"})'
        - '[*parser.AggregateExpr] sum(count by (instance) (foo{job="myjob"}))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 10
        end: 26
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/40 - 1]
expr: sum(foo{job="myjob"}) > 20
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] sum(foo{job="myjob"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 20
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/41 - 1]
expr: sum(foo{job="myjob"}) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 22
                end: 29
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] sum without (job) (foo{job="myjob"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 20
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/42 - 1]
expr: sum(foo) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 9
                end: 11
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 16
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 9
                end: 11
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum by (job) (foo)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 7
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/43 - 1]
expr: sum(foo{job="myjob"}) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 22
                end: 24
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 29
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] sum by (job) (foo{job="myjob"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 20
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/44 - 1]
expr: abs(foo{job="myjob"} offset 5m)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 31
      operation: abs
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"} offset 5m'
        - '[*parser.Call] abs(foo{job="myjob"} offset 5m)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 30
      returnednumber: 0
      type: 4
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/45 - 1]
expr: abs(foo{job="myjob"} or bar{cluster="dev"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 43
      operation: abs
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.Call] abs(foo{job="myjob"} or bar{cluster="dev"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 42
      returnednumber: 0
      type: 4
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels:
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 43
      operation: abs
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{cluster="dev"}'
        - '[*parser.Call] abs(foo{job="myjob"} or bar{cluster="dev"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 42
      returnednumber: 0
      type: 4
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/46 - 1]
expr: sum(foo{job="myjob"} or bar{cluster="dev"}) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 61
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 44
                end: 51
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"} or bar{cluster="dev"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 20
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 61
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 24
                end: 42
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 44
                end: 51
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{cluster="dev"}'
        - '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"} or bar{cluster="dev"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 24
        end: 42
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/47 - 1]
expr: sum(foo{job="myjob"}) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 39
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 22
                end: 29
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 20
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/48 - 1]
expr: min(foo{job="myjob"}) / max(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
      operation: min
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] min(foo{job="myjob"})'
      joins:
        - labels:
            "":
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 24
                    end: 45
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 24
                    end: 45
            job:
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 24
                    end: 45
          operation: max
          returns: vector
          operations:
            - '[*parser.VectorSelector] foo{job="myjob"}'
            - '[*parser.AggregateExpr] max(foo{job="myjob"})'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 28
            end: 44
          returnednumber: 0
          type: 5
          fixedlabels: true
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 20
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/49 - 1]
expr: max(foo{job="myjob"}) / min(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
      operation: max
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] max(foo{job="myjob"})'
      joins:
        - labels:
            "":
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 24
                    end: 45
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 24
                    end: 45
            job:
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 24
                    end: 45
          operation: min
          returns: vector
          operations:
            - '[*parser.VectorSelector] foo{job="myjob"}'
            - '[*parser.AggregateExpr] min(foo{job="myjob"})'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 28
            end: 44
          returnednumber: 0
          type: 5
          fixedlabels: true
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 20
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/50 - 1]
expr: avg(foo{job="myjob"}) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 22
                end: 24
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 29
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      operation: avg
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] avg by (job) (foo{job="myjob"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 20
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/51 - 1]
expr: group(foo) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 11
                end: 13
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 18
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 13
      operation: group
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] group by (job) (foo)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 6
        end: 9
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/52 - 1]
expr: stddev(rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      operation: stddev
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] rate(foo[5m])'
        - '[*parser.AggregateExpr] stddev(rate(foo[5m]))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 12
        end: 19
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/53 - 1]
expr: stdvar(rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      operation: stdvar
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] rate(foo[5m])'
        - '[*parser.AggregateExpr] stdvar(rate(foo[5m]))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 12
        end: 19
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/54 - 1]
expr: stddev_over_time(foo[5m])
output:
    - labels: {}
      operation: stddev_over_time
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] stddev_over_time(foo[5m])'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 17
        end: 24
      returnednumber: 0
      type: 4
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/55 - 1]
expr: stdvar_over_time(foo[5m])
output:
    - labels: {}
      operation: stdvar_over_time
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] stdvar_over_time(foo[5m])'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 17
        end: 24
      returnednumber: 0
      type: 4
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/56 - 1]
expr: quantile(0.9, rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 28
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 28
      operation: quantile
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] rate(foo[5m])'
        - '[*parser.AggregateExpr] quantile(0.9, rate(foo[5m]))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 19
        end: 26
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/57 - 1]
expr: count_values("version", build_version)
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 38
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 38
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
      operation: count_values
      returns: vector
      operations:
        - '[*parser.VectorSelector] build_version'
        - '[*parser.AggregateExpr] count_values("version", build_version)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 24
        end: 37
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/58 - 1]
expr: count_values("version", build_version) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 51
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 39
                end: 46
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 51
      operation: count_values
      returns: vector
      operations:
        - '[*parser.VectorSelector] build_version'
        - '[*parser.AggregateExpr] count_values without (job) ("version", build_version)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 24
        end: 37
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/59 - 1]
expr: count_values("version", build_version{job="foo"}) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 62
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 50
                end: 57
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 62
      operation: count_values
      returns: vector
      operations:
        - '[*parser.VectorSelector] build_version{job="foo"}'
        - '[*parser.AggregateExpr] count_values without (job) ("version", build_version{job="foo"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 24
        end: 48
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/60 - 1]
expr: count_values("version", build_version) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 39
                end: 41
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 46
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 39
                end: 41
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 46
      operation: count_values
      returns: vector
      operations:
        - '[*parser.VectorSelector] build_version'
        - '[*parser.AggregateExpr] count_values by (job) ("version", build_version)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 24
        end: 37
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/61 - 1]
expr: topk(10, foo{job="myjob"}) > 10
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 9
                end: 25
      operation: topk
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] topk(10, foo{job="myjob"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 9
        end: 25
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/62 - 1]
expr: topk(10, foo or bar)
output:
    - labels: {}
      operation: topk
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] topk(10, foo or bar)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 9
        end: 12
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels: {}
      operation: topk
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar'
        - '[*parser.AggregateExpr] topk(10, foo or bar)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 16
        end: 19
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/63 - 1]
expr: rate(foo[10m])
output:
    - labels: {}
      operation: rate
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] rate(foo[10m])'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 5
        end: 13
      returnednumber: 0
      type: 4
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/64 - 1]
expr: sum(rate(foo[10m])) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 37
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 20
                end: 27
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] rate(foo[10m])'
        - '[*parser.AggregateExpr] sum without (instance) (rate(foo[10m]))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 9
        end: 17
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/65 - 1]
expr: foo{job="foo"} / bar
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="foo"}'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 17
            end: 20
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 14
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/66 - 1]
expr: foo{job="foo"} * on(instance) bar
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 17
                end: 19
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 17
                end: 19
        job:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 17
                end: 19
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="foo"}'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 30
            end: 33
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 14
      returnednumber: 0
      type: 3
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/67 - 1]
expr: foo{job="foo"} * on(instance) group_left(bar) bar
output:
    - labels:
        bar:
            reason: Query is using many-to-one vector matching with `group_left(bar)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 30
                end: 40
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 17
                end: 19
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="foo"}'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 46
            end: 49
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 14
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/68 - 1]
expr: foo{job="foo"} * on(instance) group_left(cluster) bar{cluster="bar", ignored="true"}
output:
    - labels:
        cluster:
            reason: Query is using many-to-one vector matching with `group_left(cluster)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 30
                end: 40
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 17
                end: 19
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="foo"}'
      joins:
        - labels:
            cluster:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 50
                    end: 84
            ignored:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 50
                    end: 84
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar{cluster="bar",ignored="true"}'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 50
            end: 84
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 14
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/69 - 1]
expr: foo{job="foo", ignored="true"} * on(instance) group_right(job) bar{cluster="bar"}
output:
    - labels:
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 63
                end: 81
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 33
                end: 35
        job:
            reason: Query is using one-to-many vector matching with `group_right(job)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 46
                end: 57
      operation: one-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{cluster="bar"}'
      joins:
        - labels:
            ignored:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 0
                    end: 30
            job:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 0
                    end: 30
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] foo{ignored="true",job="foo"}'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 0
            end: 30
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 63
        end: 81
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/70 - 1]
expr: count(foo / bar)
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 16
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 16
      operation: count
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] count(foo / bar)'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 12
            end: 15
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 6
        end: 9
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/71 - 1]
expr: count(up{job="a"} / on () up{job="b"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 38
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 38
        job:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 20
                end: 23
      operation: count
      returns: vector
      operations:
        - '[*parser.VectorSelector] up{job="a"}'
        - '[*parser.AggregateExpr] count(up{job="a"} / on () up{job="b"})'
      joins:
        - labels:
            job:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 26
                    end: 37
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] up{job="b"}'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 26
            end: 37
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 6
        end: 17
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/72 - 1]
expr: count(up{job="a"} / on (env) up{job="b"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 41
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 41
        env:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 41
        job:
            reason: Query is using one-to-one vector matching with `on(env)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 20
                end: 23
      operation: count
      returns: vector
      operations:
        - '[*parser.VectorSelector] up{job="a"}'
        - '[*parser.AggregateExpr] count(up{job="a"} / on (env) up{job="b"})'
      joins:
        - labels:
            job:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 29
                    end: 40
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] up{job="b"}'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 29
            end: 40
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 6
        end: 17
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/73 - 1]
expr: foo{job="foo", instance="1"} and bar
output:
    - labels:
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{instance="1",job="foo"}'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 33
            end: 36
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 28
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/74 - 1]
expr: foo{job="foo", instance="1"} and on(cluster) bar
output:
    - labels:
        cluster:
            reason: Query is using many-to-many vector matching with `on(cluster)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 33
                end: 35
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{instance="1",job="foo"}'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 45
            end: 48
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 28
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/75 - 1]
expr: topk(10, foo)
output:
    - labels: {}
      operation: topk
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] topk(10, foo)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 9
        end: 12
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/76 - 1]
expr: topk(10, foo) without(cluster)
output:
    - labels: {}
      operation: topk
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] topk without (cluster) (10, foo)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 9
        end: 12
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/77 - 1]
expr: topk(10, foo) by(cluster)
output:
    - labels: {}
      operation: topk
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] topk by (cluster) (10, foo)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 9
        end: 12
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/78 - 1]
expr: bottomk(10, sum(rate(foo[5m])) without(job))
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 12
                end: 43
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 31
                end: 38
      operation: bottomk
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] rate(foo[5m])'
        - '[*parser.AggregateExpr] sum without (job) (rate(foo[5m]))'
        - '[*parser.AggregateExpr] bottomk(10, sum without (job) (rate(foo[5m])))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 21
        end: 28
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/79 - 1]
expr: foo or bar
output:
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 7
        end: 10
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/80 - 1]
expr: foo or bar or baz
output:
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 7
        end: 10
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] baz'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 14
        end: 17
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/81 - 1]
expr: (foo or bar) or baz
output:
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 1
        end: 4
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 8
        end: 11
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] baz'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 16
        end: 19
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/82 - 1]
expr: foo unless bar
output:
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 11
            end: 14
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/83 - 1]
expr: foo unless bar > 5
output:
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 11
            end: 14
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: true
          isreturnbool: false
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/84 - 1]
expr: foo unless bar unless baz
output:
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 11
            end: 14
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] baz'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 22
            end: 25
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      deadinfo: null
      position:
        start: 0
        end: 3
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/85 - 1]
expr: count(sum(up{job="foo", cluster="dev"}) by(job, cluster) == 0) without(job, cluster)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 40
                end: 42
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 84
        cluster:
            reason: Query is using aggregation with `without(job, cluster)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 63
                end: 70
        job:
            reason: Query is using aggregation with `without(job, cluster)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 63
                end: 70
      operation: count
      returns: vector
      operations:
        - '[*parser.VectorSelector] up{cluster="dev",job="foo"}'
        - '[*parser.AggregateExpr] sum by (job, cluster) (up{cluster="dev",job="foo"})'
        - '[*parser.AggregateExpr] count without (job, cluster) (sum by (job, cluster) (up{cluster="dev",job="foo"}) == 0)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 10
        end: 38
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/86 - 1]
expr: year()
output:
    - labels:
        "":
            reason: Calling `year()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      operation: year
      returns: vector
      operations:
        - '[*parser.Call] year()'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 6
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/87 - 1]
expr: year(foo)
output:
    - labels: {}
      operation: year
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] year(foo)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 5
        end: 8
      returnednumber: 0
      type: 4
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/88 - 1]
expr: label_join(up{job="api-server",src1="a",src2="b",src3="c"}, "foo", ",", "src1", "src2", "src3")
output:
    - labels:
        foo:
            reason: This label will be added to the result by label_join() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 95
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src1:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src2:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src3:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
      operation: label_join
      returns: vector
      operations:
        - '[*parser.VectorSelector] up{job="api-server",src1="a",src2="b",src3="c"}'
        - '[*parser.Call] label_join(up{job="api-server",src1="a",src2="b",src3="c"}, "foo", ",", "src1", "src2", "src3")'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 11
        end: 58
      returnednumber: 0
      type: 4
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/89 - 1]
expr: |4-
    (
     sum(foo:sum > 0) without(notify)
     * on(job) group_left(notify)
     job:notify
    )
    and on(job)
    sum(foo:count) by(job) > 20
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 4
                end: 36
        job:
            reason: Query is using many-to-many vector matching with `on(job)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 40
                end: 42
        notify:
            reason: Query is using many-to-one vector matching with `group_left(notify)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 48
                end: 58
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo:sum'
        - '[*parser.AggregateExpr] sum without (notify) (foo:sum > 0)'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] job:notify'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 68
            end: 78
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
        - labels:
            "":
                reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
                kind: excluded
                fragment:
                    start: 108
                    end: 110
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 93
                    end: 115
            job:
                reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
                kind: included
                fragment:
                    start: 108
                    end: 110
          operation: sum
          returns: vector
          operations:
            - '[*parser.VectorSelector] foo:count'
            - '[*parser.AggregateExpr] sum by (job) (foo:count)'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 97
            end: 106
          returnednumber: 0
          type: 5
          fixedlabels: true
          alwaysreturns: false
          knownreturn: false
          isconditional: true
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 8
        end: 15
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/90 - 1]
expr: container_file_descriptors / on (instance, app_name) container_ulimits_soft{ulimit="max_open_files"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 29
                end: 32
        app_name:
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 29
                end: 32
        instance:
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 29
                end: 32
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] container_file_descriptors'
      joins:
        - labels:
            ulimit:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 53
                    end: 100
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] container_ulimits_soft{ulimit="max_open_files"}'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 53
            end: 100
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 26
      returnednumber: 0
      type: 3
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/91 - 1]
expr: container_file_descriptors / on (instance, app_name) group_left() container_ulimits_soft{ulimit="max_open_files"}
output:
    - labels:
        app_name:
            reason: Query is using many-to-one vector matching with `on(instance, app_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 29
                end: 32
        instance:
            reason: Query is using many-to-one vector matching with `on(instance, app_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 29
                end: 32
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] container_file_descriptors'
      joins:
        - labels:
            ulimit:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 66
                    end: 113
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] container_ulimits_soft{ulimit="max_open_files"}'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 66
            end: 113
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 26
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/92 - 1]
expr: absent(foo{job="bar"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 22
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="bar"}'
        - '[*parser.Call] absent(foo{job="bar"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 7
        end: 21
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/93 - 1]
expr: absent(foo{job="bar", cluster!="dev", instance=~".+", env="prod"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        env:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 66
        instance:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 66
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{cluster!="dev",env="prod",instance=~".+",job="bar"}'
        - '[*parser.Call] absent(foo{cluster!="dev",env="prod",instance=~".+",job="bar"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 7
        end: 65
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/94 - 1]
expr: absent(sum(foo) by(job, instance))
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 7
                end: 33
        instance:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum by (job, instance) (foo)'
        - '[*parser.Call] absent(sum by (job, instance) (foo))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 7
        end: 33
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/95 - 1]
expr: absent(foo{job="prometheus", xxx="1"}) AND on(job) prometheus_build_info
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
        xxx:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="prometheus",xxx="1"}'
        - '[*parser.Call] absent(foo{job="prometheus",xxx="1"})'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] prometheus_build_info'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 51
            end: 72
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 7
        end: 37
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/96 - 1]
expr: 1 + sum(foo) by(notjob)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(notjob)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 4
                end: 23
        notjob:
            reason: Query is using aggregation with `by(notjob)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum by (notjob) (foo)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 8
        end: 11
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/97 - 1]
expr: count(node_exporter_build_info) by (instance, version) != ignoring(package,version) group_left(foo) count(deb_package_version) by (instance, version, package)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 32
                end: 35
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 54
        foo:
            reason: Query is using many-to-one vector matching with `group_left(foo)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 84
                end: 94
        instance:
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 32
                end: 35
        version:
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 32
                end: 35
      operation: count
      returns: vector
      operations:
        - '[*parser.VectorSelector] node_exporter_build_info'
        - '[*parser.AggregateExpr] count by (instance, version) (node_exporter_build_info)'
      joins:
        - labels:
            "":
                reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                kind: excluded
                fragment:
                    start: 127
                    end: 130
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 100
                    end: 158
            instance:
                reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                kind: included
                fragment:
                    start: 127
                    end: 130
            package:
                reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                kind: included
                fragment:
                    start: 127
                    end: 130
            version:
                reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                kind: included
                fragment:
                    start: 127
                    end: 130
          operation: count
          returns: vector
          operations:
            - '[*parser.VectorSelector] deb_package_version'
            - '[*parser.AggregateExpr] count by (instance, version, package) (deb_package_version)'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 106
            end: 125
          returnednumber: 0
          type: 5
          fixedlabels: true
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 6
        end: 30
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/98 - 1]
expr: absent(foo) or absent(bar)
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] absent(foo)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 7
        end: 10
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 15
                end: 21
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar'
        - '[*parser.Call] absent(bar)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 22
        end: 25
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/99 - 1]
expr: absent_over_time(foo[5m]) or absent(bar)
output:
    - labels:
        "":
            reason: |-
                The [absent_over_time()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent_over_time) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 16
      operation: absent_over_time
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] absent_over_time(foo[5m])'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 17
        end: 24
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 29
                end: 35
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar'
        - '[*parser.Call] absent(bar)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 36
        end: 39
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/100 - 1]
expr: bar * on() group_right(cluster, env) absent(foo{job="xxx"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 37
                end: 43
        cluster:
            reason: Query is using one-to-many vector matching with `group_right(cluster, env)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 11
                end: 22
        env:
            reason: Query is using one-to-many vector matching with `group_right(cluster, env)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 11
                end: 22
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 37
                end: 59
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="xxx"}'
        - '[*parser.Call] absent(foo{job="xxx"})'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 0
            end: 3
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 44
        end: 58
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/101 - 1]
expr: bar * on() group_right() absent(foo{job="xxx"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 25
                end: 31
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 25
                end: 47
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="xxx"}'
        - '[*parser.Call] absent(foo{job="xxx"})'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 0
            end: 3
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 32
        end: 46
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/102 - 1]
expr: vector(1)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 9
      returnednumber: 1
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/103 - 1]
expr: vector(scalar(foo))
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(scalar(foo))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 19
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/104 - 1]
expr: vector(0.0  >= bool 0.5) == 1
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(0 >= bool 0.5)'
      joins: []
      unless: []
      deadinfo:
        reason: this query always evaluates to `0 == 1` which is not possible, so it will never return anything
        fragment:
            start: 0
            end: 24
      position:
        start: 0
        end: 24
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/105 - 1]
expr: sum_over_time(foo{job="myjob"}[5m])
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 35
      operation: sum_over_time
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.Call] sum_over_time(foo{job="myjob"}[5m])'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 14
        end: 34
      returnednumber: 0
      type: 4
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/106 - 1]
expr: days_in_month()
output:
    - labels:
        "":
            reason: Calling `days_in_month()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 15
      operation: days_in_month
      returns: vector
      operations:
        - '[*parser.Call] days_in_month()'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 15
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/107 - 1]
expr: days_in_month(foo{job="foo"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 29
      operation: days_in_month
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="foo"}'
        - '[*parser.Call] days_in_month(foo{job="foo"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 14
        end: 28
      returnednumber: 0
      type: 4
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/108 - 1]
expr: label_replace(up{job="api-server",service="a:c"}, "foo", "$1", "service", "(.*):.*")
output:
    - labels:
        foo:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 84
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 14
                end: 48
        service:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 14
                end: 48
      operation: label_replace
      returns: vector
      operations:
        - '[*parser.VectorSelector] up{job="api-server",service="a:c"}'
        - '[*parser.Call] label_replace(up{job="api-server",service="a:c"}, "foo", "$1", "service", "(.*):.*")'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 14
        end: 48
      returnednumber: 0
      type: 4
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/109 - 1]
expr: label_replace(sum by (pod) (pod_status) > 0, "cluster", "$1", "pod", "(.*)")
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 18
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 14
                end: 39
        cluster:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 76
        pod:
            reason: Query is using aggregation with `by(pod)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 18
                end: 21
      operation: label_replace
      returns: vector
      operations:
        - '[*parser.VectorSelector] pod_status'
        - '[*parser.AggregateExpr] sum by (pod) (pod_status)'
        - '[*parser.Call] label_replace(sum by (pod) (pod_status) > 0, "cluster", "$1", "pod", "(.*)")'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 14
        end: 43
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/110 - 1]
expr: (time() - my_metric) > 5*3600
output:
    - labels: {}
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] my_metric'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 10
        end: 19
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/111 - 1]
expr: up{instance="a", job="prometheus"} * ignoring(job) up{instance="a", job="pint"}
output:
    - labels:
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using one-to-one vector matching with `ignoring(job)`, all labels included inside `ignoring(...)` will be removed on the results.
            kind: excluded
            fragment:
                start: 37
                end: 45
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] up{instance="a",job="prometheus"}'
      joins:
        - labels:
            instance:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 51
                    end: 79
            job:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 51
                    end: 79
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] up{instance="a",job="pint"}'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 51
            end: 79
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 34
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/112 - 1]
expr: |4
    avg without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"})
    < 0.5 > 0
    or sum without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"})
    < on() count(colo_router_tier:disabled_pops:max{tier="1",router=~"edge.*"}) * 0.4 > 0
    or avg without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"})
    < 0.1 > 0
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 101
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 5
                end: 12
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 5
                end: 12
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 5
                end: 12
      operation: avg
      returns: vector
      operations:
        - '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"}'
        - '[*parser.AggregateExpr] avg without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 41
        end: 100
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 216
                end: 218
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 115
                end: 213
        cidr_use_case:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 216
                end: 218
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 119
                end: 126
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 119
                end: 126
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 119
                end: 126
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"}'
        - '[*parser.AggregateExpr] sum without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"})'
      joins:
        - labels:
            "":
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 221
                    end: 289
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 221
                    end: 289
            router:
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 221
                    end: 289
            tier:
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 221
                    end: 289
          operation: count
          returns: vector
          operations:
            - '[*parser.VectorSelector] colo_router_tier:disabled_pops:max{router=~"edge.*",tier="1"}'
            - '[*parser.AggregateExpr] count(colo_router_tier:disabled_pops:max{router=~"edge.*",tier="1"})'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 227
            end: 288
          returnednumber: 0
          type: 5
          fixedlabels: true
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 155
        end: 212
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 303
                end: 404
        cidr_use_case:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 343
                end: 403
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 307
                end: 314
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 307
                end: 314
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 307
                end: 314
      operation: avg
      returns: vector
      operations:
        - '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"}'
        - '[*parser.AggregateExpr] avg without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 343
        end: 403
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/113 - 1]
expr: label_replace(sum(foo) without(instance), "instance", "none", "", "")
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 14
                end: 40
        instance:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 69
      operation: label_replace
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum without (instance) (foo)'
        - '[*parser.Call] label_replace(sum without (instance) (foo), "instance", "none", "", "")'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 14
        end: 40
      returnednumber: 0
      type: 4
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/114 - 1]
expr: |4-
    sum by (region, target, colo_name) (
        sum_over_time(probe_success{job="abc"}[5m])
     or
     vector(1)
    ) == 0
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 102
        colo_name:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        job:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        region:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        target:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] probe_success{job="abc"}'
        - '[*parser.Call] sum_over_time(probe_success{job="abc"}[5m])'
        - '[*parser.AggregateExpr] sum by (region, target, colo_name) (sum_over_time(probe_success{job="abc"}[5m]) or vector(1))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 56
        end: 84
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false
    - labels:
        "":
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 102
        colo_name:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
        region:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
        target:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
      operation: sum
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
        - '[*parser.AggregateExpr] sum by (region, target, colo_name) (sum_over_time(probe_success{job="abc"}[5m]) or vector(1))'
      joins: []
      unless: []
      deadinfo:
        reason: this query always evaluates to `1 == 0` which is not possible, so it will never return anything
        fragment:
            start: 91
            end: 100
      position:
        start: 91
        end: 100
      returnednumber: 1
      type: 5
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/115 - 1]
expr: vector(1) or foo
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 9
      returnednumber: 1
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: false
      isreturnbool: false
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo:
        reason: the left hand side always returs something and so the right hand side is never used
        fragment:
            start: 13
            end: 16
      position:
        start: 13
        end: 16
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/116 - 1]
expr: vector(0) > 0
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
      joins: []
      unless: []
      deadinfo:
        reason: this query always evaluates to `0 > 0` which is not possible, so it will never return anything
        fragment:
            start: 0
            end: 9
      position:
        start: 0
        end: 9
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/117 - 1]
expr: vector(0) > vector(1)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
      joins:
        - labels:
            "":
                reason: Calling `vector()` will return a vector value with no labels.
                kind: excluded
                fragment:
                    start: 12
                    end: 18
          operation: vector
          returns: vector
          operations:
            - '[*parser.Call] vector(1)'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 12
            end: 21
          returnednumber: 1
          type: 4
          fixedlabels: true
          alwaysreturns: true
          knownreturn: true
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo:
        reason: '`vector(0) > vector(1)` always evaluates to `0 > 1` which is not possible, so it will never return anything'
        fragment:
            start: 0
            end: 9
      position:
        start: 0
        end: 9
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/118 - 1]
expr: sum(foo or vector(0)) > 0
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum(foo or vector(0))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 7
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      operation: sum
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
        - '[*parser.AggregateExpr] sum(foo or vector(0))'
      joins: []
      unless: []
      deadinfo:
        reason: this query always evaluates to `0 > 0` which is not possible, so it will never return anything
        fragment:
            start: 11
            end: 20
      position:
        start: 11
        end: 20
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/119 - 1]
expr: (sum(foo or vector(1)) > 0) == 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum(foo or vector(1))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 5
        end: 8
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      operation: sum
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
        - '[*parser.AggregateExpr] sum(foo or vector(1))'
      joins: []
      unless: []
      deadinfo:
        reason: this query always evaluates to `1 == 2` which is not possible, so it will never return anything
        fragment:
            start: 12
            end: 21
      position:
        start: 12
        end: 21
      returnednumber: 1
      type: 5
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/120 - 1]
expr: (sum(foo or vector(1)) > 0) != 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum(foo or vector(1))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 5
        end: 8
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      operation: sum
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
        - '[*parser.AggregateExpr] sum(foo or vector(1))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 12
        end: 21
      returnednumber: 1
      type: 5
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/121 - 1]
expr: (sum(foo or vector(2)) > 0) != 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum(foo or vector(2))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 5
        end: 8
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      operation: sum
      returns: vector
      operations:
        - '[*parser.Call] vector(2)'
        - '[*parser.AggregateExpr] sum(foo or vector(2))'
      joins: []
      unless: []
      deadinfo:
        reason: this query always evaluates to `2 != 2` which is not possible, so it will never return anything
        fragment:
            start: 12
            end: 21
      position:
        start: 12
        end: 21
      returnednumber: 2
      type: 5
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/122 - 1]
expr: |-
    (sum(sometimes{foo!="bar"} or vector(0)))
    or
    ((bob > 10) or sum(foo) or vector(1))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 41
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] sometimes{foo!="bar"}'
        - '[*parser.AggregateExpr] sum(sometimes{foo!="bar"} or vector(0))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 5
        end: 26
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 41
      operation: sum
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
        - '[*parser.AggregateExpr] sum(sometimes{foo!="bar"} or vector(0))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 30
        end: 39
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: false
      isreturnbool: false
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bob'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 47
        end: 50
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 60
                end: 63
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 60
                end: 68
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum(foo)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 64
        end: 67
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 72
                end: 78
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 72
        end: 81
      returnednumber: 1
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/123 - 1]
expr: |4-
    (
     sum(sometimes{foo!="bar"})
     or
     vector(1)
    ) and (
     ((bob > 10) or sum(bar))
     or
     notfound > 0
    )
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 4
                end: 7
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 4
                end: 30
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] sometimes{foo!="bar"}'
        - '[*parser.AggregateExpr] sum(sometimes{foo!="bar"})'
      joins:
        - labels: {}
          operation: many-to-many
          returns: vector
          operations:
            - '[*parser.VectorSelector] bob'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 57
            end: 60
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: true
          isreturnbool: false
        - labels:
            "":
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 70
                    end: 73
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 70
                    end: 79
          operation: sum
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
            - '[*parser.AggregateExpr] sum(bar)'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 74
            end: 77
          returnednumber: 0
          type: 5
          fixedlabels: true
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
        - labels: {}
          operation: many-to-many
          returns: vector
          operations:
            - '[*parser.VectorSelector] notfound'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 85
            end: 93
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: true
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 8
        end: 29
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 36
                end: 42
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
      joins:
        - labels: {}
          operation: many-to-many
          returns: vector
          operations:
            - '[*parser.VectorSelector] bob'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 57
            end: 60
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: true
          isreturnbool: false
        - labels:
            "":
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 70
                    end: 73
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 70
                    end: 79
          operation: sum
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
            - '[*parser.AggregateExpr] sum(bar)'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 74
            end: 77
          returnednumber: 0
          type: 5
          fixedlabels: true
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
        - labels: {}
          operation: many-to-many
          returns: vector
          operations:
            - '[*parser.VectorSelector] notfound'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 85
            end: 93
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: true
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 36
        end: 45
      returnednumber: 1
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/124 - 1]
expr: foo offset 5m > 5
output:
    - labels: {}
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo offset 5m'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 13
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/125 - 1]
expr: |4
    (rate(metric2[5m]) or vector(0)) +
    (rate(metric1[5m]) or vector(1)) +
    (rate(metric3{log_name="samplerd"}[5m]) or vector(2)) > 0
output:
    - labels: {}
      operation: rate
      returns: vector
      operations:
        - '[*parser.VectorSelector] metric2'
        - '[*parser.Call] rate(metric2[5m])'
      joins:
        - labels: {}
          operation: rate
          returns: vector
          operations:
            - '[*parser.VectorSelector] metric1'
            - '[*parser.Call] rate(metric1[5m])'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 42
            end: 53
          returnednumber: 0
          type: 4
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
        - labels:
            "":
                reason: Calling `vector()` will return a vector value with no labels.
                kind: excluded
                fragment:
                    start: 58
                    end: 64
          operation: vector
          returns: vector
          operations:
            - '[*parser.Call] vector(1)'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 58
            end: 67
          returnednumber: 1
          type: 4
          fixedlabels: true
          alwaysreturns: true
          knownreturn: true
          isconditional: false
          isreturnbool: false
        - labels:
            log_name:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 72
                    end: 110
          operation: rate
          returns: vector
          operations:
            - '[*parser.VectorSelector] metric3{log_name="samplerd"}'
            - '[*parser.Call] rate(metric3{log_name="samplerd"}[5m])'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 77
            end: 109
          returnednumber: 0
          type: 4
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
        - labels:
            "":
                reason: Calling `vector()` will return a vector value with no labels.
                kind: excluded
                fragment:
                    start: 114
                    end: 120
          operation: vector
          returns: vector
          operations:
            - '[*parser.Call] vector(2)'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 114
            end: 123
          returnednumber: 2
          type: 4
          fixedlabels: true
          alwaysreturns: true
          knownreturn: true
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 7
        end: 18
      returnednumber: 0
      type: 4
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 23
                end: 29
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
      joins:
        - labels: {}
          operation: rate
          returns: vector
          operations:
            - '[*parser.VectorSelector] metric1'
            - '[*parser.Call] rate(metric1[5m])'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 42
            end: 53
          returnednumber: 0
          type: 4
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
        - labels:
            "":
                reason: Calling `vector()` will return a vector value with no labels.
                kind: excluded
                fragment:
                    start: 58
                    end: 64
          operation: vector
          returns: vector
          operations:
            - '[*parser.Call] vector(1)'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 58
            end: 67
          returnednumber: 1
          type: 4
          fixedlabels: true
          alwaysreturns: true
          knownreturn: true
          isconditional: false
          isreturnbool: false
        - labels:
            log_name:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 72
                    end: 110
          operation: rate
          returns: vector
          operations:
            - '[*parser.VectorSelector] metric3{log_name="samplerd"}'
            - '[*parser.Call] rate(metric3{log_name="samplerd"}[5m])'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 77
            end: 109
          returnednumber: 0
          type: 4
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
        - labels:
            "":
                reason: Calling `vector()` will return a vector value with no labels.
                kind: excluded
                fragment:
                    start: 114
                    end: 120
          operation: vector
          returns: vector
          operations:
            - '[*parser.Call] vector(2)'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 114
            end: 123
          returnednumber: 2
          type: 4
          fixedlabels: true
          alwaysreturns: true
          knownreturn: true
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 23
        end: 32
      returnednumber: 3
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/126 - 1]
expr: label_replace(vector(1), "nexthop_tag", "$1", "nexthop", "(.+)")
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 14
                end: 20
        nexthop_tag:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 64
      operation: label_replace
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
        - '[*parser.Call] label_replace(vector(1), "nexthop_tag", "$1", "nexthop", "(.+)")'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 14
        end: 23
      returnednumber: 1
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/127 - 1]
expr: (sum(foo{job="myjob"}))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 23
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] sum(foo{job="myjob"})'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 5
        end: 21
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/128 - 1]
expr: (-foo{job="myjob"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 2
                end: 18
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 2
        end: 18
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/129 - 1]
expr: |4-
    ((( group(vector(0)) ))) > 0
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 5
                end: 23
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 5
                end: 23
      operation: group
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
        - '[*parser.AggregateExpr] group(vector(0))'
      joins: []
      unless: []
      deadinfo:
        reason: this query always evaluates to `0 > 0` which is not possible, so it will never return anything
        fragment:
            start: 11
            end: 20
      position:
        start: 11
        end: 20
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/130 - 1]
expr: 1 > bool 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      deadinfo:
        reason: this query always evaluates to `1 > 5` which is not possible, so it will never return anything
        fragment:
            start: 0
            end: 1
      position:
        start: 0
        end: 1
      returnednumber: 1
      type: 1
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: true

---

[TestLabelsSource/131 - 1]
expr: prometheus_ready{job="prometheus"} unless vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
      joins: []
      unless:
        - labels:
            "":
                reason: Calling `vector()` will return a vector value with no labels.
                kind: excluded
                fragment:
                    start: 42
                    end: 48
          operation: vector
          returns: vector
          operations:
            - '[*parser.Call] vector(0)'
          joins: []
          unless: []
          deadinfo:
            reason: The right hand side will never be matched because it doesn't have the `job` label while the left hand side will. Calling `vector()` will return a vector value with no labels.
            fragment:
                start: 42
                end: 48
          position:
            start: 42
            end: 51
          returnednumber: 0
          type: 4
          fixedlabels: true
          alwaysreturns: true
          knownreturn: true
          isconditional: false
          isreturnbool: false
      deadinfo: null
      position:
        start: 0
        end: 34
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/132 - 1]
expr: prometheus_ready{job="prometheus"} unless on() vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
      joins: []
      unless:
        - labels:
            "":
                reason: Calling `vector()` will return a vector value with no labels.
                kind: excluded
                fragment:
                    start: 47
                    end: 53
          operation: vector
          returns: vector
          operations:
            - '[*parser.Call] vector(0)'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 47
            end: 56
          returnednumber: 0
          type: 4
          fixedlabels: true
          alwaysreturns: true
          knownreturn: true
          isconditional: false
          isreturnbool: false
      deadinfo:
        reason: this query will never return anything because the `unless` query always returns something
        fragment:
            start: 47
            end: 56
      position:
        start: 0
        end: 34
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/133 - 1]
expr: prometheus_ready{job="prometheus"} unless on(job) vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
      joins: []
      unless:
        - labels:
            "":
                reason: Calling `vector()` will return a vector value with no labels.
                kind: excluded
                fragment:
                    start: 50
                    end: 56
          operation: vector
          returns: vector
          operations:
            - '[*parser.Call] vector(0)'
          joins: []
          unless: []
          deadinfo:
            reason: The right hand side will never be matched because it doesn't have the `job` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
            fragment:
                start: 50
                end: 56
          position:
            start: 50
            end: 59
          returnednumber: 0
          type: 4
          fixedlabels: true
          alwaysreturns: true
          knownreturn: true
          isconditional: false
          isreturnbool: false
      deadinfo: null
      position:
        start: 0
        end: 34
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/134 - 1]
expr: |4
    max by (instance, cluster) (cf_node_role{kubernetes_role="master",role="kubernetes"})
    unless
       sum by (instance, cluster) (time() - node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"})
       * on (instance) group_left (cluster)
        cf_node_role{kubernetes_role="master",role="kubernetes"}
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 86
        cluster:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        instance:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        kubernetes_role:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        role:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
      operation: max
      returns: vector
      operations:
        - '[*parser.VectorSelector] cf_node_role{kubernetes_role="master",role="kubernetes"}'
        - '[*parser.AggregateExpr] max by (instance, cluster) (cf_node_role{kubernetes_role="master",role="kubernetes"})'
      joins: []
      unless:
        - labels:
            "":
                reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
                kind: excluded
                fragment:
                    start: 99
                    end: 102
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 95
                    end: 202
            cluster:
                reason: Query is using many-to-one vector matching with `group_left(cluster)`, all labels included inside `group_left(...)` will be include on the results.
                kind: included
                fragment:
                    start: 222
                    end: 233
            instance:
                reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
                kind: included
                fragment:
                    start: 208
                    end: 211
            name:
                reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
                kind: excluded
                fragment:
                    start: 99
                    end: 102
          operation: sum
          returns: vector
          operations:
            - '[*parser.VectorSelector] node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"}'
            - '[*parser.AggregateExpr] sum by (instance, cluster) (time() - node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"})'
          joins:
            - labels:
                kubernetes_role:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 247
                        end: 303
                role:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 247
                        end: 303
              operation: ""
              returns: vector
              operations:
                - '[*parser.VectorSelector] cf_node_role{kubernetes_role="master",role="kubernetes"}'
              joins: []
              unless: []
              deadinfo: null
              position:
                start: 247
                end: 303
              returnednumber: 0
              type: 3
              fixedlabels: false
              alwaysreturns: false
              knownreturn: false
              isconditional: false
              isreturnbool: false
          unless: []
          deadinfo: null
          position:
            start: 132
            end: 201
          returnednumber: 0
          type: 5
          fixedlabels: true
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      deadinfo: null
      position:
        start: 29
        end: 85
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/135 - 1]
expr: foo{a="1"} * on() bar{b="2"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
        a:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{a="1"}'
      joins:
        - labels:
            b:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 18
                    end: 28
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar{b="2"}'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 18
            end: 28
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 10
      returnednumber: 0
      type: 3
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/136 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) bar{b="2"}
output:
    - labels:
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        d:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{a="1"}'
      joins:
        - labels:
            b:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 42
                    end: 52
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar{b="2"}'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 42
            end: 52
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 10
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/137 - 1]
expr: foo{a="1"} * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 43
                end: 53
        c:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 37
        d:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 37
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      operation: one-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{b="2"}'
      joins:
        - labels:
            a:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 0
                    end: 10
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] foo{a="1"}'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 0
            end: 10
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 43
        end: 53
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/138 - 1]
expr: foo{a="1"} * on(instance) sum(bar{b="2"})
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
        a:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{a="1"}'
      joins:
        - labels:
            "":
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 26
                    end: 29
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 26
                    end: 41
            b:
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 26
                    end: 29
          operation: sum
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar{b="2"}'
            - '[*parser.AggregateExpr] sum(bar{b="2"})'
          joins: []
          unless: []
          deadinfo:
            reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
            fragment:
                start: 26
                end: 29
          position:
            start: 30
            end: 40
          returnednumber: 0
          type: 5
          fixedlabels: true
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 10
      returnednumber: 0
      type: 3
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/139 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) sum(bar{b="2"})
output:
    - labels:
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        d:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{a="1"}'
      joins:
        - labels:
            "":
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 42
                    end: 45
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 42
                    end: 57
            b:
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 42
                    end: 45
          operation: sum
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar{b="2"}'
            - '[*parser.AggregateExpr] sum(bar{b="2"})'
          joins: []
          unless: []
          deadinfo:
            reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
            fragment:
                start: 42
                end: 45
          position:
            start: 46
            end: 56
          returnednumber: 0
          type: 5
          fixedlabels: true
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 10
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/140 - 1]
expr: sum(foo{a="1"}) * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 48
                end: 58
        c:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 31
                end: 42
        d:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 31
                end: 42
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 18
                end: 20
      operation: one-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{b="2"}'
      joins:
        - labels:
            "":
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 0
                    end: 3
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 0
                    end: 15
            a:
                reason: Query is using aggregation that removes all labels.
                kind: excluded
                fragment:
                    start: 0
                    end: 3
          operation: sum
          returns: vector
          operations:
            - '[*parser.VectorSelector] foo{a="1"}'
            - '[*parser.AggregateExpr] sum(foo{a="1"})'
          joins: []
          unless: []
          deadinfo:
            reason: The left hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
            fragment:
                start: 0
                end: 3
          position:
            start: 4
            end: 14
          returnednumber: 0
          type: 5
          fixedlabels: true
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 48
        end: 58
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/141 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) sum(bar{b="2"}) without(instance)
output:
    - labels:
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        d:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{a="1"}'
      joins:
        - labels:
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 42
                    end: 75
            b:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 46
                    end: 56
            instance:
                reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                kind: excluded
                fragment:
                    start: 58
                    end: 65
          operation: sum
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar{b="2"}'
            - '[*parser.AggregateExpr] sum without (instance) (bar{b="2"})'
          joins: []
          unless: []
          deadinfo:
            reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            fragment:
                start: 58
                end: 65
          position:
            start: 46
            end: 56
          returnednumber: 0
          type: 5
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 0
        end: 10
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/142 - 1]
expr: sum(foo{a="1"}) without(instance) * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 66
                end: 76
        c:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 49
                end: 60
        d:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 49
                end: 60
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 36
                end: 38
      operation: one-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{b="2"}'
      joins:
        - labels:
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 0
                    end: 33
            a:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 4
                    end: 14
            instance:
                reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                kind: excluded
                fragment:
                    start: 16
                    end: 23
          operation: sum
          returns: vector
          operations:
            - '[*parser.VectorSelector] foo{a="1"}'
            - '[*parser.AggregateExpr] sum without (instance) (foo{a="1"})'
          joins: []
          unless: []
          deadinfo:
            reason: The left hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            fragment:
                start: 16
                end: 23
          position:
            start: 4
            end: 14
          returnednumber: 0
          type: 5
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 66
        end: 76
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/143 - 1]
expr: |4
     max without (source_instance) (
       increase(kernel_device_io_errors_total{device!~"loop.+"}[120m]) > 3 unless on(instance, device) (
         increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[125m])*2 > increase(kernel_device_io_errors_total[120m])
       )
       and on(device, instance) absent(node_disk_info)
     ) * on(instance) group_left(group) label_replace(salt_highstate_runner_configured_minions, "instance", "$1", "minion", "(.+)")
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 2
                end: 317
        device:
            reason: Query is using many-to-many vector matching with `on(device, instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 112
                end: 114
        group:
            reason: Query is using many-to-one vector matching with `group_left(group)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 333
                end: 343
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 112
                end: 114
        source_instance:
            reason: Query is using aggregation with `without(source_instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 6
                end: 14
      operation: max
      returns: vector
      operations:
        - '[*parser.VectorSelector] kernel_device_io_errors_total{device!~"loop.+"}'
        - '[*parser.Call] increase(kernel_device_io_errors_total{device!~"loop.+"}[2h])'
        - '[*parser.AggregateExpr] max without (source_instance) (increase(kernel_device_io_errors_total{device!~"loop.+"}[2h]) > 3 unless on (instance, device) (increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[2h5m]) * 2 > increase(kernel_device_io_errors_total[2h])) and on (device, instance) absent(node_disk_info))'
      joins:
        - labels:
            "":
                reason: |-
                    The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                    You will only get any results back if the metric selector you pass doesn't match anything.
                    Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                    This means that the only labels you can get back from absent call are the ones you pass to it.
                    If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
                kind: excluded
                fragment:
                    start: 292
                    end: 298
          operation: absent
          returns: vector
          operations:
            - '[*parser.VectorSelector] node_disk_info'
            - '[*parser.Call] absent(node_disk_info)'
          joins: []
          unless: []
          deadinfo:
            reason: |-
                The right hand side will never be matched because it doesn't have the `device` label from `on(...)`. The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            fragment:
                start: 292
                end: 298
          position:
            start: 299
            end: 313
          returnednumber: 0
          type: 4
          fixedlabels: true
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
        - labels:
            instance:
                reason: This label will be added to the result by label_replace() call.
                kind: guaranteed
                fragment:
                    start: 351
                    end: 442
          operation: label_replace
          returns: vector
          operations:
            - '[*parser.VectorSelector] salt_highstate_runner_configured_minions'
            - '[*parser.Call] label_replace(salt_highstate_runner_configured_minions, "instance", "$1", "minion", "(.+)")'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 365
            end: 405
          returnednumber: 0
          type: 4
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless:
        - labels: {}
          operation: increase
          returns: vector
          operations:
            - '[*parser.VectorSelector] kernel_device_io_soft_errors_total{device!~"loop.+"}'
            - '[*parser.Call] increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[2h5m])'
          joins:
            - labels: {}
              operation: increase
              returns: vector
              operations:
                - '[*parser.VectorSelector] kernel_device_io_errors_total'
                - '[*parser.Call] increase(kernel_device_io_errors_total[2h])'
              joins: []
              unless: []
              deadinfo: null
              position:
                start: 222
                end: 257
              returnednumber: 0
              type: 4
              fixedlabels: false
              alwaysreturns: false
              knownreturn: false
              isconditional: false
              isreturnbool: false
          unless: []
          deadinfo: null
          position:
            start: 149
            end: 207
          returnednumber: 0
          type: 4
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: true
          isreturnbool: false
      deadinfo: null
      position:
        start: 46
        end: 99
      returnednumber: 0
      type: 5
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/144 - 1]
expr: sum(foo{a="1"}) by(job) * on() bar{b="2"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 26
                end: 28
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 23
        a:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 16
                end: 18
        job:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 26
                end: 28
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{a="1"}'
        - '[*parser.AggregateExpr] sum by (job) (foo{a="1"})'
      joins:
        - labels:
            b:
                reason: Query will only return series where these labels are present.
                kind: guaranteed
                fragment:
                    start: 31
                    end: 41
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar{b="2"}'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 31
            end: 41
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 4
        end: 14
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/145 - 1]
expr: sum(sum(foo) without(job)) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 27
                end: 29
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 13
                end: 20
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum without (job) (foo)'
        - '[*parser.AggregateExpr] sum by (job) (sum without (job) (foo))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 8
        end: 11
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/146 - 1]
expr: |4
    prometheus:scrape_series_added:since_gc:sum
    * on(prometheus) group_left()
    label_replace(
      max(max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])) by(instance)
      /
      max(max_over_time(prometheus_tsdb_head_series[2h])) by(instance),
      "prometheus", "$1",
      "instance", "(.+)"
    )
output:
    - labels:
        prometheus:
            reason: Query is using many-to-one vector matching with `on(prometheus)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 47
                end: 49
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] prometheus:scrape_series_added:since_gc:sum'
      joins:
        - labels:
            "":
                reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                kind: excluded
                fragment:
                    start: 158
                    end: 160
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 92
                    end: 170
            instance:
                reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                kind: included
                fragment:
                    start: 158
                    end: 160
            job:
                reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                kind: excluded
                fragment:
                    start: 158
                    end: 160
            prometheus:
                reason: This label will be added to the result by label_replace() call.
                kind: guaranteed
                fragment:
                    start: 75
                    end: 287
          operation: label_replace
          returns: vector
          operations:
            - '[*parser.VectorSelector] go_memstats_alloc_bytes{job="prometheus"}'
            - '[*parser.Call] max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])'
            - '[*parser.AggregateExpr] max by (instance) (max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h]))'
            - '[*parser.Call] label_replace(max by (instance) (max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])) / max by (instance) (max_over_time(prometheus_tsdb_head_series[2h])), "prometheus", "$1", "instance", "(.+)")'
          joins:
            - labels:
                "":
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 229
                        end: 231
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 177
                        end: 241
                instance:
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 229
                        end: 231
              operation: max
              returns: vector
              operations:
                - '[*parser.VectorSelector] prometheus_tsdb_head_series'
                - '[*parser.Call] max_over_time(prometheus_tsdb_head_series[2h])'
                - '[*parser.AggregateExpr] max by (instance) (max_over_time(prometheus_tsdb_head_series[2h]))'
              joins: []
              unless: []
              deadinfo: null
              position:
                start: 195
                end: 226
              returnednumber: 0
              type: 5
              fixedlabels: true
              alwaysreturns: false
              knownreturn: false
              isconditional: false
              isreturnbool: false
          unless: []
          deadinfo: null
          position:
            start: 92
            end: 241
          returnednumber: 0
          type: 4
          fixedlabels: true
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 1
        end: 44
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/147 - 1]
expr: (day_of_week() == 6 and hour() < 1) or vector(1)
output:
    - labels:
        "":
            reason: Calling `day_of_week()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 14
      operation: day_of_week
      returns: vector
      operations:
        - '[*parser.Call] day_of_week()'
      joins:
        - labels:
            "":
                reason: Calling `hour()` with no arguments will return an empty time series with no labels.
                kind: excluded
                fragment:
                    start: 24
                    end: 30
          operation: hour
          returns: vector
          operations:
            - '[*parser.Call] hour()'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 24
            end: 30
          returnednumber: 0
          type: 4
          fixedlabels: true
          alwaysreturns: true
          knownreturn: false
          isconditional: true
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 1
        end: 14
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: false
      isconditional: true
      isreturnbool: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 39
                end: 45
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 39
        end: 48
      returnednumber: 1
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/148 - 1]
expr: |4-
    sum by (foo, bar) (
        rate(errors_total[5m])
      * on (instance) group_left (bob, alice)
        server_errors_total
    )
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 115
        alice:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        bar:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        bob:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        foo:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        instance:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] errors_total'
        - '[*parser.Call] rate(errors_total[5m])'
        - '[*parser.AggregateExpr] sum by (foo, bar) (rate(errors_total[5m]) * on (instance) group_left (bob, alice) server_errors_total)'
      joins:
        - labels: {}
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] server_errors_total'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 94
            end: 113
          returnednumber: 0
          type: 3
          fixedlabels: false
          alwaysreturns: false
          knownreturn: false
          isconditional: false
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 30
        end: 46
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/149 - 1]
expr: 1 - (foo or vector(0)) < 0.999
output:
    - labels: {}
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 5
        end: 8
      returnednumber: 0
      type: 3
      fixedlabels: false
      alwaysreturns: false
      knownreturn: false
      isconditional: true
      isreturnbool: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 12
                end: 18
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
      joins: []
      unless: []
      deadinfo:
        reason: this query always evaluates to `1 < 0.999` which is not possible, so it will never return anything
        fragment:
            start: 12
            end: 21
      position:
        start: 12
        end: 21
      returnednumber: 1
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: false

---

[TestLabelsSource/150 - 1]
expr: |4
    (
      vector(1) and month() == 2
    ) or vector(0)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 5
                end: 11
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
      joins:
        - labels:
            "":
                reason: Calling `month()` with no arguments will return an empty time series with no labels.
                kind: excluded
                fragment:
                    start: 19
                    end: 26
          operation: month
          returns: vector
          operations:
            - '[*parser.Call] month()'
          joins: []
          unless: []
          deadinfo: null
          position:
            start: 19
            end: 26
          returnednumber: 0
          type: 4
          fixedlabels: true
          alwaysreturns: true
          knownreturn: false
          isconditional: true
          isreturnbool: false
      unless: []
      deadinfo: null
      position:
        start: 5
        end: 14
      returnednumber: 1
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: true
      isreturnbool: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 37
                end: 43
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 37
        end: 46
      returnednumber: 0
      type: 4
      fixedlabels: true
      alwaysreturns: true
      knownreturn: true
      isconditional: false
      isreturnbool: false

---

[TestLabelsSource/151 - 1]
expr: count by (region) (stddev by (colo_name, region) (error_total))
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 9
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 63
        colo_name:
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 9
        region:
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 6
                end: 9
      operation: count
      returns: vector
      operations:
        - '[*parser.VectorSelector] error_total'
        - '[*parser.AggregateExpr] stddev by (colo_name, region) (error_total)'
        - '[*parser.AggregateExpr] count by (region) (stddev by (colo_name, region) (error_total))'
      joins: []
      unless: []
      deadinfo: null
      position:
        start: 50
        end: 61
      returnednumber: 0
      type: 5
      fixedlabels: true
      alwaysreturns: false
      knownreturn: false
      isconditional: false
      isreturnbool: false

---
