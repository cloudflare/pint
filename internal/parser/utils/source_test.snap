
[TestLabelsSource/1 - 1]
expr: "1"
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo: null
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/2 - 1]
expr: 1 / 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo: null
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 1 / 5
        valueposition:
            start: 0
            end: 1
        returnednumber: 0.2
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/3 - 1]
expr: (2 ^ 5) == bool 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo:
        reason: '`2 ^ 5 == 5` always evaluates to `32 == 5` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 32
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/4 - 1]
expr: (2 ^ 5 + 11) % 5 <= bool 2
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo:
        reason: '`2 ^ 5 + 11 % 5 <= 2` always evaluates to `3 <= 2` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/5 - 1]
expr: (2 ^ 5 + 11) % 5 >= bool 20
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo:
        reason: '`2 ^ 5 + 11 % 5 >= 20` always evaluates to `3 >= 20` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/6 - 1]
expr: (2 ^ 5 + 11) % 5 <= bool 3
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo: null
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/7 - 1]
expr: (2 ^ 5 + 11) % 5 < bool 1
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo:
        reason: '`2 ^ 5 + 11 % 5 < 1` always evaluates to `3 < 1` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/8 - 1]
expr: 20 - 15 < bool 1
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 2
      deadinfo:
        reason: '`20 - 15 < 1` always evaluates to `5 < 1` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 0
            end: 2
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 20 - 15
        valueposition:
            start: 0
            end: 2
        returnednumber: 5
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/9 - 1]
expr: 2 * 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo: null
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 * 5
        valueposition:
            start: 0
            end: 1
        returnednumber: 10
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/10 - 1]
expr: (foo or bar) * 5
output:
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 11
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/11 - 1]
expr: (foo or vector(2)) * 5
output:
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 8
                end: 14
      deadinfo: null
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(2)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: vector(2) * 5
        valueposition:
            start: 8
            end: 17
        returnednumber: 10
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 8
        end: 17
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/12 - 1]
expr: (foo or vector(5)) * (vector(2) or bar)
output:
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 22
                        end: 28
            deadinfo: null
            operation: vector
            returns: vector
            operations:
                - '[*parser.Call] vector(2)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 22
                    end: 31
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 22
                end: 31
            type: function
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
        - src:
            labels: {}
            deadinfo:
                reason: The left hand side always returs something and so the right hand side is never used.
                fragment:
                    start: 35
                    end: 38
            operation: many-to-many
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 35
                end: 38
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 8
                end: 14
      deadinfo: null
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(5)'
      joins:
        - src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 22
                        end: 28
            deadinfo: null
            operation: vector
            returns: vector
            operations:
                - '[*parser.Call] vector(2)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 22
                    end: 31
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 22
                end: 31
            type: function
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
        - src:
            labels: {}
            deadinfo:
                reason: The left hand side always returs something and so the right hand side is never used.
                fragment:
                    start: 35
                    end: 38
            operation: many-to-many
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 35
                end: 38
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: vector(5) * vector(2)
        valueposition:
            start: 8
            end: 17
        returnednumber: 10
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 8
        end: 17
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/13 - 1]
expr: 1 > bool 0
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo: null
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/14 - 1]
expr: 20 > bool 10
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 2
      deadinfo: null
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 2
        returnednumber: 20
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/15 - 1]
expr: '"test"'
output:
    - labels:
        "":
            reason: This query returns a string value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      operation: ""
      returns: string
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 6
      type: string
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/16 - 1]
expr: foo
output:
    - labels: {}
      deadinfo: null
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/17 - 1]
expr: (foo > 1) > bool 1
output:
    - labels: {}
      deadinfo: null
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/18 - 1]
expr: foo > bool 5
output:
    - labels: {}
      deadinfo: null
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/19 - 1]
expr: foo > bool 5 == 1
output:
    - labels: {}
      deadinfo: null
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/20 - 1]
expr: foo > bool bar
output:
    - labels: {}
      deadinfo: null
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 11
                end: 14
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/21 - 1]
expr: (foo > bool bar) == 0
output:
    - labels: {}
      deadinfo: null
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 12
                end: 15
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/22 - 1]
expr: foo > bool on(instance) bar
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 11
                end: 13
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 13
      deadinfo: null
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 24
                end: 27
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/23 - 1]
expr: (foo > bool on(instance) bar) == 1
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 12
                end: 14
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 12
                end: 14
      deadinfo: null
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 25
                end: 28
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/24 - 1]
expr: foo > bool on(instance) group_left(version) bar
output:
    - labels:
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 13
        version:
            reason: Query is using many-to-one vector matching with `group_left(version)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 24
                end: 34
      deadinfo: null
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 44
                end: 47
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/25 - 1]
expr: bar > bool on(instance) group_right(version) foo
output:
    - labels:
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 13
        version:
            reason: Query is using one-to-many vector matching with `group_right(version)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 24
                end: 35
      deadinfo: null
      operation: one-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 3
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 45
        end: 48
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/26 - 1]
expr: foo and bar > bool 0
output:
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: true
            position:
                start: 8
                end: 11
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/27 - 1]
expr: foo offset 5m
output:
    - labels: {}
      deadinfo: null
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo offset 5m'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 13
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/28 - 1]
expr: foo{job="bar"}
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="bar"}'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/29 - 1]
expr: foo{job=""}
output:
    - labels:
        job:
            reason: Query uses `{job=""}` selector which will filter out any time series with the `job` label set.
            kind: excluded
            fragment:
                start: 0
                end: 11
      deadinfo: null
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job=""}'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 11
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/30 - 1]
expr: foo{job="bar"} or bar{job="foo"}
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="bar"}'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 18
                end: 32
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{job="foo"}'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 18
        end: 32
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/31 - 1]
expr: foo{a="bar"} or bar{b="foo"}
output:
    - labels:
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 12
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{a="bar"}'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 12
      type: selector
      fixedlabels: false
      isconditional: false
    - labels:
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 16
                end: 28
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{b="foo"}'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 16
        end: 28
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/32 - 1]
expr: foo[5m]
output:
    - labels: {}
      deadinfo: null
      operation: ""
      returns: matrix
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/33 - 1]
expr: prometheus_build_info[2m:1m]
output:
    - labels: {}
      deadinfo: null
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] prometheus_build_info'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 21
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/34 - 1]
expr: deriv(rate(distance_covered_meters_total[1m])[5m:1m])
output:
    - labels: {}
      deadinfo: null
      operation: deriv
      returns: vector
      operations:
        - '[*parser.VectorSelector] distance_covered_meters_total'
        - '[*parser.Call] rate(distance_covered_meters_total[1m])'
        - '[*parser.Call] deriv(rate(distance_covered_meters_total[1m])[5m:1m])'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 52
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/35 - 1]
expr: foo - 1
output:
    - labels: {}
      deadinfo: null
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/36 - 1]
expr: foo / 5
output:
    - labels: {}
      deadinfo: null
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/37 - 1]
expr: -foo
output:
    - labels: {}
      deadinfo: null
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/38 - 1]
expr: sum(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] sum(foo{job="myjob"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/39 - 1]
expr: sum(count(foo{job="myjob"}) by(instance))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 41
        instance:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        job:
            reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 28
                end: 30
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] count by (instance) (foo{job="myjob"})'
        - '[*parser.AggregateExpr] sum(count by (instance) (foo{job="myjob"}))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 10
        end: 26
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/40 - 1]
expr: sum(foo{job="myjob"}) > 20
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] sum(foo{job="myjob"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/41 - 1]
expr: sum(foo{job="myjob"}) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 22
                end: 29
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] sum without (job) (foo{job="myjob"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/42 - 1]
expr: sum(foo) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 9
                end: 11
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 16
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 9
                end: 11
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum by (job) (foo)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 7
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/43 - 1]
expr: sum(foo{job="myjob"}) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 22
                end: 24
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 29
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] sum by (job) (foo{job="myjob"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/44 - 1]
expr: abs(foo{job="myjob"} offset 5m)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 31
      deadinfo: null
      operation: abs
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"} offset 5m'
        - '[*parser.Call] abs(foo{job="myjob"} offset 5m)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 30
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/45 - 1]
expr: abs(foo{job="myjob"} or bar{cluster="dev"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 43
      deadinfo: null
      operation: abs
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.Call] abs(foo{job="myjob"} or bar{cluster="dev"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 42
      type: function
      fixedlabels: false
      isconditional: false
    - labels:
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 43
      deadinfo: null
      operation: abs
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{cluster="dev"}'
        - '[*parser.Call] abs(foo{job="myjob"} or bar{cluster="dev"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 42
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/46 - 1]
expr: sum(foo{job="myjob"} or bar{cluster="dev"}) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 61
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 44
                end: 51
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"} or bar{cluster="dev"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: false
      isconditional: false
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 61
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 24
                end: 42
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 44
                end: 51
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{cluster="dev"}'
        - '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"} or bar{cluster="dev"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 42
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/47 - 1]
expr: sum(foo{job="myjob"}) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 39
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 22
                end: 29
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/48 - 1]
expr: min(foo{job="myjob"}) / max(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo: null
      operation: min
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] min(foo{job="myjob"})'
      joins:
        - src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
                job:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
            deadinfo: null
            operation: max
            returns: vector
            operations:
                - '[*parser.VectorSelector] foo{job="myjob"}'
                - '[*parser.AggregateExpr] max(foo{job="myjob"})'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 28
                end: 44
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/49 - 1]
expr: max(foo{job="myjob"}) / min(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo: null
      operation: max
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] max(foo{job="myjob"})'
      joins:
        - src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
                job:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
            deadinfo: null
            operation: min
            returns: vector
            operations:
                - '[*parser.VectorSelector] foo{job="myjob"}'
                - '[*parser.AggregateExpr] min(foo{job="myjob"})'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 28
                end: 44
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/50 - 1]
expr: avg(foo{job="myjob"}) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 22
                end: 24
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 29
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      deadinfo: null
      operation: avg
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] avg by (job) (foo{job="myjob"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/51 - 1]
expr: group(foo) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 11
                end: 13
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 18
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 13
      deadinfo: null
      operation: group
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] group by (job) (foo)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 9
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/52 - 1]
expr: stddev(rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo: null
      operation: stddev
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] rate(foo[5m])'
        - '[*parser.AggregateExpr] stddev(rate(foo[5m]))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 12
        end: 19
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/53 - 1]
expr: stdvar(rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo: null
      operation: stdvar
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] rate(foo[5m])'
        - '[*parser.AggregateExpr] stdvar(rate(foo[5m]))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 12
        end: 19
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/54 - 1]
expr: stddev_over_time(foo[5m])
output:
    - labels: {}
      deadinfo: null
      operation: stddev_over_time
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] stddev_over_time(foo[5m])'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 17
        end: 24
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/55 - 1]
expr: stdvar_over_time(foo[5m])
output:
    - labels: {}
      deadinfo: null
      operation: stdvar_over_time
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] stdvar_over_time(foo[5m])'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 17
        end: 24
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/56 - 1]
expr: quantile(0.9, rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 28
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 28
      deadinfo: null
      operation: quantile
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] rate(foo[5m])'
        - '[*parser.AggregateExpr] quantile(0.9, rate(foo[5m]))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 19
        end: 26
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/57 - 1]
expr: count_values("version", build_version)
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 38
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 38
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
      deadinfo: null
      operation: count_values
      returns: vector
      operations:
        - '[*parser.VectorSelector] build_version'
        - '[*parser.AggregateExpr] count_values("version", build_version)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 37
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/58 - 1]
expr: count_values("version", build_version) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 51
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 39
                end: 46
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 51
      deadinfo: null
      operation: count_values
      returns: vector
      operations:
        - '[*parser.VectorSelector] build_version'
        - '[*parser.AggregateExpr] count_values without (job) ("version", build_version)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 37
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/59 - 1]
expr: count_values("version", build_version{job="foo"}) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 62
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 50
                end: 57
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 62
      deadinfo: null
      operation: count_values
      returns: vector
      operations:
        - '[*parser.VectorSelector] build_version{job="foo"}'
        - '[*parser.AggregateExpr] count_values without (job) ("version", build_version{job="foo"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 48
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/60 - 1]
expr: count_values("version", build_version) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 39
                end: 41
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 46
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 39
                end: 41
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 46
      deadinfo: null
      operation: count_values
      returns: vector
      operations:
        - '[*parser.VectorSelector] build_version'
        - '[*parser.AggregateExpr] count_values by (job) ("version", build_version)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 37
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/61 - 1]
expr: topk(10, foo{job="myjob"}) > 10
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 9
                end: 25
      deadinfo: null
      operation: topk
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] topk(10, foo{job="myjob"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 25
      type: aggregation
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/62 - 1]
expr: topk(10, foo or bar)
output:
    - labels: {}
      deadinfo: null
      operation: topk
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] topk(10, foo or bar)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 12
      type: aggregation
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      operation: topk
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar'
        - '[*parser.AggregateExpr] topk(10, foo or bar)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 16
        end: 19
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/63 - 1]
expr: rate(foo[10m])
output:
    - labels: {}
      deadinfo: null
      operation: rate
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] rate(foo[10m])'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 13
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/64 - 1]
expr: sum(rate(foo[10m])) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 37
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 20
                end: 27
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] rate(foo[10m])'
        - '[*parser.AggregateExpr] sum without (instance) (rate(foo[10m]))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 17
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/65 - 1]
expr: foo{job="foo"} / bar
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="foo"}'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 17
                end: 20
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/66 - 1]
expr: foo{job="foo"} * on(instance) bar
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 17
                end: 19
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 17
                end: 19
        job:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 17
                end: 19
      deadinfo: null
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="foo"}'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 30
                end: 33
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/67 - 1]
expr: foo{job="foo"} * on(instance) group_left(bar) bar
output:
    - labels:
        bar:
            reason: Query is using many-to-one vector matching with `group_left(bar)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 30
                end: 40
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 17
                end: 19
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="foo"}'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 46
                end: 49
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/68 - 1]
expr: foo{job="foo"} * on(instance) group_left(cluster) bar{cluster="bar", ignored="true"}
output:
    - labels:
        cluster:
            reason: Query is using many-to-one vector matching with `group_left(cluster)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 30
                end: 40
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 17
                end: 19
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="foo"}'
      joins:
        - src:
            labels:
                cluster:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 50
                        end: 84
                ignored:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 50
                        end: 84
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar{cluster="bar",ignored="true"}'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 50
                end: 84
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/69 - 1]
expr: foo{job="foo", ignored="true"} * on(instance) group_right(job) bar{cluster="bar"}
output:
    - labels:
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 63
                end: 81
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 33
                end: 35
        job:
            reason: Query is using one-to-many vector matching with `group_right(job)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 46
                end: 57
      deadinfo: null
      operation: one-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{cluster="bar"}'
      joins:
        - src:
            labels:
                ignored:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 0
                        end: 30
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 0
                        end: 30
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] foo{ignored="true",job="foo"}'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 30
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 63
        end: 81
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/70 - 1]
expr: count(foo / bar)
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 16
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 16
      deadinfo: null
      operation: count
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] count(foo / bar)'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 12
                end: 15
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 1
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 9
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/71 - 1]
expr: count(up{job="a"} / on () up{job="b"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 38
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 38
        job:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 20
                end: 23
      deadinfo: null
      operation: count
      returns: vector
      operations:
        - '[*parser.VectorSelector] up{job="a"}'
        - '[*parser.AggregateExpr] count(up{job="a"} / on () up{job="b"})'
      joins:
        - src:
            labels:
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 26
                        end: 37
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] up{job="b"}'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 26
                end: 37
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 1
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 17
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/72 - 1]
expr: count(up{job="a"} / on (env) up{job="b"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 41
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 41
        env:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 41
        job:
            reason: Query is using one-to-one vector matching with `on(env)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 20
                end: 23
      deadinfo: null
      operation: count
      returns: vector
      operations:
        - '[*parser.VectorSelector] up{job="a"}'
        - '[*parser.AggregateExpr] count(up{job="a"} / on (env) up{job="b"})'
      joins:
        - src:
            labels:
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 29
                        end: 40
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] up{job="b"}'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 29
                end: 40
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 1
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 17
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/73 - 1]
expr: foo{job="foo", instance="1"} and bar
output:
    - labels:
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{instance="1",job="foo"}'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 33
                end: 36
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 28
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/74 - 1]
expr: foo{job="foo", instance="1"} and on(cluster) bar
output:
    - labels:
        cluster:
            reason: Query is using many-to-many vector matching with `on(cluster)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 33
                end: 35
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{instance="1",job="foo"}'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 45
                end: 48
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 28
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/75 - 1]
expr: topk(10, foo)
output:
    - labels: {}
      deadinfo: null
      operation: topk
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] topk(10, foo)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 12
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/76 - 1]
expr: topk(10, foo) without(cluster)
output:
    - labels: {}
      deadinfo: null
      operation: topk
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] topk without (cluster) (10, foo)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 12
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/77 - 1]
expr: topk(10, foo) by(cluster)
output:
    - labels: {}
      deadinfo: null
      operation: topk
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] topk by (cluster) (10, foo)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 12
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/78 - 1]
expr: bottomk(10, sum(rate(foo[5m])) without(job))
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 12
                end: 43
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 31
                end: 38
      deadinfo: null
      operation: bottomk
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] rate(foo[5m])'
        - '[*parser.AggregateExpr] sum without (job) (rate(foo[5m]))'
        - '[*parser.AggregateExpr] bottomk(10, sum without (job) (rate(foo[5m])))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 21
        end: 28
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/79 - 1]
expr: foo or bar
output:
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/80 - 1]
expr: foo or bar or baz
output:
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] baz'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 17
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/81 - 1]
expr: (foo or bar) or baz
output:
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 11
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] baz'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 16
        end: 19
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/82 - 1]
expr: foo unless bar
output:
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless:
        - labels: {}
          deadinfo: null
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          returninfo:
            logicalexpr: ""
            valueposition:
                start: 0
                end: 0
            returnednumber: 0
            alwaysreturns: false
            knownreturn: false
            isreturnbool: false
          position:
            start: 11
            end: 14
          type: selector
          fixedlabels: false
          isconditional: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/83 - 1]
expr: foo unless bar > 5
output:
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless:
        - labels: {}
          deadinfo: null
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          returninfo:
            logicalexpr: ""
            valueposition:
                start: 0
                end: 0
            returnednumber: 0
            alwaysreturns: false
            knownreturn: false
            isreturnbool: false
          position:
            start: 11
            end: 14
          type: selector
          fixedlabels: false
          isconditional: true
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/84 - 1]
expr: foo unless bar unless baz
output:
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless:
        - labels: {}
          deadinfo: null
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] bar'
          joins: []
          unless: []
          returninfo:
            logicalexpr: ""
            valueposition:
                start: 0
                end: 0
            returnednumber: 0
            alwaysreturns: false
            knownreturn: false
            isreturnbool: false
          position:
            start: 11
            end: 14
          type: selector
          fixedlabels: false
          isconditional: false
        - labels: {}
          deadinfo: null
          operation: ""
          returns: vector
          operations:
            - '[*parser.VectorSelector] baz'
          joins: []
          unless: []
          returninfo:
            logicalexpr: ""
            valueposition:
                start: 0
                end: 0
            returnednumber: 0
            alwaysreturns: false
            knownreturn: false
            isreturnbool: false
          position:
            start: 22
            end: 25
          type: selector
          fixedlabels: false
          isconditional: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/85 - 1]
expr: count(sum(up{job="foo", cluster="dev"}) by(job, cluster) == 0) without(job, cluster)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 40
                end: 42
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 84
        cluster:
            reason: Query is using aggregation with `without(job, cluster)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 63
                end: 70
        job:
            reason: Query is using aggregation with `without(job, cluster)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 63
                end: 70
      deadinfo: null
      operation: count
      returns: vector
      operations:
        - '[*parser.VectorSelector] up{cluster="dev",job="foo"}'
        - '[*parser.AggregateExpr] sum by (job, cluster) (up{cluster="dev",job="foo"})'
        - '[*parser.AggregateExpr] count without (job, cluster) (sum by (job, cluster) (up{cluster="dev",job="foo"}) == 0)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 10
        end: 38
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/86 - 1]
expr: year()
output:
    - labels:
        "":
            reason: Calling `year()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      operation: year
      returns: vector
      operations:
        - '[*parser.Call] year()'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 6
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/87 - 1]
expr: year(foo)
output:
    - labels: {}
      deadinfo: null
      operation: year
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] year(foo)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/88 - 1]
expr: label_join(up{job="api-server",src1="a",src2="b",src3="c"}, "foo", ",", "src1", "src2", "src3")
output:
    - labels:
        foo:
            reason: This label will be added to the result by label_join() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 95
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src1:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src2:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src3:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
      deadinfo: null
      operation: label_join
      returns: vector
      operations:
        - '[*parser.VectorSelector] up{job="api-server",src1="a",src2="b",src3="c"}'
        - '[*parser.Call] label_join(up{job="api-server",src1="a",src2="b",src3="c"}, "foo", ",", "src1", "src2", "src3")'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 11
        end: 58
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/89 - 1]
expr: |4-
    (
     sum(foo:sum > 0) without(notify)
     * on(job) group_left(notify)
     job:notify
    )
    and on(job)
    sum(foo:count) by(job) > 20
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 4
                end: 36
        job:
            reason: Query is using many-to-many vector matching with `on(job)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 40
                end: 42
        notify:
            reason: Query is using many-to-one vector matching with `group_left(notify)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 48
                end: 58
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo:sum'
        - '[*parser.AggregateExpr] sum without (notify) (foo:sum > 0)'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] job:notify'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 68
                end: 78
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
        - src:
            labels:
                "":
                    reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 108
                        end: 110
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 93
                        end: 115
                job:
                    reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 108
                        end: 110
            deadinfo: null
            operation: sum
            returns: vector
            operations:
                - '[*parser.VectorSelector] foo:count'
                - '[*parser.AggregateExpr] sum by (job) (foo:count)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 97
                end: 106
            type: aggregation
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 15
      type: aggregation
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/90 - 1]
expr: container_file_descriptors / on (instance, app_name) container_ulimits_soft{ulimit="max_open_files"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 29
                end: 32
        app_name:
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 29
                end: 32
        instance:
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 29
                end: 32
      deadinfo: null
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] container_file_descriptors'
      joins:
        - src:
            labels:
                ulimit:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 53
                        end: 100
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] container_ulimits_soft{ulimit="max_open_files"}'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 53
                end: 100
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 26
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/91 - 1]
expr: container_file_descriptors / on (instance, app_name) group_left() container_ulimits_soft{ulimit="max_open_files"}
output:
    - labels:
        app_name:
            reason: Query is using many-to-one vector matching with `on(instance, app_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 29
                end: 32
        instance:
            reason: Query is using many-to-one vector matching with `on(instance, app_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 29
                end: 32
      deadinfo: null
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] container_file_descriptors'
      joins:
        - src:
            labels:
                ulimit:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 66
                        end: 113
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] container_ulimits_soft{ulimit="max_open_files"}'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 66
                end: 113
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 26
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/92 - 1]
expr: absent(foo{job="bar"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 22
      deadinfo: null
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="bar"}'
        - '[*parser.Call] absent(foo{job="bar"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 21
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/93 - 1]
expr: absent(foo{job="bar", cluster!="dev", instance=~".+", env="prod"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        env:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 66
        instance:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 66
      deadinfo: null
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{cluster!="dev",env="prod",instance=~".+",job="bar"}'
        - '[*parser.Call] absent(foo{cluster!="dev",env="prod",instance=~".+",job="bar"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 65
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/94 - 1]
expr: absent(sum(foo) by(job, instance))
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 7
                end: 33
        instance:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum by (job, instance) (foo)'
        - '[*parser.Call] absent(sum by (job, instance) (foo))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 33
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/95 - 1]
expr: absent(foo{job="prometheus", xxx="1"}) AND on(job) prometheus_build_info
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
        xxx:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
      deadinfo: null
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="prometheus",xxx="1"}'
        - '[*parser.Call] absent(foo{job="prometheus",xxx="1"})'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] prometheus_build_info'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 51
                end: 72
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 37
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/96 - 1]
expr: 1 + sum(foo) by(notjob)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(notjob)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 4
                end: 23
        notjob:
            reason: Query is using aggregation with `by(notjob)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum by (notjob) (foo)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 11
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/97 - 1]
expr: count(node_exporter_build_info) by (instance, version) != ignoring(package,version) group_left(foo) count(deb_package_version) by (instance, version, package)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 32
                end: 35
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 54
        foo:
            reason: Query is using many-to-one vector matching with `group_left(foo)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 84
                end: 94
        instance:
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 32
                end: 35
        version:
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 32
                end: 35
      deadinfo: null
      operation: count
      returns: vector
      operations:
        - '[*parser.VectorSelector] node_exporter_build_info'
        - '[*parser.AggregateExpr] count by (instance, version) (node_exporter_build_info)'
      joins:
        - src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 127
                        end: 130
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 100
                        end: 158
                instance:
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 127
                        end: 130
                package:
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 127
                        end: 130
                version:
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 127
                        end: 130
            deadinfo: null
            operation: count
            returns: vector
            operations:
                - '[*parser.VectorSelector] deb_package_version'
                - '[*parser.AggregateExpr] count by (instance, version, package) (deb_package_version)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 106
                end: 125
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57396
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 30
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/98 - 1]
expr: absent(foo) or absent(bar)
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] absent(foo)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 10
      type: function
      fixedlabels: true
      isconditional: false
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 15
                end: 21
      deadinfo: null
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar'
        - '[*parser.Call] absent(bar)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 22
        end: 25
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/99 - 1]
expr: absent_over_time(foo[5m]) or absent(bar)
output:
    - labels:
        "":
            reason: |-
                The [absent_over_time()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent_over_time) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 16
      deadinfo: null
      operation: absent_over_time
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.Call] absent_over_time(foo[5m])'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 17
        end: 24
      type: function
      fixedlabels: true
      isconditional: false
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 29
                end: 35
      deadinfo: null
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar'
        - '[*parser.Call] absent(bar)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 36
        end: 39
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/100 - 1]
expr: bar * on() group_right(cluster, env) absent(foo{job="xxx"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 37
                end: 43
        cluster:
            reason: Query is using one-to-many vector matching with `group_right(cluster, env)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 11
                end: 22
        env:
            reason: Query is using one-to-many vector matching with `group_right(cluster, env)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 11
                end: 22
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 37
                end: 59
      deadinfo: null
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="xxx"}'
        - '[*parser.Call] absent(foo{job="xxx"})'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 3
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 44
        end: 58
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/101 - 1]
expr: bar * on() group_right() absent(foo{job="xxx"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 25
                end: 31
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 25
                end: 47
      deadinfo: null
      operation: absent
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="xxx"}'
        - '[*parser.Call] absent(foo{job="xxx"})'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 3
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 32
        end: 46
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/102 - 1]
expr: vector(1)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/103 - 1]
expr: vector(scalar(foo))
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(scalar(foo))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 19
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 19
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/104 - 1]
expr: vector(0.0  >= bool 0.5) == 1
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo:
        reason: '`vector(0.0  >= bool 0.5) == 1` always evaluates to `0 == 1` which is not possible, so it will never return anything.'
        fragment:
            start: 0
            end: 24
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(0 >= bool 0.5)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 24
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 24
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/105 - 1]
expr: sum_over_time(foo{job="myjob"}[5m])
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 35
      deadinfo: null
      operation: sum_over_time
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.Call] sum_over_time(foo{job="myjob"}[5m])'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 34
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/106 - 1]
expr: days_in_month()
output:
    - labels:
        "":
            reason: Calling `days_in_month()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 15
      deadinfo: null
      operation: days_in_month
      returns: vector
      operations:
        - '[*parser.Call] days_in_month()'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 15
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/107 - 1]
expr: days_in_month(foo{job="foo"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 29
      deadinfo: null
      operation: days_in_month
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="foo"}'
        - '[*parser.Call] days_in_month(foo{job="foo"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 28
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/108 - 1]
expr: label_replace(up{job="api-server",service="a:c"}, "foo", "$1", "service", "(.*):.*")
output:
    - labels:
        foo:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 84
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 14
                end: 48
        service:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 14
                end: 48
      deadinfo: null
      operation: label_replace
      returns: vector
      operations:
        - '[*parser.VectorSelector] up{job="api-server",service="a:c"}'
        - '[*parser.Call] label_replace(up{job="api-server",service="a:c"}, "foo", "$1", "service", "(.*):.*")'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 48
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/109 - 1]
expr: label_replace(sum by (pod) (pod_status) > 0, "cluster", "$1", "pod", "(.*)")
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 18
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 14
                end: 39
        cluster:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 76
        pod:
            reason: Query is using aggregation with `by(pod)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 18
                end: 21
      deadinfo: null
      operation: label_replace
      returns: vector
      operations:
        - '[*parser.VectorSelector] pod_status'
        - '[*parser.AggregateExpr] sum by (pod) (pod_status)'
        - '[*parser.Call] label_replace(sum by (pod) (pod_status) > 0, "cluster", "$1", "pod", "(.*)")'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 43
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/110 - 1]
expr: (time() - my_metric) > 5*3600
output:
    - labels: {}
      deadinfo: null
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] my_metric'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 10
        end: 19
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/111 - 1]
expr: up{instance="a", job="prometheus"} * ignoring(job) up{instance="a", job="pint"}
output:
    - labels:
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using one-to-one vector matching with `ignoring(job)`, all labels included inside `ignoring(...)` will be removed on the results.
            kind: excluded
            fragment:
                start: 37
                end: 45
      deadinfo: null
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] up{instance="a",job="prometheus"}'
      joins:
        - src:
            labels:
                instance:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 51
                        end: 79
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 51
                        end: 79
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] up{instance="a",job="pint"}'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 51
                end: 79
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 34
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/112 - 1]
expr: |4
    avg without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"})
    < 0.5 > 0
    or sum without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"})
    < on() count(colo_router_tier:disabled_pops:max{tier="1",router=~"edge.*"}) * 0.4 > 0
    or avg without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"})
    < 0.1 > 0
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 101
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 5
                end: 12
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 5
                end: 12
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 5
                end: 12
      deadinfo: null
      operation: avg
      returns: vector
      operations:
        - '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"}'
        - '[*parser.AggregateExpr] avg without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 41
        end: 100
      type: aggregation
      fixedlabels: false
      isconditional: true
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 216
                end: 218
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 115
                end: 213
        cidr_use_case:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 216
                end: 218
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 119
                end: 126
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 119
                end: 126
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 119
                end: 126
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"}'
        - '[*parser.AggregateExpr] sum without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"})'
      joins:
        - src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 289
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 289
                router:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 289
                tier:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 289
            deadinfo: null
            operation: count
            returns: vector
            operations:
                - '[*parser.VectorSelector] colo_router_tier:disabled_pops:max{router=~"edge.*",tier="1"}'
                - '[*parser.AggregateExpr] count(colo_router_tier:disabled_pops:max{router=~"edge.*",tier="1"})'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 227
                end: 288
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57391
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 155
        end: 212
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 303
                end: 404
        cidr_use_case:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 343
                end: 403
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 307
                end: 314
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 307
                end: 314
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 307
                end: 314
      deadinfo: null
      operation: avg
      returns: vector
      operations:
        - '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"}'
        - '[*parser.AggregateExpr] avg without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 343
        end: 403
      type: aggregation
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/113 - 1]
expr: label_replace(sum(foo) without(instance), "instance", "none", "", "")
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 14
                end: 40
        instance:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 69
      deadinfo: null
      operation: label_replace
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum without (instance) (foo)'
        - '[*parser.Call] label_replace(sum without (instance) (foo), "instance", "none", "", "")'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 40
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/114 - 1]
expr: |4-
    sum by (region, target, colo_name) (
        sum_over_time(probe_success{job="abc"}[5m])
     or
     vector(1)
    ) == 0
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 102
        colo_name:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        job:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        region:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        target:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] probe_success{job="abc"}'
        - '[*parser.Call] sum_over_time(probe_success{job="abc"}[5m])'
        - '[*parser.AggregateExpr] sum by (region, target, colo_name) (sum_over_time(probe_success{job="abc"}[5m]) or vector(1))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 56
        end: 84
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 102
        colo_name:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
        region:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
        target:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
      deadinfo:
        reason: '`vector(1) == 0` always evaluates to `1 == 0` which is not possible, so it will never return anything.'
        fragment:
            start: 91
            end: 100
      operation: sum
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
        - '[*parser.AggregateExpr] sum by (region, target, colo_name) (sum_over_time(probe_success{job="abc"}[5m]) or vector(1))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 91
            end: 100
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 91
        end: 100
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/115 - 1]
expr: vector(1) or foo
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedlabels: true
      isconditional: false
    - labels: {}
      deadinfo:
        reason: The left hand side always returs something and so the right hand side is never used.
        fragment:
            start: 13
            end: 16
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 13
        end: 16
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/116 - 1]
expr: vector(0) > 0
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo:
        reason: '`vector(0) > 0` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 0
            end: 9
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/117 - 1]
expr: vector(0) > vector(1)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo:
        reason: '`vector(0) > vector(1)` always evaluates to `0 > 1` which is not possible, so it will never return anything.'
        fragment:
            start: 0
            end: 9
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
      joins:
        - src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 12
                        end: 18
            deadinfo: null
            operation: vector
            returns: vector
            operations:
                - '[*parser.Call] vector(1)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 12
                    end: 21
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 12
                end: 21
            type: function
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/118 - 1]
expr: sum(foo or vector(0)) > 0
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum(foo or vector(0))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 7
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo:
        reason: '`vector(0) > 0` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 11
            end: 20
      operation: sum
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
        - '[*parser.AggregateExpr] sum(foo or vector(0))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 11
            end: 20
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 11
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/119 - 1]
expr: (sum(foo or vector(1)) > 0) == 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum(foo or vector(1))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo:
        reason: '`vector(1) == 2` always evaluates to `1 == 2` which is not possible, so it will never return anything.'
        fragment:
            start: 12
            end: 21
      operation: sum
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
        - '[*parser.AggregateExpr] sum(foo or vector(1))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 12
            end: 21
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/120 - 1]
expr: (sum(foo or vector(1)) > 0) != 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum(foo or vector(1))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
        - '[*parser.AggregateExpr] sum(foo or vector(1))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 12
            end: 21
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/121 - 1]
expr: (sum(foo or vector(2)) > 0) != 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum(foo or vector(2))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo:
        reason: '`vector(2) != 2` always evaluates to `2 != 2` which is not possible, so it will never return anything.'
        fragment:
            start: 12
            end: 21
      operation: sum
      returns: vector
      operations:
        - '[*parser.Call] vector(2)'
        - '[*parser.AggregateExpr] sum(foo or vector(2))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 12
            end: 21
        returnednumber: 2
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/122 - 1]
expr: |-
    (sum(sometimes{foo!="bar"} or vector(0)))
    or
    ((bob > 10) or sum(foo) or vector(1))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 41
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] sometimes{foo!="bar"}'
        - '[*parser.AggregateExpr] sum(sometimes{foo!="bar"} or vector(0))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 26
      type: aggregation
      fixedlabels: true
      isconditional: false
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 41
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
        - '[*parser.AggregateExpr] sum(sometimes{foo!="bar"} or vector(0))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 30
            end: 39
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 30
        end: 39
      type: aggregation
      fixedlabels: true
      isconditional: false
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bob'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 47
        end: 50
      type: selector
      fixedlabels: false
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 60
                end: 63
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 60
                end: 68
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum(foo)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 64
        end: 67
      type: aggregation
      fixedlabels: true
      isconditional: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 72
                end: 78
      deadinfo: null
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 72
            end: 81
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 72
        end: 81
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/123 - 1]
expr: |4-
    (
     sum(sometimes{foo!="bar"})
     or
     vector(1)
    ) and (
     ((bob > 10) or sum(bar))
     or
     notfound > 0
    )
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 4
                end: 7
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 4
                end: 30
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] sometimes{foo!="bar"}'
        - '[*parser.AggregateExpr] sum(sometimes{foo!="bar"})'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: many-to-many
            returns: vector
            operations:
                - '[*parser.VectorSelector] bob'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 57
                end: 60
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
        - src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 73
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 79
            deadinfo: null
            operation: sum
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
                - '[*parser.AggregateExpr] sum(bar)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 74
                end: 77
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57389
          depth: 0
        - src:
            labels: {}
            deadinfo: null
            operation: many-to-many
            returns: vector
            operations:
                - '[*parser.VectorSelector] notfound'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 85
                end: 93
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 29
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 36
                end: 42
      deadinfo: null
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: many-to-many
            returns: vector
            operations:
                - '[*parser.VectorSelector] bob'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 57
                end: 60
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
        - src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 73
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 79
            deadinfo: null
            operation: sum
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar'
                - '[*parser.AggregateExpr] sum(bar)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 74
                end: 77
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57389
          depth: 0
        - src:
            labels: {}
            deadinfo: null
            operation: many-to-many
            returns: vector
            operations:
                - '[*parser.VectorSelector] notfound'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 85
                end: 93
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 36
            end: 45
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 36
        end: 45
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/124 - 1]
expr: foo offset 5m > 5
output:
    - labels: {}
      deadinfo: null
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo offset 5m'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 13
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/125 - 1]
expr: |4
    (rate(metric2[5m]) or vector(0)) +
    (rate(metric1[5m]) or vector(1)) +
    (rate(metric3{log_name="samplerd"}[5m]) or vector(2)) > 0
output:
    - labels: {}
      deadinfo: null
      operation: rate
      returns: vector
      operations:
        - '[*parser.VectorSelector] metric2'
        - '[*parser.Call] rate(metric2[5m])'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: rate
            returns: vector
            operations:
                - '[*parser.VectorSelector] metric1'
                - '[*parser.Call] rate(metric1[5m])'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 42
                end: 53
            type: function
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
        - src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 58
                        end: 64
            deadinfo: null
            operation: vector
            returns: vector
            operations:
                - '[*parser.Call] vector(1)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 58
                    end: 67
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 58
                end: 67
            type: function
            fixedlabels: true
            isconditional: false
          op: 57383
          depth: 0
        - src:
            labels:
                log_name:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 72
                        end: 110
            deadinfo: null
            operation: rate
            returns: vector
            operations:
                - '[*parser.VectorSelector] metric3{log_name="samplerd"}'
                - '[*parser.Call] rate(metric3{log_name="samplerd"}[5m])'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 77
                end: 109
            type: function
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
        - src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 114
                        end: 120
            deadinfo: null
            operation: vector
            returns: vector
            operations:
                - '[*parser.Call] vector(2)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 114
                    end: 123
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 114
                end: 123
            type: function
            fixedlabels: true
            isconditional: false
          op: 57383
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 18
      type: function
      fixedlabels: false
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 23
                end: 29
      deadinfo: null
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: rate
            returns: vector
            operations:
                - '[*parser.VectorSelector] metric1'
                - '[*parser.Call] rate(metric1[5m])'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 42
                end: 53
            type: function
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
        - src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 58
                        end: 64
            deadinfo: null
            operation: vector
            returns: vector
            operations:
                - '[*parser.Call] vector(1)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 58
                    end: 67
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 58
                end: 67
            type: function
            fixedlabels: true
            isconditional: false
          op: 57383
          depth: 0
        - src:
            labels:
                log_name:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 72
                        end: 110
            deadinfo: null
            operation: rate
            returns: vector
            operations:
                - '[*parser.VectorSelector] metric3{log_name="samplerd"}'
                - '[*parser.Call] rate(metric3{log_name="samplerd"}[5m])'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 77
                end: 109
            type: function
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
        - src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 114
                        end: 120
            deadinfo: null
            operation: vector
            returns: vector
            operations:
                - '[*parser.Call] vector(2)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 114
                    end: 123
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 114
                end: 123
            type: function
            fixedlabels: true
            isconditional: false
          op: 57383
          depth: 0
      unless: []
      returninfo:
        logicalexpr: vector(0) + vector(1) + vector(2)
        valueposition:
            start: 23
            end: 32
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 23
        end: 32
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/126 - 1]
expr: label_replace(vector(1), "nexthop_tag", "$1", "nexthop", "(.+)")
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 14
                end: 20
        nexthop_tag:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 64
      deadinfo: null
      operation: label_replace
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
        - '[*parser.Call] label_replace(vector(1), "nexthop_tag", "$1", "nexthop", "(.+)")'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 14
            end: 23
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 14
        end: 23
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/127 - 1]
expr: (sum(foo{job="myjob"}))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 23
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
        - '[*parser.AggregateExpr] sum(foo{job="myjob"})'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 21
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/128 - 1]
expr: (-foo{job="myjob"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 2
                end: 18
      deadinfo: null
      operation: ""
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{job="myjob"}'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 2
        end: 18
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/129 - 1]
expr: |4-
    ((( group(vector(0)) ))) > 0
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 5
                end: 23
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 5
                end: 23
      deadinfo:
        reason: '`vector(0) > 0` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 11
            end: 20
      operation: group
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
        - '[*parser.AggregateExpr] group(vector(0))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 11
            end: 20
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 11
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/130 - 1]
expr: 1 > bool 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo:
        reason: '`1 > 5` always evaluates to `1 > 5` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 0
            end: 1
      operation: ""
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/131 - 1]
expr: prometheus_ready{job="prometheus"} unless vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
      joins: []
      unless:
        - labels:
            "":
                reason: Calling `vector()` will return a vector value with no labels.
                kind: excluded
                fragment:
                    start: 42
                    end: 48
          deadinfo:
            reason: The right hand side will never be matched because it doesn't have the `job` label while the left hand side will. Calling `vector()` will return a vector value with no labels.
            fragment:
                start: 42
                end: 48
          operation: vector
          returns: vector
          operations:
            - '[*parser.Call] vector(0)'
          joins: []
          unless: []
          returninfo:
            logicalexpr: ""
            valueposition:
                start: 42
                end: 51
            returnednumber: 0
            alwaysreturns: true
            knownreturn: true
            isreturnbool: false
          position:
            start: 42
            end: 51
          type: function
          fixedlabels: true
          isconditional: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 34
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/132 - 1]
expr: prometheus_ready{job="prometheus"} unless on() vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      deadinfo:
        reason: This query will never return anything because the `unless` query always returns something.
        fragment:
            start: 47
            end: 56
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
      joins: []
      unless:
        - labels:
            "":
                reason: Calling `vector()` will return a vector value with no labels.
                kind: excluded
                fragment:
                    start: 47
                    end: 53
          deadinfo: null
          operation: vector
          returns: vector
          operations:
            - '[*parser.Call] vector(0)'
          joins: []
          unless: []
          returninfo:
            logicalexpr: ""
            valueposition:
                start: 47
                end: 56
            returnednumber: 0
            alwaysreturns: true
            knownreturn: true
            isreturnbool: false
          position:
            start: 47
            end: 56
          type: function
          fixedlabels: true
          isconditional: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 34
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/133 - 1]
expr: prometheus_ready{job="prometheus"} unless on(job) vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
      joins: []
      unless:
        - labels:
            "":
                reason: Calling `vector()` will return a vector value with no labels.
                kind: excluded
                fragment:
                    start: 50
                    end: 56
          deadinfo:
            reason: The right hand side will never be matched because it doesn't have the `job` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
            fragment:
                start: 50
                end: 56
          operation: vector
          returns: vector
          operations:
            - '[*parser.Call] vector(0)'
          joins: []
          unless: []
          returninfo:
            logicalexpr: ""
            valueposition:
                start: 50
                end: 59
            returnednumber: 0
            alwaysreturns: true
            knownreturn: true
            isreturnbool: false
          position:
            start: 50
            end: 59
          type: function
          fixedlabels: true
          isconditional: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 34
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/134 - 1]
expr: |4
    max by (instance, cluster) (cf_node_role{kubernetes_role="master",role="kubernetes"})
    unless
       sum by (instance, cluster) (time() - node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"})
       * on (instance) group_left (cluster)
        cf_node_role{kubernetes_role="master",role="kubernetes"}
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 86
        cluster:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        instance:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        kubernetes_role:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        role:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
      deadinfo: null
      operation: max
      returns: vector
      operations:
        - '[*parser.VectorSelector] cf_node_role{kubernetes_role="master",role="kubernetes"}'
        - '[*parser.AggregateExpr] max by (instance, cluster) (cf_node_role{kubernetes_role="master",role="kubernetes"})'
      joins: []
      unless:
        - labels:
            "":
                reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
                kind: excluded
                fragment:
                    start: 99
                    end: 102
            __name__:
                reason: Aggregation removes metric name.
                kind: excluded
                fragment:
                    start: 95
                    end: 202
            cluster:
                reason: Query is using many-to-one vector matching with `group_left(cluster)`, all labels included inside `group_left(...)` will be include on the results.
                kind: included
                fragment:
                    start: 222
                    end: 233
            instance:
                reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
                kind: included
                fragment:
                    start: 208
                    end: 211
            name:
                reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
                kind: excluded
                fragment:
                    start: 99
                    end: 102
          deadinfo: null
          operation: sum
          returns: vector
          operations:
            - '[*parser.VectorSelector] node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"}'
            - '[*parser.AggregateExpr] sum by (instance, cluster) (time() - node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"})'
          joins:
            - src:
                labels:
                    kubernetes_role:
                        reason: Query will only return series where these labels are present.
                        kind: guaranteed
                        fragment:
                            start: 247
                            end: 303
                    role:
                        reason: Query will only return series where these labels are present.
                        kind: guaranteed
                        fragment:
                            start: 247
                            end: 303
                deadinfo: null
                operation: ""
                returns: vector
                operations:
                    - '[*parser.VectorSelector] cf_node_role{kubernetes_role="master",role="kubernetes"}'
                joins: []
                unless: []
                returninfo:
                    logicalexpr: ""
                    valueposition:
                        start: 0
                        end: 0
                    returnednumber: 0
                    alwaysreturns: false
                    knownreturn: false
                    isreturnbool: false
                position:
                    start: 247
                    end: 303
                type: selector
                fixedlabels: false
                isconditional: false
              op: 57395
              depth: 0
          unless: []
          returninfo:
            logicalexpr: ""
            valueposition:
                start: 0
                end: 0
            returnednumber: 0
            alwaysreturns: false
            knownreturn: false
            isreturnbool: false
          position:
            start: 132
            end: 201
          type: aggregation
          fixedlabels: true
          isconditional: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 29
        end: 85
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/135 - 1]
expr: foo{a="1"} * on() bar{b="2"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
        a:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
      deadinfo: null
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{a="1"}'
      joins:
        - src:
            labels:
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 18
                        end: 28
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar{b="2"}'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 18
                end: 28
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/136 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) bar{b="2"}
output:
    - labels:
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        d:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      deadinfo: null
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{a="1"}'
      joins:
        - src:
            labels:
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 42
                        end: 52
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar{b="2"}'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 42
                end: 52
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/137 - 1]
expr: foo{a="1"} * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 43
                end: 53
        c:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 37
        d:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 37
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      deadinfo: null
      operation: one-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{b="2"}'
      joins:
        - src:
            labels:
                a:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 0
                        end: 10
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] foo{a="1"}'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 10
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 43
        end: 53
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/138 - 1]
expr: foo{a="1"} * on(instance) sum(bar{b="2"})
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
        a:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      deadinfo: null
      operation: one-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{a="1"}'
      joins:
        - src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 26
                        end: 29
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 26
                        end: 41
                b:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 26
                        end: 29
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 26
                    end: 29
            operation: sum
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar{b="2"}'
                - '[*parser.AggregateExpr] sum(bar{b="2"})'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 30
                end: 40
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/139 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) sum(bar{b="2"})
output:
    - labels:
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        d:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      deadinfo: null
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{a="1"}'
      joins:
        - src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 45
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 57
                b:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 45
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 42
                    end: 45
            operation: sum
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar{b="2"}'
                - '[*parser.AggregateExpr] sum(bar{b="2"})'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 46
                end: 56
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/140 - 1]
expr: sum(foo{a="1"}) * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 48
                end: 58
        c:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 31
                end: 42
        d:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 31
                end: 42
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 18
                end: 20
      deadinfo: null
      operation: one-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{b="2"}'
      joins:
        - src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 3
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 15
                a:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 3
            deadinfo:
                reason: The left hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 0
                    end: 3
            operation: sum
            returns: vector
            operations:
                - '[*parser.VectorSelector] foo{a="1"}'
                - '[*parser.AggregateExpr] sum(foo{a="1"})'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 4
                end: 14
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 48
        end: 58
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/141 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) sum(bar{b="2"}) without(instance)
output:
    - labels:
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        d:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      deadinfo: null
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{a="1"}'
      joins:
        - src:
            labels:
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 75
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 46
                        end: 56
                instance:
                    reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                    kind: excluded
                    fragment:
                        start: 58
                        end: 65
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                fragment:
                    start: 58
                    end: 65
            operation: sum
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar{b="2"}'
                - '[*parser.AggregateExpr] sum without (instance) (bar{b="2"})'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 46
                end: 56
            type: aggregation
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/142 - 1]
expr: sum(foo{a="1"}) without(instance) * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 66
                end: 76
        c:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 49
                end: 60
        d:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 49
                end: 60
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 36
                end: 38
      deadinfo: null
      operation: one-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] bar{b="2"}'
      joins:
        - src:
            labels:
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 33
                a:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 4
                        end: 14
                instance:
                    reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                    kind: excluded
                    fragment:
                        start: 16
                        end: 23
            deadinfo:
                reason: The left hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                fragment:
                    start: 16
                    end: 23
            operation: sum
            returns: vector
            operations:
                - '[*parser.VectorSelector] foo{a="1"}'
                - '[*parser.AggregateExpr] sum without (instance) (foo{a="1"})'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 4
                end: 14
            type: aggregation
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 66
        end: 76
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/143 - 1]
expr: |4
     max without (source_instance) (
       increase(kernel_device_io_errors_total{device!~"loop.+"}[120m]) > 3 unless on(instance, device) (
         increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[125m])*2 > increase(kernel_device_io_errors_total[120m])
       )
       and on(device, instance) absent(node_disk_info)
     ) * on(instance) group_left(group) label_replace(salt_highstate_runner_configured_minions, "instance", "$1", "minion", "(.+)")
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 2
                end: 317
        device:
            reason: Query is using many-to-many vector matching with `on(device, instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 112
                end: 114
        group:
            reason: Query is using many-to-one vector matching with `group_left(group)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 333
                end: 343
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 112
                end: 114
        source_instance:
            reason: Query is using aggregation with `without(source_instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 6
                end: 14
      deadinfo: null
      operation: max
      returns: vector
      operations:
        - '[*parser.VectorSelector] kernel_device_io_errors_total{device!~"loop.+"}'
        - '[*parser.Call] increase(kernel_device_io_errors_total{device!~"loop.+"}[2h])'
        - '[*parser.AggregateExpr] max without (source_instance) (increase(kernel_device_io_errors_total{device!~"loop.+"}[2h]) > 3 unless on (instance, device) (increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[2h5m]) * 2 > increase(kernel_device_io_errors_total[2h])) and on (device, instance) absent(node_disk_info))'
      joins:
        - src:
            labels:
                "":
                    reason: |-
                        The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                        You will only get any results back if the metric selector you pass doesn't match anything.
                        Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                        This means that the only labels you can get back from absent call are the ones you pass to it.
                        If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
                    kind: excluded
                    fragment:
                        start: 292
                        end: 298
            deadinfo:
                reason: |-
                    The right hand side will never be matched because it doesn't have the `device` label from `on(...)`. The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                    You will only get any results back if the metric selector you pass doesn't match anything.
                    Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                    This means that the only labels you can get back from absent call are the ones you pass to it.
                    If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
                fragment:
                    start: 292
                    end: 298
            operation: absent
            returns: vector
            operations:
                - '[*parser.VectorSelector] node_disk_info'
                - '[*parser.Call] absent(node_disk_info)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 299
                end: 313
            type: function
            fixedlabels: true
            isconditional: false
          op: 57389
          depth: 1
        - src:
            labels:
                instance:
                    reason: This label will be added to the result by label_replace() call.
                    kind: guaranteed
                    fragment:
                        start: 351
                        end: 442
            deadinfo: null
            operation: label_replace
            returns: vector
            operations:
                - '[*parser.VectorSelector] salt_highstate_runner_configured_minions'
                - '[*parser.Call] label_replace(salt_highstate_runner_configured_minions, "instance", "$1", "minion", "(.+)")'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 365
                end: 405
            type: function
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless:
        - labels: {}
          deadinfo: null
          operation: increase
          returns: vector
          operations:
            - '[*parser.VectorSelector] kernel_device_io_soft_errors_total{device!~"loop.+"}'
            - '[*parser.Call] increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[2h5m])'
          joins:
            - src:
                labels: {}
                deadinfo: null
                operation: increase
                returns: vector
                operations:
                    - '[*parser.VectorSelector] kernel_device_io_errors_total'
                    - '[*parser.Call] increase(kernel_device_io_errors_total[2h])'
                joins: []
                unless: []
                returninfo:
                    logicalexpr: ""
                    valueposition:
                        start: 0
                        end: 0
                    returnednumber: 0
                    alwaysreturns: false
                    knownreturn: false
                    isreturnbool: false
                position:
                    start: 222
                    end: 257
                type: function
                fixedlabels: false
                isconditional: false
              op: 57388
              depth: 0
          unless: []
          returninfo:
            logicalexpr: ""
            valueposition:
                start: 0
                end: 0
            returnednumber: 0
            alwaysreturns: false
            knownreturn: false
            isreturnbool: false
          position:
            start: 149
            end: 207
          type: function
          fixedlabels: false
          isconditional: true
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 46
        end: 99
      type: aggregation
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/144 - 1]
expr: sum(foo{a="1"}) by(job) * on() bar{b="2"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 26
                end: 28
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 23
        a:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 16
                end: 18
        job:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 26
                end: 28
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo{a="1"}'
        - '[*parser.AggregateExpr] sum by (job) (foo{a="1"})'
      joins:
        - src:
            labels:
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 31
                        end: 41
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] bar{b="2"}'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 31
                end: 41
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 14
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/145 - 1]
expr: sum(sum(foo) without(job)) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 27
                end: 29
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 13
                end: 20
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
        - '[*parser.AggregateExpr] sum without (job) (foo)'
        - '[*parser.AggregateExpr] sum by (job) (sum without (job) (foo))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 11
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/146 - 1]
expr: |4
    prometheus:scrape_series_added:since_gc:sum
    * on(prometheus) group_left()
    label_replace(
      max(max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])) by(instance)
      /
      max(max_over_time(prometheus_tsdb_head_series[2h])) by(instance),
      "prometheus", "$1",
      "instance", "(.+)"
    )
output:
    - labels:
        prometheus:
            reason: Query is using many-to-one vector matching with `on(prometheus)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 47
                end: 49
      deadinfo: null
      operation: many-to-one
      returns: vector
      operations:
        - '[*parser.VectorSelector] prometheus:scrape_series_added:since_gc:sum'
      joins:
        - src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 158
                        end: 160
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 92
                        end: 170
                instance:
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 158
                        end: 160
                job:
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 158
                        end: 160
                prometheus:
                    reason: This label will be added to the result by label_replace() call.
                    kind: guaranteed
                    fragment:
                        start: 75
                        end: 287
            deadinfo: null
            operation: label_replace
            returns: vector
            operations:
                - '[*parser.VectorSelector] go_memstats_alloc_bytes{job="prometheus"}'
                - '[*parser.Call] max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])'
                - '[*parser.AggregateExpr] max by (instance) (max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h]))'
                - '[*parser.Call] label_replace(max by (instance) (max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])) / max by (instance) (max_over_time(prometheus_tsdb_head_series[2h])), "prometheus", "$1", "instance", "(.+)")'
            joins:
                - src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 229
                                end: 231
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 177
                                end: 241
                        instance:
                            reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 229
                                end: 231
                    deadinfo: null
                    operation: max
                    returns: vector
                    operations:
                        - '[*parser.VectorSelector] prometheus_tsdb_head_series'
                        - '[*parser.Call] max_over_time(prometheus_tsdb_head_series[2h])'
                        - '[*parser.AggregateExpr] max by (instance) (max_over_time(prometheus_tsdb_head_series[2h]))'
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 195
                        end: 226
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 92
                end: 241
            type: function
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 44
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/147 - 1]
expr: (day_of_week() == 6 and hour() < 1) or vector(1)
output:
    - labels:
        "":
            reason: Calling `day_of_week()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 14
      deadinfo: null
      operation: day_of_week
      returns: vector
      operations:
        - '[*parser.Call] day_of_week()'
      joins:
        - src:
            labels:
                "":
                    reason: Calling `hour()` with no arguments will return an empty time series with no labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 30
            deadinfo: null
            operation: hour
            returns: vector
            operations:
                - '[*parser.Call] hour()'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: true
                knownreturn: false
                isreturnbool: false
            position:
                start: 24
                end: 30
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 14
      type: function
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 39
                end: 45
      deadinfo: null
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 39
            end: 48
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 39
        end: 48
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/148 - 1]
expr: |4-
    sum by (foo, bar) (
        rate(errors_total[5m])
      * on (instance) group_left (bob, alice)
        server_errors_total
    )
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 115
        alice:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        bar:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        bob:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        foo:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        instance:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] errors_total'
        - '[*parser.Call] rate(errors_total[5m])'
        - '[*parser.AggregateExpr] sum by (foo, bar) (rate(errors_total[5m]) * on (instance) group_left (bob, alice) server_errors_total)'
      joins:
        - src:
            labels: {}
            deadinfo: null
            operation: ""
            returns: vector
            operations:
                - '[*parser.VectorSelector] server_errors_total'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 94
                end: 113
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 1
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 30
        end: 46
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/149 - 1]
expr: 1 - (foo or vector(0)) < 0.999
output:
    - labels: {}
      deadinfo: null
      operation: many-to-many
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: selector
      fixedlabels: false
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 12
                end: 18
      deadinfo:
        reason: '`1 - vector(0) < 0.999` always evaluates to `1 < 0.999` which is not possible, so it will never return anything.'
        fragment:
            start: 12
            end: 21
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: 1 - vector(0)
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/150 - 1]
expr: |4
    (
      vector(1) and month() == 2
    ) or vector(0)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 5
                end: 11
      deadinfo: null
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(1)'
      joins:
        - src:
            labels:
                "":
                    reason: Calling `month()` with no arguments will return an empty time series with no labels.
                    kind: excluded
                    fragment:
                        start: 19
                        end: 26
            deadinfo: null
            operation: month
            returns: vector
            operations:
                - '[*parser.Call] month()'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: true
                knownreturn: false
                isreturnbool: false
            position:
                start: 19
                end: 26
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 5
            end: 14
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 5
        end: 14
      type: function
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 37
                end: 43
      deadinfo: null
      operation: vector
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 37
            end: 46
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 37
        end: 46
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/151 - 1]
expr: count by (region) (stddev by (colo_name, region) (error_total))
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 9
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 63
        colo_name:
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 9
        region:
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 6
                end: 9
      deadinfo: null
      operation: count
      returns: vector
      operations:
        - '[*parser.VectorSelector] error_total'
        - '[*parser.AggregateExpr] stddev by (colo_name, region) (error_total)'
        - '[*parser.AggregateExpr] count by (region) (stddev by (colo_name, region) (error_total))'
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 50
        end: 61
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/152 - 1]
expr: |4
    (
      avg(
        rate(foo_rejections[6h])
        or
        vector(0)
      ) by (colo_name)
      /
      (
        avg(
          rate(foo_total[6h])
       or
       vector(1)
        ) by (colo_name)
      )
    ) > 5
    *
    (
      avg(
        rate(foo_rejections[6h] offset 1d)
     or
     vector(0)
      ) by (colo_name)
      /
      avg(
        rate(foo_total[6h] offset 1d)
     or
     vector(1)
      ) by (colo_name)
    ) and on (colo_name) (colo_job:foo_total:rate2m or vector(0)) > 80
      and on (colo_name) (colo_job:foo_total:rate2m offset 1d or vector(0)) > 80
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 64
                end: 67
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 5
                end: 78
        colo_name:
            reason: Query is using many-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 341
                end: 344
      deadinfo: null
      operation: avg
      returns: vector
      operations:
        - '[*parser.VectorSelector] foo_rejections'
        - '[*parser.Call] rate(foo_rejections[6h])'
        - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h]) or vector(0))'
      joins:
        - src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 147
                        end: 150
            deadinfo: null
            operation: avg
            returns: vector
            operations:
                - '[*parser.VectorSelector] foo_total'
                - '[*parser.Call] rate(foo_total[6h])'
                - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 107
                end: 120
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
        - src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 131
                        end: 137
            deadinfo: null
            operation: avg
            returns: vector
            operations:
                - '[*parser.Call] vector(1)'
                - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 131
                    end: 140
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 131
                end: 140
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
        - src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 255
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 241
                        end: 244
            deadinfo: null
            operation: avg
            returns: vector
            operations:
                - '[*parser.VectorSelector] foo_rejections offset 1d'
                - '[*parser.Call] rate(foo_rejections[6h] offset 1d)'
                - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
            joins:
                - src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 320
                                end: 323
                    deadinfo: null
                    operation: avg
                    returns: vector
                    operations:
                        - '[*parser.VectorSelector] foo_total offset 1d'
                        - '[*parser.Call] rate(foo_total[6h] offset 1d)'
                        - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                - src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadinfo: null
                    operation: avg
                    returns: vector
                    operations:
                        - '[*parser.Call] vector(1)'
                        - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 192
                end: 220
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
        - src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 255
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 227
                        end: 233
            deadinfo: null
            operation: avg
            returns: vector
            operations:
                - '[*parser.Call] vector(0)'
                - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
            joins:
                - src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 320
                                end: 323
                    deadinfo: null
                    operation: avg
                    returns: vector
                    operations:
                        - '[*parser.VectorSelector] foo_total offset 1d'
                        - '[*parser.Call] rate(foo_total[6h] offset 1d)'
                        - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                - src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadinfo: null
                    operation: avg
                    returns: vector
                    operations:
                        - '[*parser.Call] vector(1)'
                        - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
            unless: []
            returninfo:
                logicalexpr: 5 * vector(0) / vector(1)
                valueposition:
                    start: 170
                    end: 171
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 227
                end: 236
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
        - src:
            labels: {}
            deadinfo: null
            operation: many-to-many
            returns: vector
            operations:
                - '[*parser.VectorSelector] colo_job:foo_total:rate2m'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 357
                end: 382
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
        - src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 386
                        end: 392
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 386
                    end: 392
            operation: vector
            returns: vector
            operations:
                - '[*parser.Call] vector(0)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 386
                    end: 395
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 386
                end: 395
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
        - src:
            labels: {}
            deadinfo: null
            operation: many-to-many
            returns: vector
            operations:
                - '[*parser.VectorSelector] colo_job:foo_total:rate2m offset 1d'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 424
                end: 459
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
        - src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 463
                        end: 469
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 463
                    end: 469
            operation: vector
            returns: vector
            operations:
                - '[*parser.Call] vector(0)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 463
                    end: 472
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 463
                end: 472
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 19
        end: 37
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 64
                end: 67
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 5
                end: 78
        colo_name:
            reason: Query is using many-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 341
                end: 344
      deadinfo:
        reason: '`vector(0) / vector(1) > 5 * vector(0) / vector(1)` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 50
            end: 59
      operation: avg
      returns: vector
      operations:
        - '[*parser.Call] vector(0)'
        - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h]) or vector(0))'
      joins:
        - src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 147
                        end: 150
            deadinfo: null
            operation: avg
            returns: vector
            operations:
                - '[*parser.VectorSelector] foo_total'
                - '[*parser.Call] rate(foo_total[6h])'
                - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 107
                end: 120
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
        - src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 131
                        end: 137
            deadinfo: null
            operation: avg
            returns: vector
            operations:
                - '[*parser.Call] vector(1)'
                - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 131
                    end: 140
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 131
                end: 140
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
        - src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 255
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 241
                        end: 244
            deadinfo: null
            operation: avg
            returns: vector
            operations:
                - '[*parser.VectorSelector] foo_rejections offset 1d'
                - '[*parser.Call] rate(foo_rejections[6h] offset 1d)'
                - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
            joins:
                - src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 320
                                end: 323
                    deadinfo: null
                    operation: avg
                    returns: vector
                    operations:
                        - '[*parser.VectorSelector] foo_total offset 1d'
                        - '[*parser.Call] rate(foo_total[6h] offset 1d)'
                        - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                - src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadinfo: null
                    operation: avg
                    returns: vector
                    operations:
                        - '[*parser.Call] vector(1)'
                        - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 192
                end: 220
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
        - src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 255
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 227
                        end: 233
            deadinfo: null
            operation: avg
            returns: vector
            operations:
                - '[*parser.Call] vector(0)'
                - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
            joins:
                - src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 320
                                end: 323
                    deadinfo: null
                    operation: avg
                    returns: vector
                    operations:
                        - '[*parser.VectorSelector] foo_total offset 1d'
                        - '[*parser.Call] rate(foo_total[6h] offset 1d)'
                        - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                - src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadinfo: null
                    operation: avg
                    returns: vector
                    operations:
                        - '[*parser.Call] vector(1)'
                        - '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
            unless: []
            returninfo:
                logicalexpr: 5 * vector(0) / vector(1)
                valueposition:
                    start: 170
                    end: 171
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 227
                end: 236
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
        - src:
            labels: {}
            deadinfo: null
            operation: many-to-many
            returns: vector
            operations:
                - '[*parser.VectorSelector] colo_job:foo_total:rate2m'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 357
                end: 382
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
        - src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 386
                        end: 392
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 386
                    end: 392
            operation: vector
            returns: vector
            operations:
                - '[*parser.Call] vector(0)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 386
                    end: 395
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 386
                end: 395
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
        - src:
            labels: {}
            deadinfo: null
            operation: many-to-many
            returns: vector
            operations:
                - '[*parser.VectorSelector] colo_job:foo_total:rate2m offset 1d'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 424
                end: 459
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
        - src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 463
                        end: 469
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 463
                    end: 469
            operation: vector
            returns: vector
            operations:
                - '[*parser.Call] vector(0)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 463
                    end: 472
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 463
                end: 472
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: vector(0) / vector(1)
        valueposition:
            start: 50
            end: 59
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 50
        end: 59
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/153 - 1]
expr: sum(selector) / sum(selector offset 30m) > 5
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 13
      deadinfo: null
      operation: sum
      returns: vector
      operations:
        - '[*parser.VectorSelector] selector'
        - '[*parser.AggregateExpr] sum(selector)'
      joins:
        - src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 16
                        end: 19
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 16
                        end: 40
            deadinfo: null
            operation: sum
            returns: vector
            operations:
                - '[*parser.VectorSelector] selector offset 30m'
                - '[*parser.AggregateExpr] sum(selector offset 30m)'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 20
                end: 39
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 12
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/154 - 1]
expr: |4-
    count by (dc) (
      max(0 < (token_expiration - time()) < (6*60*60)) by (instance)
      * on (instance) group_right label_replace(
        configured_minions, "instance", "$1", "minion", "(.+)")
      ) > 5
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(dc)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 10
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 190
        dc:
            reason: Query is using aggregation with `by(dc)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 7
                end: 10
        instance:
            reason: Query is using aggregation with `by(dc)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 10
      deadinfo: null
      operation: count
      returns: vector
      operations:
        - '[*parser.VectorSelector] configured_minions'
        - '[*parser.Call] label_replace(configured_minions, "instance", "$1", "minion", "(.+)")'
        - '[*parser.AggregateExpr] count by (dc) (max by (instance) (0 < (token_expiration - time()) < (6 * 60 * 60)) * on (instance) group_right () label_replace(configured_minions, "instance", "$1", "minion", "(.+)"))'
      joins:
        - src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 68
                        end: 71
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 19
                        end: 81
                instance:
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 68
                        end: 71
            deadinfo: null
            operation: max
            returns: vector
            operations:
                - '[*parser.VectorSelector] token_expiration'
                - '[*parser.AggregateExpr] max by (instance) (0 < (token_expiration - time()) < (6 * 60 * 60))'
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 28
                end: 44
            type: aggregation
            fixedlabels: true
            isconditional: true
          op: 57395
          depth: 1
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 131
        end: 149
      type: aggregation
      fixedlabels: true
      isconditional: true

---
