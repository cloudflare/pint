
[TestLabelsSource/1 - 1]
expr: "1"
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo: null
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/2 - 1]
expr: 1 / 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo: null
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 1 / 5
        valueposition:
            start: 0
            end: 1
        returnednumber: 0.2
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/3 - 1]
expr: (2 ^ 5) == bool 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo:
        reason: '`2 ^ 5 == 5` always evaluates to `32 == 5` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 32
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/4 - 1]
expr: (2 ^ 5 + 11) % 5 <= bool 2
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo:
        reason: '`2 ^ 5 + 11 % 5 <= 2` always evaluates to `3 <= 2` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/5 - 1]
expr: (2 ^ 5 + 11) % 5 >= bool 20
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo:
        reason: '`2 ^ 5 + 11 % 5 >= 20` always evaluates to `3 >= 20` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/6 - 1]
expr: (2 ^ 5 + 11) % 5 <= bool 3
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo: null
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/7 - 1]
expr: (2 ^ 5 + 11) % 5 < bool 1
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 2
      deadinfo:
        reason: '`2 ^ 5 + 11 % 5 < 1` always evaluates to `3 < 1` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 1
            end: 2
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 ^ 5 + 11 % 5
        valueposition:
            start: 1
            end: 2
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 1
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/8 - 1]
expr: 20 - 15 < bool 1
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 2
      deadinfo:
        reason: '`20 - 15 < 1` always evaluates to `5 < 1` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 0
            end: 2
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 20 - 15
        valueposition:
            start: 0
            end: 2
        returnednumber: 5
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/9 - 1]
expr: 2 * 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo: null
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: 2 * 5
        valueposition:
            start: 0
            end: 1
        returnednumber: 10
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/10 - 1]
expr: (foo or bar) * 5
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 11
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/11 - 1]
expr: (foo or vector(2)) * 5
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 8
                end: 14
      deadinfo: null
      returns: vector
      operations:
        - args:
            - "2"
          node: '[*parser.Call] vector(2)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: vector(2) * 5
        valueposition:
            start: 8
            end: 17
        returnednumber: 10
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 8
        end: 17
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/12 - 1]
expr: (foo or vector(5)) * (vector(2) or bar)
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 39
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 22
                        end: 28
            deadinfo: null
            returns: vector
            operations:
                - args:
                    - "2"
                  node: '[*parser.Call] vector(2)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 22
                    end: 31
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 22
                end: 31
            type: function
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo:
                reason: The left hand side always returs something and so the right hand side is never used.
                fragment:
                    start: 35
                    end: 38
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 35
                end: 38
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 8
                end: 14
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 39
      deadinfo: null
      returns: vector
      operations:
        - args:
            - "5"
          node: '[*parser.Call] vector(5)'
          op: vector
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 22
                        end: 28
            deadinfo: null
            returns: vector
            operations:
                - args:
                    - "2"
                  node: '[*parser.Call] vector(2)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 22
                    end: 31
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 22
                end: 31
            type: function
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo:
                reason: The left hand side always returs something and so the right hand side is never used.
                fragment:
                    start: 35
                    end: 38
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 35
                end: 38
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: vector(5) * vector(2)
        valueposition:
            start: 8
            end: 17
        returnednumber: 10
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 8
        end: 17
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/13 - 1]
expr: 1 > bool 0
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo: null
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/14 - 1]
expr: 20 > bool 10
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 2
      deadinfo: null
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 2
        returnednumber: 20
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 2
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/15 - 1]
expr: '"test"'
output:
    - labels:
        "":
            reason: This query returns a string value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      returns: string
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 6
      type: string
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/16 - 1]
expr: foo
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/17 - 1]
expr: (foo > 1) > bool 1
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/18 - 1]
expr: foo > bool 5
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/19 - 1]
expr: foo > bool 5 == 1
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/20 - 1]
expr: foo > bool bar
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 14
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 11
                end: 14
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/21 - 1]
expr: (foo > bool bar) == 0
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 15
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 12
                end: 15
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/22 - 1]
expr: foo > bool on(instance) bar
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 11
                end: 13
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 27
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 13
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 24
                end: 27
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/23 - 1]
expr: (foo > bool on(instance) bar) == 1
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 12
                end: 14
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 28
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 12
                end: 14
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 25
                end: 28
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/24 - 1]
expr: foo > bool on(instance) group_left(version) bar
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 47
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 13
        version:
            reason: Query is using many-to-one vector matching with `group_left(version)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 24
                end: 34
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels:
            - version
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 44
                end: 47
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/25 - 1]
expr: bar > bool on(instance) group_right(version) foo
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 48
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 13
        version:
            reason: Query is using one-to-many vector matching with `group_right(version)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 24
                end: 35
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels:
            - version
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 3
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57388
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: true
      position:
        start: 45
        end: 48
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/26 - 1]
expr: foo and bar > bool 0
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: true
            position:
                start: 8
                end: 11
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/27 - 1]
expr: foo offset 5m
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo offset 5m'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 13
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/28 - 1]
expr: foo{job="bar"}
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="bar"}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/29 - 1]
expr: foo{job=""}
output:
    - labels:
        job:
            reason: Query uses `{job=""}` selector which will filter out any time series with the `job` label set.
            kind: excluded
            fragment:
                start: 0
                end: 11
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job=""}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 11
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/30 - 1]
expr: foo{job="bar"} or bar{job="foo"}
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="bar"}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 18
                end: 32
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{job="foo"}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 18
        end: 32
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/31 - 1]
expr: foo{a="bar"} or bar{b="foo"}
output:
    - labels:
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 12
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="bar"}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 12
      type: selector
      fixedlabels: false
      isconditional: false
    - labels:
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 16
                end: 28
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{b="foo"}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 16
        end: 28
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/32 - 1]
expr: foo[5m]
output:
    - labels: {}
      deadinfo: null
      returns: matrix
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/33 - 1]
expr: prometheus_build_info[2m:1m]
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_build_info'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 21
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/34 - 1]
expr: deriv(rate(distance_covered_meters_total[1m])[5m:1m])
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] distance_covered_meters_total'
          op: ""
        - node: '[*parser.Call] rate(distance_covered_meters_total[1m])'
          op: rate
        - node: '[*parser.Call] deriv(rate(distance_covered_meters_total[1m])[5m:1m])'
          op: deriv
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 52
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/35 - 1]
expr: foo - 1
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/36 - 1]
expr: foo / 5
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/37 - 1]
expr: -foo
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/38 - 1]
expr: sum(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo{job="myjob"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/39 - 1]
expr: sum(count(foo{job="myjob"}) by(instance))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 41
        instance:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        job:
            reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 28
                end: 30
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] count by (instance) (foo{job="myjob"})'
          op: count
        - node: '[*parser.AggregateExpr] sum(count by (instance) (foo{job="myjob"}))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 10
        end: 26
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/40 - 1]
expr: sum(foo{job="myjob"}) > 20
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo{job="myjob"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/41 - 1]
expr: sum(foo{job="myjob"}) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 22
                end: 29
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (job) (foo{job="myjob"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/42 - 1]
expr: sum(foo) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 9
                end: 11
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 16
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 9
                end: 11
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job) (foo)'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 7
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/43 - 1]
expr: sum(foo{job="myjob"}) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 22
                end: 24
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 29
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job) (foo{job="myjob"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/44 - 1]
expr: abs(foo{job="myjob"} offset 5m)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 31
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"} offset 5m'
          op: ""
        - node: '[*parser.Call] abs(foo{job="myjob"} offset 5m)'
          op: abs
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 30
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/45 - 1]
expr: abs(foo{job="myjob"} or bar{cluster="dev"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 43
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.Call] abs(foo{job="myjob"} or bar{cluster="dev"})'
          op: abs
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 42
      type: function
      fixedlabels: false
      isconditional: false
    - labels:
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 43
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{cluster="dev"}'
          op: ""
        - node: '[*parser.Call] abs(foo{job="myjob"} or bar{cluster="dev"})'
          op: abs
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 42
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/46 - 1]
expr: sum(foo{job="myjob"} or bar{cluster="dev"}) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 61
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 44
                end: 51
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"} or bar{cluster="dev"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: false
      isconditional: false
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 61
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 24
                end: 42
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 44
                end: 51
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{cluster="dev"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"} or bar{cluster="dev"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 42
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/47 - 1]
expr: sum(foo{job="myjob"}) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 39
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 22
                end: 29
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (instance) (foo{job="myjob"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/48 - 1]
expr: min(foo{job="myjob"}) / max(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 45
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] min(foo{job="myjob"})'
          op: min
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
                job:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{job="myjob"}'
                  op: ""
                - node: '[*parser.AggregateExpr] max(foo{job="myjob"})'
                  op: max
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 28
                end: 44
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/49 - 1]
expr: max(foo{job="myjob"}) / min(foo{job="myjob"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 45
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] max(foo{job="myjob"})'
          op: max
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
                job:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 45
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{job="myjob"}'
                  op: ""
                - node: '[*parser.AggregateExpr] min(foo{job="myjob"})'
                  op: min
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 28
                end: 44
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/50 - 1]
expr: avg(foo{job="myjob"}) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 22
                end: 24
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 29
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 4
                end: 20
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] avg by (job) (foo{job="myjob"})'
          op: avg
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/51 - 1]
expr: group(foo) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 11
                end: 13
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 18
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 11
                end: 13
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] group by (job) (foo)'
          op: group
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 9
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/52 - 1]
expr: stddev(rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[5m])'
          op: rate
        - node: '[*parser.AggregateExpr] stddev(rate(foo[5m]))'
          op: stddev
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 12
        end: 19
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/53 - 1]
expr: stdvar(rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[5m])'
          op: rate
        - node: '[*parser.AggregateExpr] stdvar(rate(foo[5m]))'
          op: stdvar
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 12
        end: 19
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/54 - 1]
expr: stddev_over_time(foo[5m])
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] stddev_over_time(foo[5m])'
          op: stddev_over_time
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 17
        end: 24
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/55 - 1]
expr: stdvar_over_time(foo[5m])
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] stdvar_over_time(foo[5m])'
          op: stdvar_over_time
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 17
        end: 24
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/56 - 1]
expr: quantile(0.9, rate(foo[5m]))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 28
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 28
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[5m])'
          op: rate
        - args:
            - "0.9"
          node: '[*parser.AggregateExpr] quantile(0.9, rate(foo[5m]))'
          op: quantile
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 19
        end: 26
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/57 - 1]
expr: count_values("version", build_version)
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 38
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 38
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] build_version'
          op: ""
        - args:
            - '"version"'
          node: '[*parser.AggregateExpr] count_values("version", build_version)'
          op: count_values
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 37
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/58 - 1]
expr: count_values("version", build_version) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 51
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 39
                end: 46
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 51
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] build_version'
          op: ""
        - args:
            - '"version"'
          node: '[*parser.AggregateExpr] count_values without (job) ("version", build_version)'
          op: count_values
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 37
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/59 - 1]
expr: count_values("version", build_version{job="foo"}) without(job)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 62
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 50
                end: 57
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 62
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] build_version{job="foo"}'
          op: ""
        - args:
            - '"version"'
          node: '[*parser.AggregateExpr] count_values without (job) ("version", build_version{job="foo"})'
          op: count_values
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 48
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/60 - 1]
expr: count_values("version", build_version) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 39
                end: 41
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 46
        job:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 39
                end: 41
        version:
            reason: This label will be added to the results by the count_values() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 46
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] build_version'
          op: ""
        - args:
            - '"version"'
          node: '[*parser.AggregateExpr] count_values by (job) ("version", build_version)'
          op: count_values
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 24
        end: 37
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/61 - 1]
expr: topk(10, foo{job="myjob"}) > 10
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 9
                end: 25
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, foo{job="myjob"})'
          op: topk
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 25
      type: aggregation
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/62 - 1]
expr: topk(10, foo or bar)
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, foo or bar)'
          op: topk
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 12
      type: aggregation
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, foo or bar)'
          op: topk
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 16
        end: 19
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/63 - 1]
expr: rate(foo[10m])
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[10m])'
          op: rate
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 13
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/64 - 1]
expr: sum(rate(foo[10m])) without(instance)
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 37
        instance:
            reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 20
                end: 27
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[10m])'
          op: rate
        - node: '[*parser.AggregateExpr] sum without (instance) (rate(foo[10m]))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 17
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/65 - 1]
expr: foo{job="foo"} / bar
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 20
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 17
                end: 20
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/66 - 1]
expr: foo{job="foo"} * on(instance) bar
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 17
                end: 19
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 33
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 17
                end: 19
        job:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 17
                end: 19
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 30
                end: 33
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/67 - 1]
expr: foo{job="foo"} * on(instance) group_left(bar) bar
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 49
        bar:
            reason: Query is using many-to-one vector matching with `group_left(bar)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 30
                end: 40
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 17
                end: 19
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels:
            - bar
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 46
                end: 49
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/68 - 1]
expr: foo{job="foo"} * on(instance) group_left(cluster) bar{cluster="bar", ignored="true"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 84
        cluster:
            reason: Query is using many-to-one vector matching with `group_left(cluster)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 30
                end: 40
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 17
                end: 19
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 14
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels:
            - cluster
          src:
            labels:
                cluster:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 50
                        end: 84
                ignored:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 50
                        end: 84
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{cluster="bar",ignored="true"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 50
                end: 84
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 14
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/69 - 1]
expr: foo{job="foo", ignored="true"} * on(instance) group_right(job) bar{cluster="bar"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 81
        cluster:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 63
                end: 81
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 33
                end: 35
        job:
            reason: Query is using one-to-many vector matching with `group_right(job)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 46
                end: 57
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{cluster="bar"}'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels:
            - job
          src:
            labels:
                ignored:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 0
                        end: 30
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 0
                        end: 30
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{ignored="true",job="foo"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 30
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 63
        end: 81
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/70 - 1]
expr: count(foo / bar)
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 16
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 16
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] count(foo / bar)'
          op: count
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 12
                end: 15
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 1
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 9
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/71 - 1]
expr: count(up{job="a"} / on () up{job="b"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 38
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 38
        job:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 20
                end: 23
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="a"}'
          op: ""
        - node: '[*parser.AggregateExpr] count(up{job="a"} / on () up{job="b"})'
          op: count
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 26
                        end: 37
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] up{job="b"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 26
                end: 37
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 1
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 17
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/72 - 1]
expr: count(up{job="a"} / on (env) up{job="b"})
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 41
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 41
        env:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 41
        job:
            reason: Query is using one-to-one vector matching with `on(env)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 20
                end: 23
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="a"}'
          op: ""
        - node: '[*parser.AggregateExpr] count(up{job="a"} / on (env) up{job="b"})'
          op: count
      joins:
        - "on":
            - env
          ignoring: []
          addedlabels: []
          src:
            labels:
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 29
                        end: 40
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] up{job="b"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 29
                end: 40
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 1
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 17
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/73 - 1]
expr: foo{job="foo", instance="1"} and bar
output:
    - labels:
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{instance="1",job="foo"}'
          op: ""
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 33
                end: 36
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 28
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/74 - 1]
expr: foo{job="foo", instance="1"} and on(cluster) bar
output:
    - labels:
        cluster:
            reason: Query is using many-to-many vector matching with `on(cluster)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 33
                end: 35
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 28
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{instance="1",job="foo"}'
          op: ""
      joins:
        - "on":
            - cluster
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 45
                end: 48
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 28
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/75 - 1]
expr: topk(10, foo)
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, foo)'
          op: topk
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 12
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/76 - 1]
expr: topk(10, foo) without(cluster)
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk without (cluster) (10, foo)'
          op: topk
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 12
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/77 - 1]
expr: topk(10, foo) by(cluster)
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk by (cluster) (10, foo)'
          op: topk
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 12
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/78 - 1]
expr: bottomk(10, sum(rate(foo[5m])) without(job))
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 12
                end: 43
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 31
                end: 38
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] rate(foo[5m])'
          op: rate
        - node: '[*parser.AggregateExpr] sum without (job) (rate(foo[5m]))'
          op: sum
        - args:
            - "10"
          node: '[*parser.AggregateExpr] bottomk(10, sum without (job) (rate(foo[5m])))'
          op: bottomk
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 21
        end: 28
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/79 - 1]
expr: foo or bar
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/80 - 1]
expr: foo or bar or baz
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] baz'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 17
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/81 - 1]
expr: (foo or bar) or baz
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 4
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 11
      type: selector
      fixedlabels: false
      isconditional: false
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] baz'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 16
        end: 19
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/82 - 1]
expr: foo unless bar
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless:
        - "on": []
          ignoring: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 11
                end: 14
            type: selector
            fixedlabels: false
            isconditional: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/83 - 1]
expr: foo unless bar > 5
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless:
        - "on": []
          ignoring: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 11
                end: 14
            type: selector
            fixedlabels: false
            isconditional: true
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/84 - 1]
expr: foo unless bar unless baz
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless:
        - "on": []
          ignoring: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 11
                end: 14
            type: selector
            fixedlabels: false
            isconditional: false
        - "on": []
          ignoring: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] baz'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 22
                end: 25
            type: selector
            fixedlabels: false
            isconditional: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/85 - 1]
expr: count(sum(up{job="foo", cluster="dev"}) by(job, cluster) == 0) without(job, cluster)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 40
                end: 42
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 84
        cluster:
            reason: Query is using aggregation with `without(job, cluster)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 63
                end: 70
        job:
            reason: Query is using aggregation with `without(job, cluster)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 63
                end: 70
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{cluster="dev",job="foo"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job, cluster) (up{cluster="dev",job="foo"})'
          op: sum
        - node: '[*parser.AggregateExpr] count without (job, cluster) (sum by (job, cluster) (up{cluster="dev",job="foo"}) == 0)'
          op: count
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 10
        end: 38
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/86 - 1]
expr: year()
output:
    - labels:
        "":
            reason: Calling `year()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.Call] year()'
          op: year
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 6
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/87 - 1]
expr: year(foo)
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] year(foo)'
          op: year
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/88 - 1]
expr: label_join(up{job="api-server",src1="a",src2="b",src3="c"}, "foo", ",", "src1", "src2", "src3")
output:
    - labels:
        foo:
            reason: This label will be added to the result by label_join() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 95
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src1:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src2:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
        src3:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 11
                end: 58
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="api-server",src1="a",src2="b",src3="c"}'
          op: ""
        - args:
            - '"foo"'
            - '","'
            - '"src1"'
            - '"src2"'
            - '"src3"'
          node: '[*parser.Call] label_join(up{job="api-server",src1="a",src2="b",src3="c"}, "foo", ",", "src1", "src2", "src3")'
          op: label_join
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 11
        end: 58
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/89 - 1]
expr: |4-

    (
     sum(foo:sum > 0) without(notify)
     * on(job) group_left(notify)
     job:notify
    )
    and on(job)
    sum(foo:count) by(job) > 20
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 4
                end: 78
        job:
            reason: Query is using many-to-many vector matching with `on(job)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 40
                end: 42
        notify:
            reason: Query is using many-to-one vector matching with `group_left(notify)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 48
                end: 58
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo:sum'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (notify) (foo:sum > 0)'
          op: sum
      joins:
        - "on":
            - job
          ignoring: []
          addedlabels:
            - notify
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] job:notify'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 68
                end: 78
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
        - "on":
            - job
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 108
                        end: 110
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 93
                        end: 115
                job:
                    reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 108
                        end: 110
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo:count'
                  op: ""
                - node: '[*parser.AggregateExpr] sum by (job) (foo:count)'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 97
                end: 106
            type: aggregation
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 15
      type: aggregation
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/90 - 1]
expr: container_file_descriptors / on (instance, app_name) container_ulimits_soft{ulimit="max_open_files"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 29
                end: 32
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 100
        app_name:
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 29
                end: 32
        instance:
            reason: Query is using one-to-one vector matching with `on(instance, app_name)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 29
                end: 32
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] container_file_descriptors'
          op: ""
      joins:
        - "on":
            - instance
            - app_name
          ignoring: []
          addedlabels: []
          src:
            labels:
                ulimit:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 53
                        end: 100
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] container_ulimits_soft{ulimit="max_open_files"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 53
                end: 100
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 26
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/91 - 1]
expr: container_file_descriptors / on (instance, app_name) group_left() container_ulimits_soft{ulimit="max_open_files"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 113
        app_name:
            reason: Query is using many-to-one vector matching with `on(instance, app_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 29
                end: 32
        instance:
            reason: Query is using many-to-one vector matching with `on(instance, app_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 29
                end: 32
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] container_file_descriptors'
          op: ""
      joins:
        - "on":
            - instance
            - app_name
          ignoring: []
          addedlabels: []
          src:
            labels:
                ulimit:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 66
                        end: 113
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] container_ulimits_soft{ulimit="max_open_files"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 66
                end: 113
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57384
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 26
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/92 - 1]
expr: absent(foo{job="bar"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 22
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="bar"}'
          op: ""
        - node: '[*parser.Call] absent(foo{job="bar"})'
          op: absent
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 21
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/93 - 1]
expr: absent(foo{job="bar", cluster!="dev", instance=~".+", env="prod"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        env:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 66
        instance:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 66
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{cluster!="dev",env="prod",instance=~".+",job="bar"}'
          op: ""
        - node: '[*parser.Call] absent(foo{cluster!="dev",env="prod",instance=~".+",job="bar"})'
          op: absent
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 65
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/94 - 1]
expr: absent(sum(foo) by(job, instance))
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 7
                end: 33
        instance:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job, instance) (foo)'
          op: sum
        - node: '[*parser.Call] absent(sum by (job, instance) (foo))'
          op: absent
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 33
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/95 - 1]
expr: absent(foo{job="prometheus", xxx="1"}) AND on(job) prometheus_build_info
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
        xxx:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 0
                end: 38
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="prometheus",xxx="1"}'
          op: ""
        - node: '[*parser.Call] absent(foo{job="prometheus",xxx="1"})'
          op: absent
      joins:
        - "on":
            - job
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] prometheus_build_info'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 51
                end: 72
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 37
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/96 - 1]
expr: 1 + sum(foo) by(notjob)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(notjob)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 4
                end: 23
        notjob:
            reason: Query is using aggregation with `by(notjob)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (notjob) (foo)'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 11
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/97 - 1]
expr: count(node_exporter_build_info) by (instance, version) != ignoring(package,version) group_left(foo) count(deb_package_version) by (instance, version, package)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 32
                end: 35
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 158
        foo:
            reason: Query is using many-to-one vector matching with `group_left(foo)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 84
                end: 94
        instance:
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 32
                end: 35
        version:
            reason: Query is using aggregation with `by(instance, version)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 32
                end: 35
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] node_exporter_build_info'
          op: ""
        - node: '[*parser.AggregateExpr] count by (instance, version) (node_exporter_build_info)'
          op: count
      joins:
        - "on": []
          ignoring:
            - package
            - version
          addedlabels:
            - foo
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 127
                        end: 130
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 100
                        end: 158
                instance:
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 127
                        end: 130
                package:
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 127
                        end: 130
                version:
                    reason: Query is using aggregation with `by(instance, version, package)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 127
                        end: 130
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] deb_package_version'
                  op: ""
                - node: '[*parser.AggregateExpr] count by (instance, version, package) (deb_package_version)'
                  op: count
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 106
                end: 125
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57396
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 6
        end: 30
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/98 - 1]
expr: absent(foo) or absent(bar)
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] absent(foo)'
          op: absent
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 10
      type: function
      fixedlabels: true
      isconditional: false
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 15
                end: 21
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
        - node: '[*parser.Call] absent(bar)'
          op: absent
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 22
        end: 25
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/99 - 1]
expr: absent_over_time(foo[5m]) or absent(bar)
output:
    - labels:
        "":
            reason: |-
                The [absent_over_time()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent_over_time) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 0
                end: 16
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.Call] absent_over_time(foo[5m])'
          op: absent_over_time
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 17
        end: 24
      type: function
      fixedlabels: true
      isconditional: false
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 29
                end: 35
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar'
          op: ""
        - node: '[*parser.Call] absent(bar)'
          op: absent
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 36
        end: 39
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/100 - 1]
expr: bar * on() group_right(cluster, env) absent(foo{job="xxx"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 37
                end: 43
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 59
        cluster:
            reason: Query is using one-to-many vector matching with `group_right(cluster, env)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 11
                end: 22
        env:
            reason: Query is using one-to-many vector matching with `group_right(cluster, env)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 11
                end: 22
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 37
                end: 59
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="xxx"}'
          op: ""
        - node: '[*parser.Call] absent(foo{job="xxx"})'
          op: absent
      joins:
        - "on": []
          ignoring: []
          addedlabels:
            - cluster
            - env
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 3
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 44
        end: 58
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/101 - 1]
expr: bar * on() group_right() absent(foo{job="xxx"})
output:
    - labels:
        "":
            reason: |-
                The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                You will only get any results back if the metric selector you pass doesn't match anything.
                Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                This means that the only labels you can get back from absent call are the ones you pass to it.
                If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
            kind: excluded
            fragment:
                start: 25
                end: 31
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 47
        job:
            reason: All labels passed to absent() call will be present on the results if the query doesn't match anything.
            kind: guaranteed
            fragment:
                start: 25
                end: 47
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="xxx"}'
          op: ""
        - node: '[*parser.Call] absent(foo{job="xxx"})'
          op: absent
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 3
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 32
        end: 46
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/102 - 1]
expr: vector(1)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/103 - 1]
expr: vector(scalar(foo))
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      returns: vector
      operations:
        - args:
            - scalar(foo)
          node: '[*parser.Call] vector(scalar(foo))'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 19
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 19
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/104 - 1]
expr: vector(0.0  >= bool 0.5) == 1
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo:
        reason: '`vector(0.0  >= bool 0.5) == 1` always evaluates to `0 == 1` which is not possible, so it will never return anything.'
        fragment:
            start: 0
            end: 24
      returns: vector
      operations:
        - args:
            - 0 >= bool 0.5
          node: '[*parser.Call] vector(0 >= bool 0.5)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 24
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 24
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/105 - 1]
expr: sum_over_time(foo{job="myjob"}[5m])
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 35
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.Call] sum_over_time(foo{job="myjob"}[5m])'
          op: sum_over_time
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 34
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/106 - 1]
expr: days_in_month()
output:
    - labels:
        "":
            reason: Calling `days_in_month()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 15
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.Call] days_in_month()'
          op: days_in_month
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 15
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/107 - 1]
expr: days_in_month(foo{job="foo"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 29
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="foo"}'
          op: ""
        - node: '[*parser.Call] days_in_month(foo{job="foo"})'
          op: days_in_month
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 28
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/108 - 1]
expr: label_replace(up{job="api-server",service="a:c"}, "foo", "$1", "service", "(.*):.*")
output:
    - labels:
        foo:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 84
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 14
                end: 48
        service:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 14
                end: 48
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{job="api-server",service="a:c"}'
          op: ""
        - args:
            - '"foo"'
            - '"$1"'
            - '"service"'
            - '"(.*):.*"'
          node: '[*parser.Call] label_replace(up{job="api-server",service="a:c"}, "foo", "$1", "service", "(.*):.*")'
          op: label_replace
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 48
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/109 - 1]
expr: label_replace(sum by (pod) (pod_status) > 0, "cluster", "$1", "pod", "(.*)")
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(pod)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 18
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 14
                end: 39
        cluster:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 76
        pod:
            reason: Query is using aggregation with `by(pod)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 18
                end: 21
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] pod_status'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (pod) (pod_status)'
          op: sum
        - args:
            - '"cluster"'
            - '"$1"'
            - '"pod"'
            - '"(.*)"'
          node: '[*parser.Call] label_replace(sum by (pod) (pod_status) > 0, "cluster", "$1", "pod", "(.*)")'
          op: label_replace
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 43
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/110 - 1]
expr: (time() - my_metric) > 5*3600
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] my_metric'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 10
        end: 19
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/111 - 1]
expr: up{instance="a", job="prometheus"} * ignoring(job) up{instance="a", job="pint"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 79
        instance:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using one-to-one vector matching with `ignoring(job)`, all labels included inside `ignoring(...)` will be removed on the results.
            kind: excluded
            fragment:
                start: 37
                end: 45
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] up{instance="a",job="prometheus"}'
          op: ""
      joins:
        - "on": []
          ignoring:
            - job
          addedlabels: []
          src:
            labels:
                instance:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 51
                        end: 79
                job:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 51
                        end: 79
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] up{instance="a",job="pint"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 51
                end: 79
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 34
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/112 - 1]
expr: |4

    avg without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"})
    < 0.5 > 0
    or sum without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"})
    < on() count(colo_router_tier:disabled_pops:max{tier="1",router=~"edge.*"}) * 0.4 > 0
    or avg without(router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"})
    < 0.1 > 0
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 101
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 5
                end: 12
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 5
                end: 12
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 5
                end: 12
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"}'
          op: ""
        - node: '[*parser.AggregateExpr] avg without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case!~".*offpeak.*"})'
          op: avg
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 41
        end: 100
      type: aggregation
      fixedlabels: false
      isconditional: true
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 216
                end: 218
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 115
                end: 295
        cidr_use_case:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 216
                end: 218
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 119
                end: 126
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 119
                end: 126
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 119
                end: 126
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*tier1.*"})'
          op: sum
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 289
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 289
                router:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 289
                tier:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 221
                        end: 289
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_router_tier:disabled_pops:max{router=~"edge.*",tier="1"}'
                  op: ""
                - node: '[*parser.AggregateExpr] count(colo_router_tier:disabled_pops:max{router=~"edge.*",tier="1"})'
                  op: count
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 227
                end: 288
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57391
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 155
        end: 212
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 303
                end: 404
        cidr_use_case:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 343
                end: 403
        colo_id:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 307
                end: 314
        instance:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 307
                end: 314
        router:
            reason: Query is using aggregation with `without(router, colo_id, instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 307
                end: 314
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"}'
          op: ""
        - node: '[*parser.AggregateExpr] avg without (router, colo_id, instance) (router_anycast_prefix_enabled{cidr_use_case=~".*regional.*"})'
          op: avg
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 343
        end: 403
      type: aggregation
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/113 - 1]
expr: label_replace(sum(foo) without(instance), "instance", "none", "", "")
output:
    - labels:
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 14
                end: 40
        instance:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 69
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (instance) (foo)'
          op: sum
        - args:
            - '"instance"'
            - '"none"'
            - '""'
            - '""'
          node: '[*parser.Call] label_replace(sum without (instance) (foo), "instance", "none", "", "")'
          op: label_replace
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 14
        end: 40
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/114 - 1]
expr: |4-

    sum by (region, target, colo_name) (
        sum_over_time(probe_success{job="abc"}[5m])
     or
     vector(1)
    ) == 0
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 102
        colo_name:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        job:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        region:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        target:
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] probe_success{job="abc"}'
          op: ""
        - node: '[*parser.Call] sum_over_time(probe_success{job="abc"}[5m])'
          op: sum_over_time
        - node: '[*parser.AggregateExpr] sum by (region, target, colo_name) (sum_over_time(probe_success{job="abc"}[5m]) or vector(1))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 56
        end: 84
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation with `by(region, target, colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 102
        colo_name:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
        region:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
        target:
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 91
                end: 97
      deadinfo:
        reason: '`vector(1) == 0` always evaluates to `1 == 0` which is not possible, so it will never return anything.'
        fragment:
            start: 91
            end: 100
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
        - node: '[*parser.AggregateExpr] sum by (region, target, colo_name) (sum_over_time(probe_success{job="abc"}[5m]) or vector(1))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 91
            end: 100
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 91
        end: 100
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/115 - 1]
expr: vector(1) or foo
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo: null
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedlabels: true
      isconditional: false
    - labels: {}
      deadinfo:
        reason: The left hand side always returs something and so the right hand side is never used.
        fragment:
            start: 13
            end: 16
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 13
        end: 16
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/116 - 1]
expr: vector(0) > 0
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
      deadinfo:
        reason: '`vector(0) > 0` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 0
            end: 9
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/117 - 1]
expr: vector(0) > vector(1)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 6
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo:
        reason: '`vector(0) > vector(1)` always evaluates to `0 > 1` which is not possible, so it will never return anything.'
        fragment:
            start: 0
            end: 9
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 12
                        end: 18
            deadinfo: null
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 12
                    end: 21
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 12
                end: 21
            type: function
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 9
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 0
        end: 9
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/118 - 1]
expr: sum(foo or vector(0)) > 0
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo or vector(0))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 7
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 21
      deadinfo:
        reason: '`vector(0) > 0` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 11
            end: 20
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(foo or vector(0))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 11
            end: 20
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 11
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/119 - 1]
expr: (sum(foo or vector(1)) > 0) == 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo or vector(1))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo:
        reason: '`vector(1) == 2` always evaluates to `1 == 2` which is not possible, so it will never return anything.'
        fragment:
            start: 12
            end: 21
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(foo or vector(1))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 12
            end: 21
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/120 - 1]
expr: (sum(foo or vector(1)) > 0) != 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo or vector(1))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo: null
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(foo or vector(1))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 12
            end: 21
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/121 - 1]
expr: (sum(foo or vector(2)) > 0) != 2
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo or vector(2))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
      deadinfo:
        reason: '`vector(2) != 2` always evaluates to `2 != 2` which is not possible, so it will never return anything.'
        fragment:
            start: 12
            end: 21
      returns: vector
      operations:
        - args:
            - "2"
          node: '[*parser.Call] vector(2)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(foo or vector(2))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 12
            end: 21
        returnednumber: 2
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/122 - 1]
expr: |-
    (sum(sometimes{foo!="bar"} or vector(0)))
    or
    ((bob > 10) or sum(foo) or vector(1))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 40
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] sometimes{foo!="bar"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(sometimes{foo!="bar"} or vector(0))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 26
      type: aggregation
      fixedlabels: true
      isconditional: false
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 40
      deadinfo: null
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
        - node: '[*parser.AggregateExpr] sum(sometimes{foo!="bar"} or vector(0))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 30
            end: 39
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 30
        end: 39
      type: aggregation
      fixedlabels: true
      isconditional: false
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bob'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 47
        end: 50
      type: selector
      fixedlabels: false
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 60
                end: 63
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 60
                end: 68
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo)'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 64
        end: 67
      type: aggregation
      fixedlabels: true
      isconditional: false
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 72
                end: 78
      deadinfo: null
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 72
            end: 81
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 72
        end: 81
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/123 - 1]
expr: |4-

    (
     sum(sometimes{foo!="bar"})
     or
     vector(1)
    ) and (
     ((bob > 10) or sum(bar))
     or
     notfound > 0
    )
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 4
                end: 7
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 4
                end: 30
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] sometimes{foo!="bar"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(sometimes{foo!="bar"})'
          op: sum
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bob'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 57
                end: 60
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 73
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 78
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar)'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 74
                end: 77
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57389
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] notfound'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 85
                end: 93
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 29
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 36
                end: 42
      deadinfo: null
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bob'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 57
                end: 60
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 73
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 70
                        end: 78
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar)'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 74
                end: 77
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57389
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] notfound'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 85
                end: 93
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 36
            end: 45
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 36
        end: 45
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/124 - 1]
expr: foo offset 5m > 5
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo offset 5m'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 13
      type: selector
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/125 - 1]
expr: |4

    (rate(metric2[5m]) or vector(0)) +
    (rate(metric1[5m]) or vector(1)) +
    (rate(metric3{log_name="samplerd"}[5m]) or vector(2)) > 0
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 124
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] metric2'
          op: ""
        - node: '[*parser.Call] rate(metric2[5m])'
          op: rate
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metric1'
                  op: ""
                - node: '[*parser.Call] rate(metric1[5m])'
                  op: rate
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 42
                end: 53
            type: function
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 58
                        end: 64
            deadinfo: null
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 58
                    end: 67
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 58
                end: 67
            type: function
            fixedlabels: true
            isconditional: false
          op: 57383
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                log_name:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 72
                        end: 110
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metric3{log_name="samplerd"}'
                  op: ""
                - node: '[*parser.Call] rate(metric3{log_name="samplerd"}[5m])'
                  op: rate
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 77
                end: 109
            type: function
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 114
                        end: 120
            deadinfo: null
            returns: vector
            operations:
                - args:
                    - "2"
                  node: '[*parser.Call] vector(2)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 114
                    end: 123
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 114
                end: 123
            type: function
            fixedlabels: true
            isconditional: false
          op: 57383
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 7
        end: 18
      type: function
      fixedlabels: false
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 23
                end: 29
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 124
      deadinfo: null
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metric1'
                  op: ""
                - node: '[*parser.Call] rate(metric1[5m])'
                  op: rate
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 42
                end: 53
            type: function
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 58
                        end: 64
            deadinfo: null
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 58
                    end: 67
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 58
                end: 67
            type: function
            fixedlabels: true
            isconditional: false
          op: 57383
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                log_name:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 72
                        end: 110
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] metric3{log_name="samplerd"}'
                  op: ""
                - node: '[*parser.Call] rate(metric3{log_name="samplerd"}[5m])'
                  op: rate
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 77
                end: 109
            type: function
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 114
                        end: 120
            deadinfo: null
            returns: vector
            operations:
                - args:
                    - "2"
                  node: '[*parser.Call] vector(2)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 114
                    end: 123
                returnednumber: 2
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 114
                end: 123
            type: function
            fixedlabels: true
            isconditional: false
          op: 57383
          depth: 0
      unless: []
      returninfo:
        logicalexpr: vector(0) + vector(1) + vector(2)
        valueposition:
            start: 23
            end: 32
        returnednumber: 3
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 23
        end: 32
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/126 - 1]
expr: label_replace(vector(1), "nexthop_tag", "$1", "nexthop", "(.+)")
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 14
                end: 20
        nexthop_tag:
            reason: This label will be added to the result by label_replace() call.
            kind: guaranteed
            fragment:
                start: 0
                end: 64
      deadinfo: null
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
        - args:
            - '"nexthop_tag"'
            - '"$1"'
            - '"nexthop"'
            - '"(.+)"'
          node: '[*parser.Call] label_replace(vector(1), "nexthop_tag", "$1", "nexthop", "(.+)")'
          op: label_replace
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 14
            end: 23
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 14
        end: 23
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/127 - 1]
expr: (sum(foo{job="myjob"}))
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 22
        job:
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 1
                end: 4
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum(foo{job="myjob"})'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 21
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/128 - 1]
expr: (-foo{job="myjob"})
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 2
                end: 18
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{job="myjob"}'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 2
        end: 18
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/129 - 1]
expr: |4-

    ((( group(vector(0)) ))) > 0
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 5
                end: 21
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 5
                end: 21
      deadinfo:
        reason: '`vector(0) > 0` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 11
            end: 20
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
        - node: '[*parser.AggregateExpr] group(vector(0))'
          op: group
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 11
            end: 20
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 11
        end: 20
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/130 - 1]
expr: 1 > bool 5
output:
    - labels:
        "":
            reason: This query returns a number value with no labels.
            kind: excluded
            fragment:
                start: 0
                end: 1
      deadinfo:
        reason: '`1 > 5` always evaluates to `1 > 5` and uses the `bool` modifier which means it will always return 0'
        fragment:
            start: 0
            end: 1
      returns: scalar
      operations: []
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: true
      position:
        start: 0
        end: 1
      type: number
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/131 - 1]
expr: prometheus_ready{job="prometheus"} unless vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
          op: ""
      joins: []
      unless:
        - "on": []
          ignoring: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 48
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `job` label while the left hand side will. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 42
                    end: 48
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 42
                    end: 51
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 42
                end: 51
            type: function
            fixedlabels: true
            isconditional: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 34
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/132 - 1]
expr: prometheus_ready{job="prometheus"} unless on() vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      deadinfo:
        reason: This query will never return anything because the `unless` query always returns something.
        fragment:
            start: 47
            end: 56
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
          op: ""
      joins: []
      unless:
        - "on": []
          ignoring: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 47
                        end: 53
            deadinfo: null
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 47
                    end: 56
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 47
                end: 56
            type: function
            fixedlabels: true
            isconditional: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 34
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/133 - 1]
expr: prometheus_ready{job="prometheus"} unless on(job) vector(0)
output:
    - labels:
        job:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 34
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_ready{job="prometheus"}'
          op: ""
      joins: []
      unless:
        - "on":
            - job
          ignoring: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 50
                        end: 56
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `job` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 50
                    end: 56
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 50
                    end: 59
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 50
                end: 59
            type: function
            fixedlabels: true
            isconditional: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 34
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/134 - 1]
expr: |4

    max by (instance, cluster) (cf_node_role{kubernetes_role="master",role="kubernetes"})
    unless
       sum by (instance, cluster) (time() - node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"})
       * on (instance) group_left (cluster)
        cf_node_role{kubernetes_role="master",role="kubernetes"}
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 86
        cluster:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        instance:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        kubernetes_role:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        role:
            reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] cf_node_role{kubernetes_role="master",role="kubernetes"}'
          op: ""
        - node: '[*parser.AggregateExpr] max by (instance, cluster) (cf_node_role{kubernetes_role="master",role="kubernetes"})'
          op: max
      joins: []
      unless:
        - "on": []
          ignoring: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 99
                        end: 102
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 95
                        end: 303
                cluster:
                    reason: Query is using many-to-one vector matching with `group_left(cluster)`, all labels included inside `group_left(...)` will be include on the results.
                    kind: included
                    fragment:
                        start: 222
                        end: 233
                instance:
                    reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 208
                        end: 211
                name:
                    reason: Query is using aggregation with `by(instance, cluster)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 99
                        end: 102
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum by (instance, cluster) (time() - node_systemd_timer_last_trigger_seconds{name=~"etcd-defrag-.*.timer"})'
                  op: sum
            joins:
                - "on":
                    - instance
                  ignoring: []
                  addedlabels:
                    - cluster
                  src:
                    labels:
                        kubernetes_role:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 247
                                end: 303
                        role:
                            reason: Query will only return series where these labels are present.
                            kind: guaranteed
                            fragment:
                                start: 247
                                end: 303
                    deadinfo: null
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] cf_node_role{kubernetes_role="master",role="kubernetes"}'
                          op: ""
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 247
                        end: 303
                    type: selector
                    fixedlabels: false
                    isconditional: false
                  op: 57395
                  depth: 0
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 132
                end: 201
            type: aggregation
            fixedlabels: true
            isconditional: false
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 29
        end: 85
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/135 - 1]
expr: foo{a="1"} * on() bar{b="2"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 28
        a:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 18
                        end: 28
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 18
                end: 28
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/136 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) bar{b="2"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 52
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        d:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels:
            - c
            - d
          src:
            labels:
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 42
                        end: 52
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 42
                end: 52
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/137 - 1]
expr: foo{a="1"} * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 53
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 43
                end: 53
        c:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 37
        d:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 37
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{b="2"}'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels:
            - c
            - d
          src:
            labels:
                a:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 0
                        end: 10
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{a="1"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 10
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 43
        end: 53
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/138 - 1]
expr: foo{a="1"} * on(instance) sum(bar{b="2"})
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 41
        a:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 13
                end: 15
        instance:
            reason: Query is using one-to-one vector matching with `on(instance)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 26
                        end: 29
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 26
                        end: 41
                b:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 26
                        end: 29
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 26
                    end: 29
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar{b="2"})'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 30
                end: 40
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/139 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) sum(bar{b="2"})
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 57
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        d:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels:
            - c
            - d
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 45
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 57
                b:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 45
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 42
                    end: 45
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(bar{b="2"})'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 46
                end: 56
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/140 - 1]
expr: sum(foo{a="1"}) * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 58
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 48
                end: 58
        c:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 31
                end: 42
        d:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 31
                end: 42
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 18
                end: 20
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{b="2"}'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels:
            - c
            - d
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 3
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 15
                a:
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 3
            deadinfo:
                reason: The left hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation that removes all labels.
                fragment:
                    start: 0
                    end: 3
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{a="1"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(foo{a="1"})'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 4
                end: 14
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 48
        end: 58
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/141 - 1]
expr: foo{a="1"} * on(instance) group_left(c,d) sum(bar{b="2"}) without(instance)
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 75
        a:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 0
                end: 10
        c:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        d:
            reason: Query is using many-to-one vector matching with `group_left(c, d)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 26
                end: 36
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 13
                end: 15
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels:
            - c
            - d
          src:
            labels:
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 42
                        end: 75
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 46
                        end: 56
                instance:
                    reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                    kind: excluded
                    fragment:
                        start: 58
                        end: 65
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                fragment:
                    start: 58
                    end: 65
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum without (instance) (bar{b="2"})'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 46
                end: 56
            type: aggregation
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 10
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/142 - 1]
expr: sum(foo{a="1"}) without(instance) * on(instance) group_right(c,d) bar{b="2"}
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 76
        b:
            reason: Query will only return series where these labels are present.
            kind: guaranteed
            fragment:
                start: 66
                end: 76
        c:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 49
                end: 60
        d:
            reason: Query is using one-to-many vector matching with `group_right(c, d)`, all labels included inside `group_right(...)` will be include on the results.
            kind: included
            fragment:
                start: 49
                end: 60
        instance:
            reason: Query is using one-to-many vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 36
                end: 38
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] bar{b="2"}'
          op: ""
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels:
            - c
            - d
          src:
            labels:
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 0
                        end: 33
                a:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 4
                        end: 14
                instance:
                    reason: Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                    kind: excluded
                    fragment:
                        start: 16
                        end: 23
            deadinfo:
                reason: The left hand side will never be matched because it doesn't have the `instance` label from `on(...)`. Query is using aggregation with `without(instance)`, all labels included inside `without(...)` will be removed from the results.
                fragment:
                    start: 16
                    end: 23
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo{a="1"}'
                  op: ""
                - node: '[*parser.AggregateExpr] sum without (instance) (foo{a="1"})'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 4
                end: 14
            type: aggregation
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 66
        end: 76
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/143 - 1]
expr: |4

     max without (source_instance) (
       increase(kernel_device_io_errors_total{device!~"loop.+"}[120m]) > 3 unless on(instance, device) (
         increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[125m])*2 > increase(kernel_device_io_errors_total[120m])
       )
       and on(device, instance) absent(node_disk_info)
     ) * on(instance) group_left(group) label_replace(salt_highstate_runner_configured_minions, "instance", "$1", "minion", "(.+)")
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 2
                end: 442
        device:
            reason: Query is using many-to-many vector matching with `on(device, instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 112
                end: 114
        group:
            reason: Query is using many-to-one vector matching with `group_left(group)`, all labels included inside `group_left(...)` will be include on the results.
            kind: included
            fragment:
                start: 333
                end: 343
        instance:
            reason: Query is using many-to-one vector matching with `on(instance)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 112
                end: 114
        source_instance:
            reason: Query is using aggregation with `without(source_instance)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 6
                end: 14
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] kernel_device_io_errors_total{device!~"loop.+"}'
          op: ""
        - node: '[*parser.Call] increase(kernel_device_io_errors_total{device!~"loop.+"}[2h])'
          op: increase
        - node: '[*parser.AggregateExpr] max without (source_instance) (increase(kernel_device_io_errors_total{device!~"loop.+"}[2h]) > 3 unless on (instance, device) (increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[2h5m]) * 2 > increase(kernel_device_io_errors_total[2h])) and on (device, instance) absent(node_disk_info))'
          op: max
      joins:
        - "on":
            - device
            - instance
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: |-
                        The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                        You will only get any results back if the metric selector you pass doesn't match anything.
                        Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                        This means that the only labels you can get back from absent call are the ones you pass to it.
                        If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
                    kind: excluded
                    fragment:
                        start: 292
                        end: 298
            deadinfo:
                reason: |-
                    The right hand side will never be matched because it doesn't have the `device` label from `on(...)`. The [absent()](https://prometheus.io/docs/prometheus/latest/querying/functions/#absent) function is used to check if provided query doesn't match any time series.
                    You will only get any results back if the metric selector you pass doesn't match anything.
                    Since there are no matching time series there are also no labels. If some time series is missing you cannot read its labels.
                    This means that the only labels you can get back from absent call are the ones you pass to it.
                    If you're hoping to get instance specific labels this way and alert when some target is down then that won't work, use the `up` metric instead.
                fragment:
                    start: 292
                    end: 298
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] node_disk_info'
                  op: ""
                - node: '[*parser.Call] absent(node_disk_info)'
                  op: absent
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 299
                end: 313
            type: function
            fixedlabels: true
            isconditional: false
          op: 57389
          depth: 1
        - "on":
            - instance
          ignoring: []
          addedlabels:
            - group
          src:
            labels:
                instance:
                    reason: This label will be added to the result by label_replace() call.
                    kind: guaranteed
                    fragment:
                        start: 351
                        end: 442
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] salt_highstate_runner_configured_minions'
                  op: ""
                - args:
                    - '"instance"'
                    - '"$1"'
                    - '"minion"'
                    - '"(.+)"'
                  node: '[*parser.Call] label_replace(salt_highstate_runner_configured_minions, "instance", "$1", "minion", "(.+)")'
                  op: label_replace
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 365
                end: 405
            type: function
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless:
        - "on":
            - instance
            - device
          ignoring: []
          src:
            labels:
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 140
                        end: 258
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] kernel_device_io_soft_errors_total{device!~"loop.+"}'
                  op: ""
                - node: '[*parser.Call] increase(kernel_device_io_soft_errors_total{device!~"loop.+"}[2h5m])'
                  op: increase
            joins:
                - "on": []
                  ignoring: []
                  addedlabels: []
                  src:
                    labels: {}
                    deadinfo: null
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] kernel_device_io_errors_total'
                          op: ""
                        - node: '[*parser.Call] increase(kernel_device_io_errors_total[2h])'
                          op: increase
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 222
                        end: 257
                    type: function
                    fixedlabels: false
                    isconditional: false
                  op: 57388
                  depth: 0
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 149
                end: 207
            type: function
            fixedlabels: false
            isconditional: true
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 46
        end: 99
      type: aggregation
      fixedlabels: false
      isconditional: true

---

[TestLabelsSource/144 - 1]
expr: sum(foo{a="1"}) by(job) * on() bar{b="2"}
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 26
                end: 28
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 41
        a:
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 16
                end: 18
        job:
            reason: Query is using one-to-one vector matching with `on()`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 26
                end: 28
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo{a="1"}'
          op: ""
        - node: '[*parser.AggregateExpr] sum by (job) (foo{a="1"})'
          op: sum
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                b:
                    reason: Query will only return series where these labels are present.
                    kind: guaranteed
                    fragment:
                        start: 31
                        end: 41
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] bar{b="2"}'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 31
                end: 41
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 14
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/145 - 1]
expr: sum(sum(foo) without(job)) by(job)
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(job)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 27
                end: 29
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 34
        job:
            reason: Query is using aggregation with `without(job)`, all labels included inside `without(...)` will be removed from the results.
            kind: excluded
            fragment:
                start: 13
                end: 20
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
        - node: '[*parser.AggregateExpr] sum without (job) (foo)'
          op: sum
        - node: '[*parser.AggregateExpr] sum by (job) (sum without (job) (foo))'
          op: sum
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 8
        end: 11
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/146 - 1]
expr: |4

    prometheus:scrape_series_added:since_gc:sum
    * on(prometheus) group_left()
    label_replace(
      max(max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])) by(instance)
      /
      max(max_over_time(prometheus_tsdb_head_series[2h])) by(instance),
      "prometheus", "$1",
      "instance", "(.+)"
    )
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 287
        prometheus:
            reason: Query is using many-to-one vector matching with `on(prometheus)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 47
                end: 49
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus:scrape_series_added:since_gc:sum'
          op: ""
      joins:
        - "on":
            - prometheus
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 158
                        end: 160
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 92
                        end: 241
                instance:
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 158
                        end: 160
                job:
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 158
                        end: 160
                prometheus:
                    reason: This label will be added to the result by label_replace() call.
                    kind: guaranteed
                    fragment:
                        start: 75
                        end: 287
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] go_memstats_alloc_bytes{job="prometheus"}'
                  op: ""
                - node: '[*parser.Call] max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])'
                  op: max_over_time
                - node: '[*parser.AggregateExpr] max by (instance) (max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h]))'
                  op: max
                - args:
                    - '"prometheus"'
                    - '"$1"'
                    - '"instance"'
                    - '"(.+)"'
                  node: '[*parser.Call] label_replace(max by (instance) (max_over_time(go_memstats_alloc_bytes{job="prometheus"}[2h])) / max by (instance) (max_over_time(prometheus_tsdb_head_series[2h])), "prometheus", "$1", "instance", "(.+)")'
                  op: label_replace
            joins:
                - "on": []
                  ignoring: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 229
                                end: 231
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 177
                                end: 241
                        instance:
                            reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 229
                                end: 231
                    deadinfo: null
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] prometheus_tsdb_head_series'
                          op: ""
                        - node: '[*parser.Call] max_over_time(prometheus_tsdb_head_series[2h])'
                          op: max_over_time
                        - node: '[*parser.AggregateExpr] max by (instance) (max_over_time(prometheus_tsdb_head_series[2h]))'
                          op: max
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 195
                        end: 226
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 92
                end: 241
            type: function
            fixedlabels: true
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 44
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/147 - 1]
expr: (day_of_week() == 6 and hour() < 1) or vector(1)
output:
    - labels:
        "":
            reason: Calling `day_of_week()` with no arguments will return an empty time series with no labels.
            kind: excluded
            fragment:
                start: 1
                end: 14
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.Call] day_of_week()'
          op: day_of_week
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `hour()` with no arguments will return an empty time series with no labels.
                    kind: excluded
                    fragment:
                        start: 24
                        end: 30
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.Call] hour()'
                  op: hour
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: true
                knownreturn: false
                isreturnbool: false
            position:
                start: 24
                end: 30
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: true
        knownreturn: false
        isreturnbool: false
      position:
        start: 1
        end: 14
      type: function
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 39
                end: 45
      deadinfo: null
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 39
            end: 48
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 39
        end: 48
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/148 - 1]
expr: |4-

    sum by (foo, bar) (
        rate(errors_total[5m])
      * on (instance) group_left (bob, alice)
        server_errors_total
    )
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 115
        alice:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        bar:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        bob:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
        foo:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 5
                end: 8
        instance:
            reason: Query is using aggregation with `by(foo, bar)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 5
                end: 8
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] errors_total'
          op: ""
        - node: '[*parser.Call] rate(errors_total[5m])'
          op: rate
        - node: '[*parser.AggregateExpr] sum by (foo, bar) (rate(errors_total[5m]) * on (instance) group_left (bob, alice) server_errors_total)'
          op: sum
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels:
            - bob
            - alice
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] server_errors_total'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 94
                end: 113
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 1
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 30
        end: 46
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/149 - 1]
expr: 1 - (foo or vector(0)) < 0.999
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 5
        end: 8
      type: selector
      fixedlabels: false
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 12
                end: 18
      deadinfo:
        reason: '`1 - vector(0) < 0.999` always evaluates to `1 < 0.999` which is not possible, so it will never return anything.'
        fragment:
            start: 12
            end: 21
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: 1 - vector(0)
        valueposition:
            start: 0
            end: 1
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 12
        end: 21
      type: function
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/150 - 1]
expr: |4

    (
      vector(1) and month() == 2
    ) or vector(0)
output:
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 5
                end: 11
      deadinfo: null
      returns: vector
      operations:
        - args:
            - "1"
          node: '[*parser.Call] vector(1)'
          op: vector
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `month()` with no arguments will return an empty time series with no labels.
                    kind: excluded
                    fragment:
                        start: 19
                        end: 26
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.Call] month()'
                  op: month
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: true
                knownreturn: false
                isreturnbool: false
            position:
                start: 19
                end: 26
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 5
            end: 14
        returnednumber: 1
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 5
        end: 14
      type: function
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Calling `vector()` will return a vector value with no labels.
            kind: excluded
            fragment:
                start: 37
                end: 43
      deadinfo: null
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 37
            end: 46
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 37
        end: 46
      type: function
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/151 - 1]
expr: count by (region) (stddev by (colo_name, region) (error_total))
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 9
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 0
                end: 63
        colo_name:
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 9
        region:
            reason: Query is using aggregation with `by(region)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 6
                end: 9
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] error_total'
          op: ""
        - node: '[*parser.AggregateExpr] stddev by (colo_name, region) (error_total)'
          op: stddev
        - node: '[*parser.AggregateExpr] count by (region) (stddev by (colo_name, region) (error_total))'
          op: count
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 50
        end: 61
      type: aggregation
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/152 - 1]
expr: |4

    (
      avg(
        rate(foo_rejections[6h])
        or
        vector(0)
      ) by (colo_name)
      /
      (
        avg(
          rate(foo_total[6h])
       or
       vector(1)
        ) by (colo_name)
      )
    ) > 5
    *
    (
      avg(
        rate(foo_rejections[6h] offset 1d)
     or
     vector(0)
      ) by (colo_name)
      /
      avg(
        rate(foo_total[6h] offset 1d)
     or
     vector(1)
      ) by (colo_name)
    ) and on (colo_name) (colo_job:foo_total:rate2m or vector(0)) > 80
      and on (colo_name) (colo_job:foo_total:rate2m offset 1d or vector(0)) > 80
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 64
                end: 67
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 336
        colo_name:
            reason: Query is using many-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 341
                end: 344
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo_rejections'
          op: ""
        - node: '[*parser.Call] rate(foo_rejections[6h])'
          op: rate
        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h]) or vector(0))'
          op: avg
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 147
                        end: 150
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo_total'
                  op: ""
                - node: '[*parser.Call] rate(foo_total[6h])'
                  op: rate
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
                  op: avg
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 107
                end: 120
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 131
                        end: 137
            deadinfo: null
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
                  op: avg
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 131
                    end: 140
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 131
                end: 140
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 334
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 241
                        end: 244
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo_rejections offset 1d'
                  op: ""
                - node: '[*parser.Call] rate(foo_rejections[6h] offset 1d)'
                  op: rate
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
                  op: avg
            joins:
                - "on": []
                  ignoring: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 320
                                end: 323
                    deadinfo: null
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] foo_total offset 1d'
                          op: ""
                        - node: '[*parser.Call] rate(foo_total[6h] offset 1d)'
                          op: rate
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                - "on": []
                  ignoring: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadinfo: null
                    returns: vector
                    operations:
                        - args:
                            - "1"
                          node: '[*parser.Call] vector(1)'
                          op: vector
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 192
                end: 220
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 334
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 227
                        end: 233
            deadinfo: null
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
                  op: avg
            joins:
                - "on": []
                  ignoring: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 320
                                end: 323
                    deadinfo: null
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] foo_total offset 1d'
                          op: ""
                        - node: '[*parser.Call] rate(foo_total[6h] offset 1d)'
                          op: rate
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                - "on": []
                  ignoring: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadinfo: null
                    returns: vector
                    operations:
                        - args:
                            - "1"
                          node: '[*parser.Call] vector(1)'
                          op: vector
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
            unless: []
            returninfo:
                logicalexpr: 5 * vector(0) / vector(1)
                valueposition:
                    start: 170
                    end: 171
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 227
                end: 236
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
        - "on":
            - colo_name
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_job:foo_total:rate2m'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 357
                end: 382
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
        - "on":
            - colo_name
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 386
                        end: 392
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 386
                    end: 392
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 386
                    end: 395
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 386
                end: 395
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
        - "on":
            - colo_name
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_job:foo_total:rate2m offset 1d'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 424
                end: 459
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
        - "on":
            - colo_name
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 463
                        end: 469
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 463
                    end: 469
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 463
                    end: 472
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 463
                end: 472
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 19
        end: 37
      type: aggregation
      fixedlabels: true
      isconditional: true
    - labels:
        "":
            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 64
                end: 67
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 1
                end: 336
        colo_name:
            reason: Query is using many-to-many vector matching with `on(colo_name)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 341
                end: 344
      deadinfo:
        reason: '`vector(0) / vector(1) > 5 * vector(0) / vector(1)` always evaluates to `0 > 0` which is not possible, so it will never return anything.'
        fragment:
            start: 50
            end: 59
      returns: vector
      operations:
        - args:
            - "0"
          node: '[*parser.Call] vector(0)'
          op: vector
        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h]) or vector(0))'
          op: avg
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 147
                        end: 150
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo_total'
                  op: ""
                - node: '[*parser.Call] rate(foo_total[6h])'
                  op: rate
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
                  op: avg
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 107
                end: 120
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 147
                        end: 150
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 91
                        end: 161
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 131
                        end: 137
            deadinfo: null
            returns: vector
            operations:
                - args:
                    - "1"
                  node: '[*parser.Call] vector(1)'
                  op: vector
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h]) or vector(1))'
                  op: avg
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 131
                    end: 140
                returnednumber: 1
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 131
                end: 140
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 334
                colo_name:
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 241
                        end: 244
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo_rejections offset 1d'
                  op: ""
                - node: '[*parser.Call] rate(foo_rejections[6h] offset 1d)'
                  op: rate
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
                  op: avg
            joins:
                - "on": []
                  ignoring: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 320
                                end: 323
                    deadinfo: null
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] foo_total offset 1d'
                          op: ""
                        - node: '[*parser.Call] rate(foo_total[6h] offset 1d)'
                          op: rate
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                - "on": []
                  ignoring: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadinfo: null
                    returns: vector
                    operations:
                        - args:
                            - "1"
                          node: '[*parser.Call] vector(1)'
                          op: vector
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 192
                end: 220
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 241
                        end: 244
                __name__:
                    reason: Binary operation between two vectors removes metric names.
                    kind: excluded
                    fragment:
                        start: 178
                        end: 334
                colo_name:
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 227
                        end: 233
            deadinfo: null
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
                - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_rejections[6h] offset 1d) or vector(0))'
                  op: avg
            joins:
                - "on": []
                  ignoring: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: included
                            fragment:
                                start: 320
                                end: 323
                    deadinfo: null
                    returns: vector
                    operations:
                        - node: '[*parser.VectorSelector] foo_total offset 1d'
                          op: ""
                        - node: '[*parser.Call] rate(foo_total[6h] offset 1d)'
                          op: rate
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 0
                            end: 0
                        returnednumber: 0
                        alwaysreturns: false
                        knownreturn: false
                        isreturnbool: false
                    position:
                        start: 276
                        end: 299
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
                - "on": []
                  ignoring: []
                  addedlabels: []
                  src:
                    labels:
                        "":
                            reason: Query is using aggregation with `by(colo_name)`, only labels included inside `by(...)` will be present on the results.
                            kind: excluded
                            fragment:
                                start: 320
                                end: 323
                        __name__:
                            reason: Aggregation removes metric name.
                            kind: excluded
                            fragment:
                                start: 262
                                end: 334
                        colo_name:
                            reason: Calling `vector()` will return a vector value with no labels.
                            kind: excluded
                            fragment:
                                start: 306
                                end: 312
                    deadinfo: null
                    returns: vector
                    operations:
                        - args:
                            - "1"
                          node: '[*parser.Call] vector(1)'
                          op: vector
                        - node: '[*parser.AggregateExpr] avg by (colo_name) (rate(foo_total[6h] offset 1d) or vector(1))'
                          op: avg
                    joins: []
                    unless: []
                    returninfo:
                        logicalexpr: ""
                        valueposition:
                            start: 306
                            end: 315
                        returnednumber: 1
                        alwaysreturns: true
                        knownreturn: true
                        isreturnbool: false
                    position:
                        start: 306
                        end: 315
                    type: aggregation
                    fixedlabels: true
                    isconditional: false
                  op: 57384
                  depth: 0
            unless: []
            returninfo:
                logicalexpr: 5 * vector(0) / vector(1)
                valueposition:
                    start: 170
                    end: 171
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 227
                end: 236
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57388
          depth: 0
        - "on":
            - colo_name
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_job:foo_total:rate2m'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 357
                end: 382
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
        - "on":
            - colo_name
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 386
                        end: 392
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 386
                    end: 392
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 386
                    end: 395
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 386
                end: 395
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
        - "on":
            - colo_name
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] colo_job:foo_total:rate2m offset 1d'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 424
                end: 459
            type: selector
            fixedlabels: false
            isconditional: true
          op: 57389
          depth: 0
        - "on":
            - colo_name
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Calling `vector()` will return a vector value with no labels.
                    kind: excluded
                    fragment:
                        start: 463
                        end: 469
            deadinfo:
                reason: The right hand side will never be matched because it doesn't have the `colo_name` label from `on(...)`. Calling `vector()` will return a vector value with no labels.
                fragment:
                    start: 463
                    end: 469
            returns: vector
            operations:
                - args:
                    - "0"
                  node: '[*parser.Call] vector(0)'
                  op: vector
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 463
                    end: 472
                returnednumber: 0
                alwaysreturns: true
                knownreturn: true
                isreturnbool: false
            position:
                start: 463
                end: 472
            type: function
            fixedlabels: true
            isconditional: true
          op: 57389
          depth: 0
      unless: []
      returninfo:
        logicalexpr: vector(0) / vector(1)
        valueposition:
            start: 50
            end: 59
        returnednumber: 0
        alwaysreturns: true
        knownreturn: true
        isreturnbool: false
      position:
        start: 50
        end: 59
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/153 - 1]
expr: sum(selector) / sum(selector offset 30m) > 5
output:
    - labels:
        "":
            reason: Query is using aggregation that removes all labels.
            kind: excluded
            fragment:
                start: 0
                end: 3
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 40
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] selector'
          op: ""
        - node: '[*parser.AggregateExpr] sum(selector)'
          op: sum
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation that removes all labels.
                    kind: excluded
                    fragment:
                        start: 16
                        end: 19
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 16
                        end: 40
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] selector offset 30m'
                  op: ""
                - node: '[*parser.AggregateExpr] sum(selector offset 30m)'
                  op: sum
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 20
                end: 39
            type: aggregation
            fixedlabels: true
            isconditional: false
          op: 57384
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 4
        end: 12
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/154 - 1]
expr: |4-

    count by (dc) (
      max(0 < (token_expiration - time()) < (6*60*60)) by (instance)
      * on (instance) group_right label_replace(
        configured_minions, "instance", "$1", "minion", "(.+)")
      ) > 5
output:
    - labels:
        "":
            reason: Query is using aggregation with `by(dc)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 10
        __name__:
            reason: Aggregation removes metric name.
            kind: excluded
            fragment:
                start: 1
                end: 190
        dc:
            reason: Query is using aggregation with `by(dc)`, only labels included inside `by(...)` will be present on the results.
            kind: included
            fragment:
                start: 7
                end: 10
        instance:
            reason: Query is using aggregation with `by(dc)`, only labels included inside `by(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 7
                end: 10
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] configured_minions'
          op: ""
        - args:
            - '"instance"'
            - '"$1"'
            - '"minion"'
            - '"(.+)"'
          node: '[*parser.Call] label_replace(configured_minions, "instance", "$1", "minion", "(.+)")'
          op: label_replace
        - node: '[*parser.AggregateExpr] count by (dc) (max by (instance) (0 < (token_expiration - time()) < (6 * 60 * 60)) * on (instance) group_right () label_replace(configured_minions, "instance", "$1", "minion", "(.+)"))'
          op: count
      joins:
        - "on":
            - instance
          ignoring: []
          addedlabels: []
          src:
            labels:
                "":
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: excluded
                    fragment:
                        start: 68
                        end: 71
                __name__:
                    reason: Aggregation removes metric name.
                    kind: excluded
                    fragment:
                        start: 19
                        end: 81
                instance:
                    reason: Query is using aggregation with `by(instance)`, only labels included inside `by(...)` will be present on the results.
                    kind: included
                    fragment:
                        start: 68
                        end: 71
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] token_expiration'
                  op: ""
                - node: '[*parser.AggregateExpr] max by (instance) (0 < (token_expiration - time()) < (6 * 60 * 60))'
                  op: max
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 28
                end: 44
            type: aggregation
            fixedlabels: true
            isconditional: true
          op: 57395
          depth: 1
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 131
        end: 149
      type: aggregation
      fixedlabels: true
      isconditional: true

---

[TestLabelsSource/155 - 1]
expr: topk(10, prometheus_build_info*prometheus_ready)
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 9
                end: 47
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_build_info'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] topk(10, prometheus_build_info * prometheus_ready)'
          op: topk
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] prometheus_ready'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 31
                end: 47
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 1
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 9
        end: 30
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/156 - 1]
expr: bottomk(10, prometheus_build_info*prometheus_ready)
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 12
                end: 50
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] prometheus_build_info'
          op: ""
        - args:
            - "10"
          node: '[*parser.AggregateExpr] bottomk(10, prometheus_build_info * prometheus_ready)'
          op: bottomk
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] prometheus_ready'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 34
                end: 50
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 1
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 12
        end: 33
      type: aggregation
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/157 - 1]
expr: histogram_fraction(0, 0.1, metric)
output:
    - labels: {}
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] metric'
          op: ""
        - args:
            - "0"
            - "0.1"
          node: '[*parser.Call] histogram_fraction(0, 0.1, metric)'
          op: histogram_fraction
      joins: []
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 27
        end: 33
      type: function
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/158 - 1]
expr: 'foo * foo '
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 9
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - "on": []
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 6
                end: 9
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57395
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/159 - 1]
expr: 'foo + on(__name__, job) foo '
output:
    - labels:
        "":
            reason: Query is using one-to-one vector matching with `on(__name__, job)`, only labels included inside `on(...)` will be present on the results.
            kind: excluded
            fragment:
                start: 6
                end: 8
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 27
        job:
            reason: Query is using one-to-one vector matching with `on(__name__, job)`, only labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 6
                end: 8
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - "on":
            - __name__
            - job
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 24
                end: 27
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: true
      isconditional: false

---

[TestLabelsSource/160 - 1]
expr: 'foo + on(__name__, job) group_left foo '
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 38
        job:
            reason: Query is using many-to-one vector matching with `on(__name__, job)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 6
                end: 8
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - "on":
            - __name__
            - job
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 35
                end: 38
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 0
        end: 3
      type: selector
      fixedlabels: false
      isconditional: false

---

[TestLabelsSource/161 - 1]
expr: 'foo + on(__name__, job) group_right foo '
output:
    - labels:
        __name__:
            reason: Binary operation between two vectors removes metric names.
            kind: excluded
            fragment:
                start: 0
                end: 39
        job:
            reason: Query is using one-to-many vector matching with `on(__name__, job)`, labels included inside `on(...)` will be present on the results.
            kind: included
            fragment:
                start: 6
                end: 8
      deadinfo: null
      returns: vector
      operations:
        - node: '[*parser.VectorSelector] foo'
          op: ""
      joins:
        - "on":
            - __name__
            - job
          ignoring: []
          addedlabels: []
          src:
            labels: {}
            deadinfo: null
            returns: vector
            operations:
                - node: '[*parser.VectorSelector] foo'
                  op: ""
            joins: []
            unless: []
            returninfo:
                logicalexpr: ""
                valueposition:
                    start: 0
                    end: 0
                returnednumber: 0
                alwaysreturns: false
                knownreturn: false
                isreturnbool: false
            position:
                start: 0
                end: 3
            type: selector
            fixedlabels: false
            isconditional: false
          op: 57383
          depth: 0
      unless: []
      returninfo:
        logicalexpr: ""
        valueposition:
            start: 0
            end: 0
        returnednumber: 0
        alwaysreturns: false
        knownreturn: false
        isreturnbool: false
      position:
        start: 36
        end: 39
      type: selector
      fixedlabels: false
      isconditional: false

---
